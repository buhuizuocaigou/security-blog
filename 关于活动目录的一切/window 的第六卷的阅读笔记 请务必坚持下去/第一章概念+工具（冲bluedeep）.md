### 1.1基础概念和术语
 WINDOW API ：https://www.bilibili.com/read/cv15202035/
针对window 的操作系统 的接口问题  win32API 接口  
关注基本服务以及机理  
调用函数API的分类 针对window而言：
（1）基本服务 （2）组件服务（3）用户界面服务（4）图形跟多媒体服务（5）消息跟协作
（6）网络   （7）web服务
进程线程 内存管理 I/O安全性的内部机理 也就是内核核心底层原理部分 

关于 .NET
提供了FCL 类库 以及托管代码的平台 运行库 CLR  
![[Pasted image 20240929211938.png]]
指的是 dll 是个动态链接库像个公共仓库一样，负责将其他的散落在各地的源代码组织连接起来的过程 
插入：
托管代码VS非托管代码 
什么是托管代码 ：托管代码指的是在执行过程中运行时候管理的代码 ，在这种情况下 运行成为公共库 ，CLR 指的就是公用库  他相当于不用去考虑类似内存管理，地址分配，是否会溢出等问题，其由代码内部库自动定义并完成 
比如自动内存管理机制等  属于上层代码管理机制系统 既运行的时候的高级语言体系 
如 .NET ，NET Framerwok 等 

非托管代码 ：不托管的事事都需要读者考虑到的机制，比如 C  C++等 编写他们的时候需要细节的考虑内存管理，是否溢出等问题 

其托管代码上层 如何跟操作系统建立联系 呢？需要统一的通过一个机制 叫做CLR运行机制 ，来当做中介站建立联系 

服务函数跟例程 ：中的代码段函数如下：
例程 ：rouontie 指的是一个可以被重复利用的代码儿 类比与数学中的解模型 
通常不异步或者串行执行  一般是 同步执行信息 
线程是一个独立的代码单元  
多个线程组成一个进程 
有如下几个单元：
1 windows API函数 ：
已经被文档化的可以被调用的子例程  
2 原生的系统服务 系统调用  
指的是未被文档化的代码服务端 

PS：文档化 ：指的是已经综合整理为官方文档的内容机制 ：官方可公开开源的
未文档化：就是指的是没有被官方整理为文档的一种机制模型 ，需要逆向工程跟多种手段来做这些 

少一步 在细节分析后记得及时回顾梳理 大纲整理思维导图放出来

内核支持的函数例程：
位于诚信通的内部 且正在内核模式下的例程 
例如 啮合例程 NtCreateUserProcess 是内部系统服务 ，这个服务存在于window系统内部
且window 的CreateProcess 函数可以调用 并且调用该例程可以向系统堆 也就是内存池中申请 
就是相当于管理员权限？
Windows服务：指的是windows服务管理器启动的进程  例如 Task Scheduler 服务虽然云心瓜子啊用户进程中 他可以执行自动化的命令，并且提供日志系统。
DLL动态链接库：
一组可以调用的子例程  子例程凑一堆可以动态加载（运行时可以更改）二进制文件 
window 保证在内存中只有一种dll 代码 
并且 合起来链接二进制文件 ，动态加载二进制文件 dll库 

dll动态库优势是可以被所有应用程序共享   。NET也被编译成dll 并不会导出任何子例程  


进程线程跟作业：


程序：静态的指令序列 的模型 
进程：容器=执行程序忒都给你示例的各种资源 
window的进程组成元素 ：
1 私有的虚拟地址空间  虚拟空间不在如同普通操作系统一样共享 ，而是变得独一无二起来

2可执行的程序 定义出事代码跟数据 且可被映射到虚拟地址空间 
	新概念 句柄：操作系统中标示操作，某些资源的抽象引用 ，类似编号或者代号，通过句柄分配管理资源，句柄访问资源 （大型的“指针”）
	句柄的特殊点：当请求的资源时候，操作系统分配的是==唯一==的句柄给资源 ，而指针可以对多一 一对多
    经典计算机设计思想，封装处理思维 ，将复杂的指令进行封装处理，适当的懒改变世界啊

3 一打开句柄的列表，这句柄指向的是多种资源 信号量 通信端口跟文件等
进程中所有线程都可以通过这个来访问这些系统的资源 ，
4  访问令牌的安全环境 表示了进程管理啊男用户 安全组 特权 UAC 虚拟化状态 会话等  
5PID 存在 进程ID 的唯一标识符 
6 至少一个执行的线程（与空线程做对比 ）

注意 ：特点：每个进程“承上启下” 并且父进程不存在的话 不会影响子进程更新  即使往上的句柄指向的是不存在的父进程，整个程序依旧可以运行下去，因为私有虚拟地址空间的问题，他不需要跟父进程的空间进行共享 而是自己单独享有这一部分，从而导致即使父进程不存在的话自己衣蛾亏利用并且存储细腻系

### 实验一.1 查看进程树 
利用 性能监视器 PERFORMANCE MONITOR  查询 CREATING PROCESS ID 来获取这个属性 
利用Tlist.exe工具

