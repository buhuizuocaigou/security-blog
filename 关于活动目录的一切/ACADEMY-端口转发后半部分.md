从chisel开始
### 实验Chisel 进行SOCKS5隧道传输
chisle 进行socks 隧道传输  基于http传输使用的ssh保护数据信息创建客户端 服务器的隧道连接 
工具所在的地址:https://github.com/jpillora/chisel
使用场景 ：
场景为已知 枢纽ip 内网ip网段 ，且枢纽机为linux机器 ，且枢纽机可以在内网网段中运行出来，
目的：通过枢纽机搭建隧道并且链接内网到外网。让在外网的攻击机可以访问 内网的服务器地址：
目标是将 攻击机跟枢纽机之间搭建一条隧道并且这条隧道 可以允许流量通过转发 ：
![[Pasted image 20241115114032.png]]
这张图告诉我们是可以 一个server 配套多个client的 
默认是 ：从攻击机发送链接请求 也就是攻击机作为客户端 而枢纽机作为客户端来搭建请求通知  
如果要是 反过来的话 在攻击机上搭建server 然后 在客户端执行clent的话 需要执行选项-reverse 来表明是反向链接 并且需要 R：socks5 

所以 在reverse 的情况下是 指的 当出现 枢纽机向 攻击机发送报文数据的时候用
攻击机ip：![[Pasted image 20241112210048.png]]
枢纽机ip：ssh 链接 ip地址为： ubuntu ”和密码“ HTB_@cademy_stdnt！ ” 通过 SSH 连接到10.129.146.63 
当无ssh搭建动态端口的时候可以考虑这个工具信息 

第一步 git clone 拷贝下来
第二步 使用这个工具  

插入：Chissel 的背后的原理以及信息内容
文章来源学习：
https://www.youtube.com/watch?v=Yp4oxoQIBAM&t=1469s
0xdf的文章信息：
https://0xdf.gitlab.io/cheatsheets/chisel
在上述文章中我们可以知道，不仅可以缩小这个chisel的大小以逃避某些防火墙检测，同时还可以进一步压缩加壳已达到对抗防火墙的目的 
：
利用go 的特性来压缩文件的命令：
`go build -gccgoflags= "-s -w "`
其中各大名词解释如下  ，在使用中  这个命令 -gccgoflags 跟-ldflags的区别在于 -ldflags 是针对go编译器版本做的 而gccgo 是另外一个编译装置，需要区分这两个编译的不同，注意细节理解。

此番的目的是为了取出go文件中的 -s ：go的符号表 -w DWARF信息调试信息，这个主要负责在调试 的时候在源代码之跟二进制文件之间建立映射，对于渗透测试而言，去掉这些有助于帮助我们更好的对文件进行压缩 以及防止他们被ips防火墙侦查到位

同理 利用upx装置可以更好的对其再次进一步压缩，但是仍要防范那些检测装置 检测到upx壳后报警 

然后再压缩完文件后我们需要将文件传入到 指定的枢纽中 ，除了使用之前提到的scp外还可以借助nc去传输文件
在攻击机上使用：![[Pasted image 20241113220512.png]]
这个含义是为了 nc -监听他们的端口80上的内容  将chisel这个文件的信息通过80端口连接到对面  ，
等待对面反连 

而在ssh链接好的受害者的机器上 可以采用的是：
![[Pasted image 20241113220621.png]]
这个句话的含义是 调用bash -c 的命令台 执行 cat  < 使用的是 一个 tcp短期的链接端口装置 进行传输文件信息  其中 tcp简易端口的 格式为 /dev/tcp /ip地址 /80端口 >并且命令将chisel这个文件通过这个端口号传输给对面。

在执行完后 检测一下他的MD5sum的信息值 做个对比 防止文件中间遭到人为篡改 ，证明没有人删除过这个  或者修改过这个文件信息 
谨慎 因为速度实在太慢

![[Pasted image 20241113220826.png]]
scp -r  -r 指的是目录
傻逼 在枢纽机中缺少版本库 然后无法执行go的函数内容 
原因是glibc动态编译库不符合标准版本需求 故采用静态编译的内容去实验
为了避免出现问题 第一反应是先采用的是静态链接的功能为主，防止因为glibc版本差异导致问题发生

插入：
将 chisel进行静态编译：
重点是静态编译跟动态编译 基础知识补足在：
csapp的第七章 
以及 链接编译跟库这本书中的内容

具体静态编译步骤如下：
先去git上获取源码后进入到chisel界面 如下图所示：
![[Pasted image 20241115113354.png]]
获取完源代码后 ：
进入目录执行如下指令：
`CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -a -tags netgo -ldflags '-extldflags "-static"' .`
然后具体解释等待读完两本书中相关章节后再次来细节复现 


执行在静态编译完成后 执行
`ldd chisel`
观察到：![[Pasted image 20241115113620.png]]
观察到这个 不是动态可执行文件后可以方便的发送到枢纽机中去

然后 scp -r 文件名 ububnt@ip地址 :想在ssh上面存放的路径
密码  后 即可传输到指定枢纽机 
在枢纽机上 选定一方作为client 也就是 发送数据的端口 
一方作为server 也就是服务端 意为 打开监听的端口装置内容 ，
注意：对于chisel的工具而言 
从 攻击机 （client）--->枢纽机 server （正向）
、在server 的 代码如下：打开监听
`./chisel server -v -p 1234 --socks5`
指定强制为socks5 且-v 打开日志 观察打开的监听端口是啥，然后-p指定监听端口是1234 

此时 攻击机 执行
`./chisel client -v 枢纽机ip:打开的端口号  socks `
告诉你链接的时候是socks 的协议 
然后你会看到如下所示：
![[Pasted image 20241115120005.png]]


![[Pasted image 20241115120028.png]]
c及诶是成功链接 其中日志中 的 ：![[Pasted image 20241115120101.png]]
倒数第四行 中的1080 揭示了 隧道向外打开的端口号 内容的值 
为1080端口
此时隧道搭建成功 然后需要再proxychains 的代理配置界面最后把本地连接的 1080端口 允许通过 sock5代理链接到内网 加入后的 
配置如下：
![[Pasted image 20241115120507.png]]
-f解释为数据的一种附加状态 信息
注意最后一行加入了 127.0.0.1 1080 的socks5的本地端口转发 

如果是反向的话 记住在 

![[Pasted image 20241115120721.png]]
告知咱们两点信息 
信息一：当服务端使用的--recerse反向链接后 也就是服务端在攻击机运行  时 一定要加入 --reverse
与此同时在客户端中 末位加入 R:socks这个 类型  这里解释了 Rsocks的使用方式  且默认的端口是1080 

使用socks 的icmp隧道
对于icmp而言 ，如何判断是否使用icmp 既如何搭建起来icmp隧道体系呢 答案是。当且仅当 防火墙内部可以用ping命令的时候他可以执行
可以通过隧道的方式进行启动并且进行连接，然后 可以通过将数据卫生状并且包装在 里面来达到目的
利用工具 :
https://github.com/utoni/ptunnel-ng
为什么要使用静态链接编辑工具后并且进入到系统当中学习。
因为动态链接工具中的libc 的动态链接库 配置版本不同会导致差异 ，如果是静态链接的话，是人为指定链接编译而不是去自动匹配的


### 使用dnscat2进行dns隧道偷摸传输数据

通过dns协议内的TXT记录内发送数据  加密的 C2通道  dns协议中发送数据，每个域环境都有自己的dns服务器  将主机名解析为 IP地址，将流量发送到dns服务器中，注意 是 
在dnscat2使用的税后 使用的地址解析从外部请求而不是本地的dns解析。并且 不能让dns数据泄露被网络请求 这是一种非法的dns请求 ，所以使用了dnscat2 

攻击机下载 dnscat2：
![[Pasted image 20241124114257.png]]
从这里github上可以知道 这写安装步骤 
现在信息如下：
攻击机ip：
![[Pasted image 20241124114351.png]]
然后 受害者 的 也就是在内网中的ip如下 ：
![[Pasted image 20241124114523.png]]
这台window枢纽机 的信息如下 ：已知 我们可以通过rdp连接到windwo枢纽机 或者说某种ssh方式链接进枢纽机 通过命令行/图形化的方式获取到这台主机的攻击权限以及攻击方式，然后这台机器的ipcofig信息提示有两个ip地址 其中一个ip为：10.129.42.198这台ip地址的信息是属于介入openvpn
中所研究的内容 ，而ip地址为 ：172.16.5.150这一台ip地址所探究的内容是介入内网的部分的ip。它相当于是搭建了一个通道平台 平台的两端一个是 外网部分 另一个是内网部分
通过建立 但是网络隧道未搭建成功 显示404not found http服务器炸了 所以说 这部分具体请看详情内容 这部分前提等到网络良好的时候即可解锁

### 使用socks的ICMp隧道传输相关知识点 ：

ICMP的话防火墙网络隧道中允许ping相应 的时候 随机起了链接 内容 进行回显以及连接到外部服务器的枢纽隧道中，其中 代理流量访问 到中间的枢纽主机上 
采用工具：https://github.com/utoni/ptunnel-ng
然后具体操作先克隆岛 攻击机中 然后 构建静态二进制文件，并且把文件发送到主机中
原因是如果构建的时候动态的文件的话。在枢纽机的链接改文件的环节中，可能会导致因为版本不同差异而导致 无法成功编译运行，所以 为了能正常运行下去的话，只能采用这种方法去做
攻击场景如下：
攻击ip：![[Pasted image 20241124160057.png]]
已知的可以ssh链接的枢纽机ip：
![[Pasted image 20241124160134.png]]
其中有两个ip地址 第一个ip地址为：10.129.46.17 这个ip地址是为了链接到攻击机的ip
第二个ip地址是 ens224显卡中展示的 这个是介入到受害者内网ip 172..16.5.129 因为这台机器又能介入内网又可以链接外网 所以把它当做枢纽机进行操作 


第一步 先克隆到攻击机中 
![[Pasted image 20241124160033.png]]

关于静态编译操作 理解如下：
原始脚本内容如下
```
#!/bin/bash

set -x

OLD_WD="$(pwd)"
NEW_WD="$(dirname ${0})"

cd "${NEW_WD}"

if ! autoreconf -fi; then
    aclocal
    autoheader
    automake --force-missing --add-missing
    autoconf
fi

cd "${OLD_WD}"

"${NEW_WD}/configure" $@ && make clean && make -j${BUILDJOBS:-4} all
```
解释如下：
1 以bash解释器为基准 
2 `set -x`启动调试模式及时监控脚本命令以及参数 
3 `OLD_WD="${pwd}"`  `NEW_WD="${dirname ${0}}"`
`OLD_WD：记录了脚本的工作目录`
`NEW_WD`:记录了所在的目录的路径 
`$(0)`脚本的文件名 dirname =是获取其所在文件的路径内容 
4`cd "${NEW_WD}"`这个是切换脚本所在目录 因为他被赋予到 了一个变量名为 NEW_WD的变量里，所以切换到这个变量所在的目录下面
中间设计到的是编译原理的东西 


### 四：使用socks over rdp 进行rdp 跟socks 隧道传输 
使用场景。当在评估中无法使用 windows网络 无法用ssh进行数据透视，的时候 需要借鉴与windwo操作系统内部的工具系统  
使用的工具是window自带的 https://github.com/nccgroup/SocksOverRDP
他是DVC 也就是window自带的构造RDP 的链接隧道传输数据包。展示了 一些使用的实力，包括剪贴板传输数据等，使用 socks over rdp 隧道传输自定义的数据包后 进行自定义代理等  使用 PROxifier作为代理服务器
在漏洞复现的时候注意 如下：
1 在 枢纽机端应注意将windwo安全下的 real-world的防病毒关闭，防止误删除此软件 
2  将socks over










![[Pasted image 20241126162709.png]]![[Pasted image 20241126162851.png]]
如上图所示成功介入 
