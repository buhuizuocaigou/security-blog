从chisel开始
### 实验Chisel 进行SOCKS5隧道传输
chisle 进行socks 隧道传输  基于http传输使用的ssh保护数据信息创建客户端 服务器的隧道连接 
工具所在的地址:https://github.com/jpillora/chisel
使用场景 ：
场景为已知 枢纽ip 内网ip网段 ，且枢纽机为linux机器 ，且枢纽机可以在内网网段中运行出来，
目的：通过枢纽机搭建隧道并且链接内网到外网。让在外网的攻击机可以访问 内网的服务器地址：
目标是将 攻击机跟枢纽机之间搭建一条隧道并且这条隧道 可以允许流量通过转发 ：
![[Pasted image 20241115114032.png]]
这张图告诉我们是可以 一个server 配套多个client的 
默认是 ：从攻击机发送链接请求 也就是攻击机作为客户端 而枢纽机作为客户端来搭建请求通知  
如果要是 反过来的话 在攻击机上搭建server 然后 在客户端执行clent的话 需要执行选项-reverse 来表明是反向链接 并且需要 R：socks5 

所以 在reverse 的情况下是 指的 当出现 枢纽机向 攻击机发送报文数据的时候用
攻击机ip：![[Pasted image 20241112210048.png]]
枢纽机ip：ssh 链接 ip地址为： ubuntu ”和密码“ HTB_@cademy_stdnt！ ” 通过 SSH 连接到10.129.146.63 
当无ssh搭建动态端口的时候可以考虑这个工具信息 

第一步 git clone 拷贝下来
第二步 使用这个工具  

插入：Chissel 的背后的原理以及信息内容
文章来源学习：
https://www.youtube.com/watch?v=Yp4oxoQIBAM&t=1469s
0xdf的文章信息：
https://0xdf.gitlab.io/cheatsheets/chisel
在上述文章中我们可以知道，不仅可以缩小这个chisel的大小以逃避某些防火墙检测，同时还可以进一步压缩加壳已达到对抗防火墙的目的 
：
利用go 的特性来压缩文件的命令：
`go build -gccgoflags= "-s -w "`
其中各大名词解释如下  ，在使用中  这个命令 -gccgoflags 跟-ldflags的区别在于 -ldflags 是针对go编译器版本做的 而gccgo 是另外一个编译装置，需要区分这两个编译的不同，注意细节理解。

此番的目的是为了取出go文件中的 -s ：go的符号表 -w DWARF信息调试信息，这个主要负责在调试 的时候在源代码之跟二进制文件之间建立映射，对于渗透测试而言，去掉这些有助于帮助我们更好的对文件进行压缩 以及防止他们被ips防火墙侦查到位

同理 利用upx装置可以更好的对其再次进一步压缩，但是仍要防范那些检测装置 检测到upx壳后报警 

然后再压缩完文件后我们需要将文件传入到 指定的枢纽中 ，除了使用之前提到的scp外还可以借助nc去传输文件
在攻击机上使用：![[Pasted image 20241113220512.png]]
这个含义是为了 nc -监听他们的端口80上的内容  将chisel这个文件的信息通过80端口连接到对面  ，
等待对面反连 

而在ssh链接好的受害者的机器上 可以采用的是：
![[Pasted image 20241113220621.png]]
这个句话的含义是 调用bash -c 的命令台 执行 cat  < 使用的是 一个 tcp短期的链接端口装置 进行传输文件信息  其中 tcp简易端口的 格式为 /dev/tcp /ip地址 /80端口 >并且命令将chisel这个文件通过这个端口号传输给对面。

在执行完后 检测一下他的MD5sum的信息值 做个对比 防止文件中间遭到人为篡改 ，证明没有人删除过这个  或者修改过这个文件信息 
谨慎 因为速度实在太慢

![[Pasted image 20241113220826.png]]
scp -r  -r 指的是目录
傻逼 在枢纽机中缺少版本库 然后无法执行go的函数内容 
原因是glibc动态编译库不符合标准版本需求 故采用静态编译的内容去实验
为了避免出现问题 第一反应是先采用的是静态链接的功能为主，防止因为glibc版本差异导致问题发生

插入：
将 chisel进行静态编译：
重点是静态编译跟动态编译 基础知识补足在：
csapp的第七章 
以及 链接编译跟库这本书中的内容

具体静态编译步骤如下：
先去git上获取源码后进入到chisel界面 如下图所示：
![[Pasted image 20241115113354.png]]
获取完源代码后 ：
进入目录执行如下指令：
`CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -a -tags netgo -ldflags '-extldflags "-static"' .`
然后具体解释等待读完两本书中相关章节后再次来细节复现 


执行在静态编译完成后 执行
`ldd chisel`
观察到：![[Pasted image 20241115113620.png]]
观察到这个 不是动态可执行文件后可以方便的发送到枢纽机中去

然后 scp -r 文件名 ububnt@ip地址 :想在ssh上面存放的路径
密码  后 即可传输到指定枢纽机 
在枢纽机上 选定一方作为client 也就是 发送数据的端口 
一方作为server 也就是服务端 意为 打开监听的端口装置内容 ，
注意：对于chisel的工具而言 
从 攻击机 （client）--->枢纽机 server （正向）
、在server 的 代码如下：打开监听
`./chisel server -v -p 1234 --socks5`
指定强制为socks5 且-v 打开日志 观察打开的监听端口是啥，然后-p指定监听端口是1234 

此时 攻击机 执行
`./chisel client -v 枢纽机ip:打开的端口号  socks `
告诉你链接的时候是socks 的协议 
然后你会看到如下所示：
![[Pasted image 20241115120005.png]]


![[Pasted image 20241115120028.png]]
c及诶是成功链接 其中日志中 的 ：![[Pasted image 20241115120101.png]]
倒数第四行 中的1080 揭示了 隧道向外打开的端口号 内容的值 
为1080端口
此时隧道搭建成功 然后需要再proxychains 的代理配置界面最后把本地连接的 1080端口 允许通过 sock5代理链接到内网 加入后的 
配置如下：
![[Pasted image 20241115120507.png]]
-f解释为数据的一种附加状态 信息
注意最后一行加入了 127.0.0.1 1080 的socks5的本地端口转发 

如果是反向的话 记住在 

![[Pasted image 20241115120721.png]]
告知咱们两点信息 
信息一：当服务端使用的--recerse反向链接后 也就是服务端在攻击机运行  时 一定要加入 --reverse
与此同时在客户端中 末位加入 R:socks这个 类型  这里解释了 Rsocks的使用方式  且默认的端口是1080 











使用socks 的icmp隧道
对于icmp而言 ，如何判断是否使用icmp 既如何搭建起来icmp隧道体系呢 答案是。当且仅当 防火墙内部可以用ping命令的时候他可以执行
可以通过隧道的方式进行启动并且进行连接，然后 可以通过将数据卫生状并且包装在 里面来达到目的
利用工具 :
https://github.com/utoni/ptunnel-ng
