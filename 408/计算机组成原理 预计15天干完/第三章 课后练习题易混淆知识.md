类型一：半字寻址 易混淆 

![[Pasted image 20240726165558.png]]
首先  cpu半字寻址   根据机器字长32位得知 半字 就是一次寻址的时候16个位寻址 ，
16个位=8个位是一个bit(B) 16个位相当于是2个B 
16mb/2b得到最终解 可寻址单元数
 易错的知识点 是 字跟 位 跟bit B 区分不清晰导致 

类型二 ：![[Pasted image 20240726165837.png]]
关于命中率的考核 方式 ：
命中率 指的是 cache 也罢 ，主存也罢 的 有效命中的几率，真正有效的部分站多少 
此题解题思路：
线索点 1 ：主存与cache同时访问 ，
2 提问的是cache命中率  设他是x 
```
x * 100ns +(1-x)1000ns<=100ns*115%
```
易错的地方 ：  由于同时访问  访问了cache 也就是cache命中代表 暗示主存未命中 

类型三 概念区分 ：
1 ![[Pasted image 20240726170135.png]]
这个是错误的 原文如下：
![[Pasted image 20240726172250.png]]
主存跟cache 是对 程序员透明，主存跟辅存 因为是对操作系统有相关联系 故他是对应用程序员透明的一个东西 
2![[Pasted image 20240726172354.png]]
EPROM 
可擦写可编程存储器  非易失 性存储器  可以重复使用的存储器 主要用于只读存储机制，但是采用了随机存取的方式 ，用户可以通过特定的地址直接读取任何存储位置的数据 

DRAM ：
典型的随机存储器机制 ，允许直接访问存储器中的任何的位置，存取速度很快，并且 适合用作计算机主存储器 

SRAM：随机存取存储器 具有高速度跟稳定性，匀速任意时刻访问任何存储的单元 高速缓存 

CD-ROM ：带cd俩字 是一种光学存储机制 进行串行存储体系，排排站 并且先后顺序输出 


存储器 之易失性存储器 跟 非易失性存储器 

类型 一：存储器类型 ：
EPROM：可擦除 可编程 只读存储器 断电后数据依旧保存 非易失性存储器
应用  工控，固件存储等 早汽车电子  ECU等 
Flash 存储器  ：非易失性存储器  可靠性 速度快  
电源关闭后 依旧能保持不丢失  高速读写  ，例如 NANDflash  用于固态硬盘ssd  等 

类型二 ：生活中的一些存储介质 ：
U盘 机制 次啊用的是NANDflash存储芯片 机制 电子的非易失性存储器 
![[Pasted image 20240726202112.png]]
硬盘上的内部存储器的机制：
在操作系统中  的haul 引入 bios 机制 ，ROM 存储这启动操作系统核心的部件 其他部件 例如内存选择器等机制的话 他存放在 RAM 跟ROM上其中利用的是 BIOS 或者UEFI 将他们链接 
类型三 关于异步刷新的 机制 
![[Pasted image 20240726203624.png]]
异步刷新 可以看成是 将 2ms 分散到短短的每一次当中 这些细小的每一次累计起来 一共是2ms  其中 需要弄明白到底需要多少次 

在64k中  一共有 2的6次方 x 2的10次方个b 
然后  这些用行和列 进行表达 ，评分为  一个为 2的8次方 也就是构成 256x256个 这么多个面积   
有256个行 跟256 个列  其中 在这些行列中  需要刷新次数  当集中刷新是 也就是 将每一个堆到最后面  ，在刷新的时候cpu跟 该芯片的交流是终止的 ，这就导致一个显著的问题：一共会集中暂停256次 
在256次中 要平均分配到2ms中 
也就是每一次要执行 2ms/256那么多，这就是异步刷新的机制的概念


SDRAM：是一种同步动态的随机存储存货曲奇   重点是同步操作  
SDRAM  中的行缓冲器 是 用sdram来实现的 

关于单体多字存储器的一些 问题：
采用的是流水线的机制进行存储并运行 假 并行实际上是串行输出的 一个东西 

多模块存储器 ：
1 高速元器件：

RAM vsROM ：
 1 RAM ：随机存取的存储器   易失性的存储器，一旦丢失不容易找到 
 读写速度快  ，
 分为 DRAM 周期刷新 跟SRAM 不需要谁像你的 
2 随机存取的能力  不需要按照顺序访问  可以频繁的读写数据
缓存  RAM用作缓存 ，并且是拥有极快的读写速度 适合频繁访问并修改数据 
以 sram 常用于cpu缓存
3 这个需要定期刷新
ROM: 
1非易失性存储器，电源断开后 数据不会丢失  
2 分为 PROM  EPROM  EEPORM  FLASHROM（BIOS）传说中的闪存就是这种类型   这几种类型
3大部分只能读去不能写入  部分读的很快写的很慢慢  大量存储长期不变的数据
4由于缓存 需要经常性的读写  这个速度太慢了 故不经常用于缓存 
5不太需要刷新  因为数据固定   

总结 ：数据固定带来的一定的影响是  对于rom而言 其数据需要只能读写  且 大部分为只读   由于不需要频繁的进行数据交换 故 不能用做cache  以及不会 经常刷新 


经典题型：

![[Pasted image 20240727152240.png]]
这道题选A   他归结于 ROM 这一类 且 d 仲可以代替计算机外部存储器 比如 USB 等 硬盘等等 光盘等等闪存存储 东西 采用的也是闪存这一技术手段
![[Pasted image 20240727152535.png]]‘这道题中  关注 对于 4M x8位的而言 ：
4m 代表的是地址总线   的大小  4mb=2的22次方    
8位传达的是 一共八根 一共8位的数据总线  也就是8跟 
对于dram芯片而言 采用的是地址复位 也就是说 22根的地址总线中 有11根 在用 排成11行11列的形式 
故 一共有 11+8=19根  

![[Pasted image 20240727152852.png]]
其中 首先把 ROM 跟flash排除 为啥呢 因为这俩就属于ROM 类别 无刷新的那一回事 
其中  关于SRAM 跟SDRAM 的对比如下：
SRAM： 
采用的是双稳态触发器，存储bit数据  电源不断 就会保持稳定  cpu缓存 
SDRAM ：是一种 dram  使用电容器刷新 必须周期性刷新因为电容会逐渐泄露等问题的存在 

![[Pasted image 20240727153718.png]]
采用的考核点  
考核点1 ： 交叉编址  中用 的是 两种模式  一种是轮流启动模式 一种是 同时启动 模式 
这题中并行 读写32位 数据宽度总线也是32位刚好相同  
出题人中交叉编址 默认为 低位交叉编址 ：
这道题 学完了指令部分在回头看 ！！
![[Pasted image 20240727160846.png]]
尽量减少刷新开销  指的是 尽量减少其 行列的 差值 差值越大 刷新开销越大 
保证其地址引脚数 最少  地址引脚数  主要是行数目 总数是 一共 11根  
bc 之间 c 的行数更少 所以选c

![[Pasted image 20240727161233.png]]
名词解释 ：
1 突发（brust ）传送：
这个是 允许在一次传输操作中连续传输地址 链接或者发送

一次激活一个行  
在 做a的时候记得 将位 转换为 b  这个不一一昂  ！！！！！！！ 所以 512mb是对的 
芯片采用多路 地址引脚 评分  应该是 13x2 的形式 

行缓冲 指的是  访问特定数据的时候 哦提供弄过行地址选择 并且激活对应的行进行选择  
然后 激活的行数据被加载进行缓冲当中 ，郑航数据暂存进行缓冲区当中进行 
2 行缓冲读取跟写入 对于上述而言 是8192x8 这么多行缓冲   
所以选择c

burst 传送方式 ：
指的是可以在一次传送中传输 多个数据单元的行为  
其传送过程如下：
1 初始化： 传输开始前设置传输起始地址跟burst的长度
2 发送初识的控制信号 提示即将进行 
开始传输数据 ，当数据开始传输的时候 数据单元按照预定的burst长度连续传送 
并且数据可以在多个时钟周期内传输 取决于系统时钟跟传输速度的问题 


关于大题 的解析 理解
![[Pasted image 20240727162333.png]]
在显示适配器中存放显示信息的存储器 称为刷新存储器 重要作用是贷款 
其带宽 是   1024x768x72x3b x50% 即可 

其技术措施 ：
1 可以采用高速存储器  2 提高存储器的总线宽度  增加存储器数据的总线宽度并且让每次传输数据提升  
2 优化内存的控制器效率  
3减少数据传输的瓶颈等  
![[Pasted image 20240727171606.png]]
提问 数据线 32根 代表了32位  其 地址总线24根 表示是 2的24次方这么多跟 去除以 512k x8位 
![[Pasted image 20240727171902.png]]
第七题中 ：  逻辑如下  ：从地位开始  判断 存储芯片用了多少位 也就是说 存储芯片上的数据总线需要有 4x2的10次方 也就是2的12次方 也就是12条  这十二条 从低位开始排 占据了从A15-A4的位置 一共是 12个    然后 16kb除以 4k需要用4各个片选信号 也就是一共得4片 4 用二进制 00  两位就额可以表示  所以说 在从A4 往前数2个位置 也就是 A2 A3   
其中A0 A1做闲置处理 
![[Pasted image 20240727172730.png]]
内存地址区间为 4000H --43FFH  因为地址从0开始 所以 总的地址位 是43FFH -4000H +1  因为从0开始所以加一  然后，等于400H  换算成二进制是 100 0000 0000 为 2的十次方  然后大小是1k 
所以  1kx16x4 结果是 

一共是 占了这么多的地址区间  然后其地址区间内部一共有 4片 问的是每片芯片容量占多少

![[Pasted image 20240727174818.png]]
片选地址3位 占三根     
32k x16位地址 用15根 就可   
一共是 15+3=18根    18根 地址总线    高三位 是11 10000000 00000000十五个0 
范围从 11 10000000 00000000  - 11 11111111 1111111 


![[Pasted image 20240728143728.png]]
易混淆知识 ：
理解 直接看 主存空间大小地址 根据他 的情况配置mar的大小  
主存里面包含有 =主存储器+MAR 存储器地址寄存器的位数。
主存地址  就跟一个大仓库一样  大仓库里面放着的是主存储器跟 MAR的地址寄存器，MAR 的位数要看外部大仓库的位数决定 最终结果，而不是看 主存储器的 32mb 芯片决定的 
因为mar产生的信号是给芯片来决定用哪个的  地址


![[Pasted image 20240728144317.png]]
这道题 ：总量是64kb 然后按照字节编制  
已知 rom区是有 2000H 这么多    也就是   2的13次方 这么多 也就是8kb 这么大   
容量是64kb -8kb = 56kb （RAM区的）
56kb 的  在8kx4位的芯片下  注意 按字节编址也就是说  
按字节编址  4位是0.5字节  8kb x4位= 4kb 这是按字节的大小
56kb/4kb=14个 所以是14个 
注意按字节编址的考虑方式   以及 计算逻辑  

![[Pasted image 20240728145842.png]]
首先判断是否需要采用地址复位技术 
地址复位的 使用场景是  地址线不够用了 ，采用这种技术  所以首先判断是否够用 
我的 ram芯片的大小是512k 而2的24次方远大于这个  所以够用  故 不用考虑地址复用 
同理 32位的数据线 对应的字长是32位 故 刚刚好直接用即可 

他有个逻辑 首先按字编址 =  在32位下  32/8= 4个  也就是说 4个字为一体 ，
给的地址 的大小是 2的23次方。并且去除以 512kx8位  这8位相当于1个字 但是 32位情况按字编址的话是 4个字一组 相当于是1/4的量 所以要记得乘以1/4
![[Pasted image 20240728151130.png]]
一个大的 仓库 总共是2的30次方根地址线  按照字节编制 ，沾满空间 ，故 2的30次方除以4 分配 
分配好后  搞地质为最高位 是 4000000H  但是 别忘了 显示的时候从零开始！！！！！！
记得减一 
![[Pasted image 20240728155609.png]]
A与B 的差异  B中  RAID 主要提升的是磁盘与磁盘之间的 调度问题 
核心原因是因为他是串行运行 并行转串行   磁盘还是那么多的密度，能存放的东西还是那么多但是 磁盘之间互相配合的关系更为紧密 了 。这个是核心内容  
![[Pasted image 20240728160119.png]]
选项B ：  具体解释如下：
采用 直接存储器 DMA的方式进行输入/输出 I/O 是一种高效的数据传输的方法，并且CPU在数据传输过程中的参与，提高系统的整体的性能，这是对于DMA的详细解释 ：
DMA定义：DMA指的是一种允许外设 直接于系统内存进行交互的技术 不经过CPU的干预  
不需要经过CPU的干预，DMA专门控制 系统内存---->外设 的技术 

工作原理 ： 
1 初始化 ：CPU 告诉他的小弟，为某个外设进行数据传输 
初始化 需要 的内容是：（1）设置源地址（外设的I/0端口） （2）目标地址（系统内存中的地址）
    方向 从外设方向流入内存方向    （3）目标地址 内存的地址  （4）数据块的传输 
2 启动传输：外设告诉 DMA 我准备好了，DMA接收到后 开始执行数据拆书 
3 数据传输：DMA接管系统总线，直接把数据从源地址 （外设 ）到目标地址内存   或者反着穿 这个流程跟cpu没关系  
提升效率  
DMA是cpu的小弟

选项C：
按批处理方式进行一个数据块的读/写 ：
批处理是 一次处理一堆东西 学名叫做批处理 ：可以提升效率   
不看字节 引起的 ：
![[Pasted image 20240728162134.png]]
7200/min = 120/s x160x512/1024B    因为最后的 单位是kb  
注意单位  字节是b   题目中的是 kb

![[Pasted image 20240728162829.png]]
磁道的问题 ：
![[Pasted image 20240728162856.png]]
60mb  的 总容量  200个磁道   只需要计算一圈 的时间就行 
200磁道  平均一个磁道 是60/200这么多个mb的内容  这么多个内容 用 25ms-1.25x8= 15ms
0.3/15ms= 20mb/s
知识点 ：
1 固态硬盘的擦除以块儿为单位进行 擦除计划          不是以页 读写是以页 但是擦除是以块儿 
![[Pasted image 20240728211422.png]]
这四个机制 分别为 ：
磁盘镜像   RAID 1  增加第二个磁盘 一模一样的磁盘 复制粘贴做备份
当一个 磁盘发生故障的时候能通过镜像存储提取备份 的衣蛾寡妇年  


条带化  ：RAID0  提高 读写性能 但是不提供容错 一旦发生错误直接全部崩盘 不可靠 
奇偶检验 ：RAID5  RAID6 :使用奇偶校验的数据来提供容错能力，同时提高可靠性 达到 一旦出错可以恢复的目的 

增加缓存机制：  提升性能读写速度 跟出错没关系  
这道题的核心是什么是 RAID 的可靠性：理解如下：可靠性指的是当磁盘出现某些块儿的错误的时候 是否会影响整个磁盘 还是说 不对大部队造成影响  
由此可知   条带化 跟 增加cache机制是负责 提升磁盘读写数据的速度的 ，与其 出错后如何合理恢复 无关  

![[Pasted image 20240728212809.png]]
存取时间 =寻道时间+延迟时间+传输时间 
并且 其 存一个扇区的平均延迟时间为  半周的时间也就是半转  
也就是说  其内容如下 ：在 60s中转了7200转 求每一转多少秒   60/7200 /2 除以2 是因为 平均的扇区延迟的平均时间为  其转半周的时间也就是相当于 半周时间 4.17ms + 在每个扇区停留的时间为  60s/7200/1000=0.1ms          然后呢将其相加 得到是12.2ms

题目中访问 一个扇区的平均存取时间指的是 磁头寻找到这个磁盘的地址 后 在 横向沿着磁道延迟去走 ，最后 在磁盘中的有效扇区中延迟划过的时间  之和 
其中隐藏条件为 延迟时间平均为半周的时间   
有几个隐藏条件 







核心点：

![[Pasted image 20240729153645.png]]
各层次之间的存储系统不是孤立工作的 军事围绕主存储器进行的 工作  并且一个整体又得遵循系统运行的原理 ，符合包含性原则，而且 cache中存放的是主存的副本 而不是  另外一篇空间  

2主存跟cpu之间传递用的是字 而 cpu跟cache之间传递用的是块
3
写策略的实行是 为了保证 其主存跟 cache之间保持数据的一致性  保证他俩之间不产生延迟  ，
写直达：也就是 全写法  这个指的是 当缓存每次被更新后相应的更新，这个直达指的是直接写 
写回政策：
缓存更新后  不会直接往主存写 而是 当需要有替换的时候才会写入
4非写分配  直接直达 非写分配  就是  直接直达 直搞黄龙 
写分配 就是问问cahche 要不要一起去做  商量这来 

5 时间局部性=反复利用 
空间局部性="拔出萝卜带出泥"

6 cache 用硬件进行操作的话 ，直接可以快速的 硬件的话 ，可以快速的 进行  
7 cache地址进行映射操作 ，映射的话 进行映射方式 ，而不是直接 去访问 储存 
8  页面失效率=页面未命中率=里面页面中没有新的我去往里添加新的东西 


![[Pasted image 20240729162652.png]]
一共两级cache 在 两级cache中 
其中 在执行过程中访存 1000次  在第一级的时候40次不命中 流入第二级 在第二级中这40次里面又有 10个未命中 
也就是  命中率是 第一级命中的 960+第二级命中的 40-10=30 
`=990`  /1000 = 99% 这么多命中率 

![[Pasted image 20240729164713.png]]
其 一共组相连  也就是128kb/16b/8 没路里面有2的10次方这么多个 块儿 
现在  
TAG  + 块儿地址+ 数据地址 偏移量 
  ？+     4 （16B）+10(1024)
  总字节一共7位 也就是 7x4=28位的地址 
  28-10-4= 14 
  重点来了 ！！！！！！！！！！！！！！
  将1234567H 划为 2进制后是
  0001 0010 0011 0100 0101 0110 0111
  高位的 14位有  
  0001 0010 0011 01 
  但是在地址中从低位开始划  就是说 
  00 0100 1000  1101  这么划   
  具体 请参考 地址系统  
![[Pasted image 20240729220721.png]]
首先 线索一  按字节编址  = 8bit一个字节 32位 推出 32/8=4 最大表示的4个  也就是需要两个二进制位就可以 

全相联映射  就是一对一 取余  

然后  一共32位 32位中 明面上的是 2位的块儿地址  也就是明面剩下 30位  
但是 隐藏信息是 回写方式：暗示了回写 需要有一位作为修改位 (脏位)：目的是啥呢“： 需要告诉cpu我这个被修改过了   
因为回写法的核心是：往cpu报告 是否被修改过  设置一个缓冲区  cache   当被修改过了 就 显示1   数据流向从  cpu到cache  -再到主存

如果没修改过 ，也就是0  那么 不需要走cache 直接流向主存 
修改为存在是 告诉他 不用先走遍cache 在走主存了 直接奔主存走就行


隐藏信息2 ：随机替换策略 ：不用控制位  不像 lru之类的东西

故记得加上一位符号位 
也就是说 
主存一个框  里面放着 主存总地址位= 块儿内的地址2+标志位

cache 中 =数据位 本身+主存中的标志位 +剩下的因为 算法调度 等产生的位数 +符号位

在这道题中 
32位=2+30（标志位） 主存的 

cache中的话 cache = 标志位+数据位+符号位+回写产生的脏位 +替换策略随机替换的0位 

30+32+1+1+0=64位  64x32k= 2048Kbit


![[Pasted image 20240729224605.png]]
解析：坑 按字节编址 给的字节 
32个字节 形成块儿内地址 =2的5次方能表示32位字节 所以，用5个坑
由 提问  xxx存储单元所在主存块儿 的cahche的组号 关键点在于如何处理 这个地址 在主存块儿中怎么表达  

在主存中   地址=       从低到高               。。  组号  块儿内地址
所以 先找 块儿内地址  = 
就是5位就表示块儿内地址 

cache行的行内地址为  64行/4路 其中一路表示 16行 
也就是说 转换为2进制是 2的四次方  4位 就可以表示 
然后把 给的 2593 转换成2进制后 最低5个表示的是 块儿内地址 
然后 在往前数四个 是 提示在第几组 


总结 最后落脚点 一类题目是地址 另一类题目是数据  
![[Pasted image 20240729231345.png]]
存储器模块的交叉存储方式：
交叉存储：将存储器地址分散到多个存储器模块  串行转并行  
采用轮询手法进行 ：把一个存储器地址分散到多个存储器模块的方法 转为并行 采用叠加态 
楼梯调度法   阶梯制 （线代里面的行阶梯制度）
不浪费利用  这样 做相当于是 同一时间点内  也就是在楼梯调度算法中 任意截取一个时间 去x抽  在同一个t时刻内  其 相当于是并行 运行 但是实际上操作系统调度的话是 串行 运行
在操作系统内部是 1 --2 --3 --4 --5  但是人看是 并行 
楼梯调度发 
2 存储器芯片跟总线支持突发传送 ：
什么是突发传送 ，当 发送一次读;/写命令后  连续传输一系列数据无需发送新的命令 ，
发送完一次命令后 接着传送多个数据库  提升了效率  将准备时间一起处理  后续浪费时间放到一起处理
