![[Pasted image 20240804142143.png]]
二次回忆这些数据 信息 
控制单元 CU 会根据指令的不同完成一系列的微操作的内容  信息 

### 第一节：cpu的功能跟基本结构  
cpu的功能 ：
1 指令控制： 取指令 分析指令跟执行指令操作 ，程序进行顺序控制  
2 操作控制  往往是若干个操作信号的组合  并产生内存取出每条指令的信号把各种操作的话  按照这些指令的要求进行操作   进行若干操作信号的调配操作 
3 时间控制 ：各种操作时间控制  加以信号的调配就是时间的顺序 以及各大指令执行的先后时间顺序
4 数据加工 ：数据进行算术跟逻辑运算，主要跟ALU 这个运算器
5中断处理：计算机出现的异常情况跟 特殊的中断处理  的 机器底层逻辑的过程 
就是如何对作业进行调度过程的过程  调度的异常情况的过程 （如何处理中断处理）

### 针对运算器的基本结构的部件 进行详细拆解  ：

运算器  ：对数据进行加工  ：例如加减乘除 疑惑 与或非 疑惑 等 循环移位等操作  包括进行加减乘除 这种功能性的内容 
运算器的一些细节问题 （结合第二章去看）
在运算器内部 有 如下几种部件  
1 算数逻辑单元 (ALU ):负责指挥 进行算术 的功能 这个地方可以执行：
（1）：算术运算：加减乘除 
（2）：逻辑运算：与或非 异或取反
（3）：移位运算：算数右移 与左移   逻辑右移左移  循环移位 
（4）：比较操作：等于大小比较，比较操作数大小产生对应的条件标志  条件跳转指令 
（5）：条件判断指令  ：基于ALU 操作 设置状态寄存器中的标志 用于指令的执行 
状态寄存器 都有啥呢：SF ZF OF CF标志位
其中有如下条件标志 ：
（1） ZF：零标志 如果结果为0 比如 两个数字作比较相等了，标志设置为0  发生了是1没发生是0 
（2）CF：进位标志：进行无符号数的比较的时候 进行 进位借位的标志判断 一般发生在无符号当中 或者两个数字符号相同的时候
（3）OF溢出标志  ：进行了溢出操作后 ，运算结果超出了表示的范围 PS：这个溢出操作的存在必须跟机器 本身的表达范围限制 区分开 ，区分 是因为计算完没地方放 导致的 还是说计算本身产生的溢出
（4）SF：EFLAGS 或者是 RFLAGS寄存器  反应最近一次算数或者逻辑运算结果的符号 
符号是正就是0  负就是1 

2通用寄存器组（GPRS）：cpu==暂时临时存放数据的跟指令的一个平台==
功能：(1)数据存储：存储临时的数据跟操作数 可以在算术运算跟逻辑运算那种访问
       (2）运算操作数：操作数通常在通用寄存器里操作 结果也放在这里面
       (3)内存地址存放地点：存储内存地址，用于指针等操作
    （4）指令操作：忒都给你寄存器的操作数
x86中典型的通用寄存器有如下几种：
（1）EAX/RAX 累加器：
算术运算 累加器  
（2）EBX/RBX基址寄存器：存储基础的地址 
（3）ECX /RCX：计数器寄存器，循环计数器或者字符串用
（4）EDX/RDX:数据寄存器 用于I/O操作行为 乘法跟除法运算 
（5）ESI/RSI:字符串数组中的源指针系统 
（6）EDI/RDI:目标索引寄存器 ：字符串或者数组的目标指针存放地址
（7）EBP/RBP：栈帧的基指针的地方 “井底”位置 从上到下是从高地址到低地址 他存放位置在井底这个位置上 
（8）ESP/RSP：栈指针寄存器：指向当前栈顶位置 就是个井盖的位置 堆栈指针  

针对寄存器跟 ALU之间连接方式的阐述 ：
1 多路选择器 MUX ：也就是 通过多路选择器 起到一种选择寄存器的作用  
可以选择不同种类的寄存器  之间的差别通过这个控制信号进行选择  
2 用三态门进行：控制每一路是否输出   R0out 
R0out 的含义是 当 寄存器R0当中的信号被激活后 也就是高电平或者逻辑是1 的话 R0的内容是被输出到 指定的目的地中的  
高电平激活 低电平关闭 
上述采用的是专用通路方式 也就是转门的路线给了这个 模型 


![[Pasted image 20240804174018.png]]
他主要控制总线是这样的   
引入暂存寄存器的目的是：暂存寄存器为了保证 其R0 R1 R2等内容在那条箭头上的路不冲突，就是说 为了信号不冲突 将串联改成了并联去做 
需要用 暂存寄存器  R0 来保证 达到alu的信号是稳定的 主要针对A 跟B 而言 
![[Pasted image 20240804174220.png]]
这里alu后面设置暂存寄存器的目的是保证 了alu 计算出的信息不会回到cpu内部数据地址总线上跟 其内容冲突  
3 累加寄存器 ACC 临时存放 ALU的结果 并且 实现加法运算 
4 psw 是程序状态寄存器  专门处理 OF CF ZF  等标志位 的  
这些参与 促使了整个微操作的形成 
5移位器：移位运算 
6计数器：进行乘除运算的操作部署 

左边运算器 右边控制器 ：
![[Pasted image 20240804174603.png]]
关于每一部分的详细整理 分析：
一 、关于程序计数器 PC：
指令指针  ：功能 ：
(1). 指示当前的执行的位置：指出下一条指令在主存中存放的地址 ，cpu是根据pc 主存中取指令  
当从cpu取走指令后 pc 的值会+1 并且 指向下一条指令     pc有自增 功能 
通常情况下是顺序执行  
以下是可能不进行顺序执行的场景 ：
 first 跳转指令  无条件跳转 直接修改pc的值 一步到位 jmp 
              条件跳转 ：根据某个条件进行跳转 例如 零标志 副标志等 jz jnz等 
2 函数调用 ： 例如call 功能将pc修改为 被调用的函数的起始地址  ，记住 在调用 真正调用之前 会先保存“快照”也就是把之前的pc 保存到堆栈 方便函数返回的时候使用 
函数返回 ：汇编语言中的RET 指令可以将 PC回复 为调用前保存快照的地址 
3中断处理：ISR  也就是中断服务程序 发生的时候  PC 自动修改为ISR起始地址  处理 引起中断的称序 其本质上也是一种 另类版本的函数调用 当处理完的时候 如同 调用函数所用的RET函数那样 返回之前保存快照的地址
4分支指令：类似跳转指令  BEQ 根据条件判断 修改pc  
5 异常处理: 异常通常是由cpu在处理指令检测到错误 或者某些特定瞧见引起的 比如 软件引起的 
算数异常  等非法指令，内存中的服务 系统调用等    软件显式触发 
中断：有外部设备内部计时器引发的时间 ，硬件引起的中断    主要是定时器跟时钟周期引起的异常功能触发  
其中异常的处理优先级比终端搞  
二 、指令寄存器 ：IR：
存储当前正在执行指令  这一般 是存pc那边来的指令 放到IR中   进行解码 并且执行，阶码后被送到相应的执行单元执行 具体的操作     如算术逻辑单元ALU 或者是 浮点运算单元 FPU 进行具体的操作行为 
三 指令译码器：ID  把存储在指令寄存器的 指令进行翻译 姨妈 然后 解释 具体的指令周期工鞥呢 
主要作用：
1 解析 OP 也就是 由 op+Ad组成的操作码跟 操作数 组成的指令地址工鞥   他负责解析OP前半部分 确定指令的生成 以及不同种类的类型 
2 确定操数 ：确定操作数的种类 数量  可以是寄存器 内存地址 跟立即数  ，解析操作数字段 并且 传递给执行单元 
3 生成控制信号传给 ALU  等  以调度 调配他们之间的行为  
四 微操作信号发生器 :
生成控制处理器内部执行单元的微操作信号，根据指令译码器输出
他结合三个地方 时序系统  PSW 标志位 以及 指令译码器ID 的信息位  最终生成微操作信号发生器 
这三者在 其内部分别的作用是 ： 指令译码器 拆解 解密后的操作码跟操作数  
                           接受 时序信号 的控制信号 确定微处理器什么时间干啥事 该干啥事
                           并且参考psw的状态  信息位 生成一些我操作信号    比如  alu操作信号 寄存器读写信号 数据总线控制信号等等  
四 时序系统：控制指令执行过程中谁先执行谁后执行 如果不那么操作的话 导致 是海南升序 
1 生成时钟信号 ：时钟信号 是由时钟发生器生成  是一个稳定的方波信号，并且有固定的频率 ，就跟咱们现实世界的秒针一样   处理各个操作的同步跟时序  
2控制指令的周期：包括取指 解码  执行 写回等   阶段  控制 这些该啥时候执行 不该啥时候执行  
3协调控制流跟数据流：复杂的指令执行 必须协调性 他们的 处理器内部 什么时候走数据什么时候走地址  核心存储方式 就是数据+地址 这两种方式 
控制流包括：条件判断+分支跳转 等等   
4流水线控制：大概解释为 各种指令 串行改并行 利用阶梯式将他们修改为并行的形式进行运行处理  避免流水线 中这么设计的冲突 等等  
5中断跟异常事件 ： 发生中断跟异常的时候找他 处理进行 

微操作信号发生器 的结构被描述为组合逻辑跟存储逻辑 
组合逻辑：
特性 ：生成 控制信号是即时性  随时随地产生并且生成的 并根据当期那的输入 直接生成  不依赖于历史干了啥 只管当前输入了啥 
没有记忆功能简称没脑子 
所以叫做组合逻辑 也就是只管 组合 不管存放信息的位数等 

存储逻辑部分：
特性：
1 状态记忆 既快照存储功能 ，能够存放历史状态的信息，存储当前指令执行的装态是啥  根据历史的 装态也就是保存的快照进行存储 
时序控制： 通常通过时钟信号来控制状态更新跟微操作的执行  等 问题 
确保这部分按照时间顺序进行不能弄混了前后顺序 
六 存储地址寄存器 ：存放地址单元的寄存器 用来存放地址单元并且提供地址信息的寄存器 
七 存储数据的寄存器 



后缀名是 加了E 是输入正确 则 走这条路     ，不加e是 输出失败 走这条路   
![[Pasted image 20240804150144.png]]![[Pasted image 20240804150243.png]]
控制器 跟寄存器 
棕色的是对用户课件寄存器  
灰色的是对用户不可见的寄存器   这是  他们大概的结构图 
![[Pasted image 20240804152420.png]]
CLK指的是 指令周期 =定长的指令周期或者不定长的 指令周期 
执行一条指令的时候所用的时间周期  分为定长或不定长 
大小依赖关系如下：
指令周期 （定长或不定长）= 机器周期（CPU周期）若干 =时钟周期（节拍 t周期 cpu操作的最基本单位 ，衡量cpu的最基本的单位是机器周期 
不定长的 也是这个下面的值
其中 机器周期跟时钟周期 可以不相等 其区分度在于 长短  除去一些必要的环节 也就是 固定的步骤以外   可添加不同附件   比如 任意的执行抽泣等  
其中 特殊的 有nop  他无执行周期 也就是 取指周期等于指令周期  

指令周期不同的环节的详细描述 

第一步 取值周期 （必须存在的 也就是 无法删减的环节）
从内存中获取指令 的过程  第一个环节
1 人话 就是 描述性语言 ：
你要取地址 必须先找 到存储地址的地方  PC 存储下一条指令的地方 于是 先去那里找 
（1）程序计数器pc读取  从pc读取 到当前获取指令的地址   
（PC） ---->MAR   这是程序地址寄存器  在存储器内  存储 存储空间值的地方  
（2）地址总线传输 
CU  控制中心 告诉 cpu 我们这条指令 不是写 是读  读 意味着2进制信号是1 代表读 
同理 写是用0 表示 写 
所以  写作：1--->R   意为  控制总线CU 发出信号 读信号 传输数据为1 这个值   1 表示的是启动这个控制中心   R表示的是 采用的是读操作  进行 的 
1 读信号 发送给 R 寄存器 传输给主存 告诉主存我要取信息 我要取指令信息 需要申请与你互动 
（3）MAR 存放的是地址信息  存放的是什么地址信息
我要取的 指令 在主存中的哪里  ，我申请与 MDR 互动 MDR存放的是真正的指令数据
`M（MAR）-->MDR`  我要取的指令 的地址信息 从内存中mar得到的地址 给到mdr 在mdr的大型存储指令集的仓库中搜寻我想要的指令的信息
M 指明的是memory 也就是内存的意思 ，就是表达的是内存的值告诉 我是内存的信息

MAR 指的主存内容 的地址信息 经过数据总线 流入到MDR中  
也就是说mdr存放的值不是最终指令的具体值 而是他在ir里面存放的位置信息 暴露出出来具体在什么位置上
（4）MDR中的内容  指令 送入IR  指令寄存器   存储的指令的值 寻找专用指令贮存的地方
（MDR）--->IR  取指令寄存器中去取到 相对应的指令信息 
（5）CU发出控制信号 ，告诉他  结束了  本条指令取指令环节结束 PC的值+“1” 去找下一条你该做的东西去吧 ！！！！


![[Pasted image 20240805195208.png]]
这是他的整套流程图   ，以及 clk始终i新年好 通过不同的101010 控制来解释 这写周期的过程  


第二步 ： 附件（可以选择不执行 也可以选择执行  如果有间接地址的话 就执行 这个周期 可有可无 ）
有中间商赚差价 ：  中间要过二手商 
（1）将指令的地址码送入MAR 也就是 说 Ad(IR)--->MAR  他还可以从 Ad（mdr）--->MAR中  
mar存放的是真实的指令地址  ，然后 mdr 存放的是  mar中 存放数据的地址的地址 
（2） cu发出信号 说  这是主存的读操作 1--->R
（3）将MAR所指的主存内容 经过==数据总线==送入MDR中   M（MAR）--->MDR  
然后 （MDR）-->AD(IR)送到指令寄存器的地址码字段 

第三步  执行周期（必备） ：根据alu 不同指令的需求来做 

第四步：中断周期（可以选择性 可选择性 ）
其 主要目的 是 存档 去做其他事情 然后再回档到目的位置 
核心  利用栈  高位是栈顶 低位是栈底 来保障 此时 保存的指针的位置 
先开井盖 在放数据  push 进栈 就是 先栈指针升级 在 放入数据信息 
栈  从高位到低位 分别对应的是高地址到低地址 
具体 流程如下 ：
（1）CU 控制栈顶指针 先将 栈顶的指针-1 然后 盖子打开了 后 将 修改后的地址 送入MAR 中  
进行存档  将 这个地址点拍摄快照 存档存入某个存储单元中 去 然后 
（SP）-1--->sp   (sp)--->数据保存到mar中
可以总结基座 如果地址是a 的话 就是a--->MAR
(2) CU控制中心发出信号，然后 启动主存做写这个操作 ，写的话  1（启动控制cu中心信号）--->W
这信号的任务是写 write
（3）将断点 （PC 内容 ）送入MDR中 （PC）--->MDR 中 
（4）产生中断的入口地址 向量地址送入pc  然后 结束  
细节在 后续 的 章节解锁 

 
方案是单指令或者多指令周期 

## CPU的数据通路的学习：
主体分为两种   内部单总线 跟内部多总线 

### 关于 内部单总线：
内部总线 ：指的是某个部件内部的总线系统 如：CPU 部件的内部的 电路信号的细节 
各种细小部件之间的总线 
系统总线:  同一台计算机系统的各大部件之间的 CPU 内存 等等各类I/o 相互连接的总线 

数据传递分为以下几类
第一类： 寄存器之间数据传送 ：
如 把 PC的内容送入MAR中   实践的操作流程表如下：
`(Pc）-> Bus`中   PCout 有效 PC 内容送到总线中 :
PC中存放着即将执行下一条指令的地址  BUS是数据总线的代名词 由于采用的是 CPU内部单总线的形式进行数据传输  会导致如下 问题 ，在同一时刻 那条路上有且只有一个 信号进行传输，不可能二者同频段进行信息传输 ，会有个部件来调配支配他们的先后顺序的问题 
PC中存放着下一条即将执行指令的地址   
`Bus-->MAR`这句话表示着我将数据总线的流向 的信息 ，传输到MAR中 
其中MAR中存放的信息是 ：将要访问的内存地址 
且基本上想要访问主存的话都必须经过MAR 的流向 

小结 ：这段揭示了 从某个不知名的寄存器流入 主存中的数据流向的过程  其大概得 路线如下所示 “

![[Pasted image 20240807160911.png]]
#### 类型二 ：主存到 cpu之间的数据传送 ：
问 ：CPU 从主存中读取指令的话 实现传送操作的数据流向是啥 ：
答:`(PC)->bus->MAR  pcOUT Marin 有效     `    第一步  pc中存储的指向下一条指令的数据 通过单数据总线bus 通过bus 单数据通路的话 流入 到主存前的 地址 控制部件  MAR  MAR当中揭示了我下一条即将执行的指令PC的 指 所指向的数据是多少  
第二步`1-->R` 注意标名什么地方的 指令有效  这是根据图中所给信息判断   
解析： CU 控制大脑 发出READ 信号 告诉主存我发出的是读指令 此跟mem申请互动的指令是读指令  
当cu发出来读指令后   
第三部：`MEM(MAR)->MDR` mem的含义是 告诉我们这是主存的部分  （mar）揭示了 我们从mar中存放的数据 （这个数据是揭示我们要取的指令是在主存中的存放位置的）在主存中经过一系列的映射 加工 等 流出 留到 MDR中 
MDR是 存放的数据信息 存放的是从主存当中出来的 数据 
第四步 `MDR->bus->IR` mdr中的信息 也就是转换为数据  我们的目的是 去通过主存读取指令
然而 指令一般的存储地址在指令寄存器IR中  所以我们从主存中所获取指令的目的其实获取的是防问IR的指令寄存器的具体地址  也就是指令在IR中具体存放到哪个位置中 
指令从 MDR通过总通路流向了 IR  获取最终的有效地址  
	注：其实pc从取完到指令经过 MAR这一系列的 加工过程中后  就可以 自己增加“1” 此处的1是单位一 也就指向下一个指令块儿 实际过程中这里可能是 包含2个  暗藏悬鸡
#### 类型三 ：执行算数或者逻辑运算 
![[Pasted image 20240807163903.png]]
比如某条加法指令 ADD a，b   微操作信号为 ：
第一步：看到ADD 想到 如果想使用这个指令 必须申请 ALU（算数加法器）  而ALU 是如果想执行加法 必须等到其输入的两个信号中平等 既当他们都共同的输入到 同一时刻去输入到ALU中的时候才可以奏效 
`Ad(IR)-->Bus--->MAR`：从 IR指令寄存器中的取出指令 申请与内存互动 目的取出寄存器的内部的指令
第二步 ：
`1--->R   CU发出的是读命令，通过控制总线发出读命令 read `ps 规律是 当以各种理由申请跟主存内的信息互动那个的时候  信息先流向这里 再次进行 CU控制信号的发出跟读取  
前面是1 的意义是 CU 发出 mem的读写信号的时候默认采用的是高电平触发 所以是1 
第三步：
`MEM(MAR)->数据线->MDR`  这里是mar中存放的 地址信息经过 主存中内部的各种映射 已经找到了 相关的数据信息  输送给临时存储的 MDR中 
第四步：
`MDR-->Bus->Y` 此时 从MDR中的数据信息 通过BUS 这个cpu内部总线 流入到 Y中 图上可以观察到 Y是alu的一个通路   进行准备加法操作   此时不能进行ALU操作需要等到 另外一条线 准备好了以后才可以进行 

第五步：默认他存放的信息位置是在 ACC也就是累加寄存器中   ALU计算完的一般也存放回ACC中去 

`(ACC)+(Y)-->Z`在ALU中 寄存器Y中存放的信息 + ACC中之前存放的已经累加到某个的值  再次相加 后  输送到Z中    
第六步 ：此时 Z中 是经过ALU 加工好的信息 将再次 流入ACC中 
`Z->ACC`此时 Z中的数据流入的总向是ACC也就是累加寄存器中去 




### 5,4 控制器的内部的细节操作 
FE=1 ：取指周期
IND=1 ：间址周期
EX=1：执行周期
INT=1 中断周期 

微命令= 微操作对应的控制信号 
这些命令是 按照周期发布 的 在 某个周期  固定的 一段CLK表达时间内 存在 一个或者两个的微操作 系统 可以存在于 一个或者两个微操作 
同一个微操作 可以在不同的指令 不同阶段 都会使用  
不同的 指令不同的机器周期 不同的节拍    可能不同 
如果简化设计的话  我们可能出现的最大的 节拍数  涉及到访存所需哟啊最大的节拍数执行即可 
当少的话 就尽量放到 末尾执行 
t0  t1  等是 证明了 是 第几号节拍       
ID指的是 指令译码器=操作码译码器    
(pc)+1=PC 即可 

特点 硬部件一般采用的是RISC 精简指令集系统 去做  一般新插入的指令的话 就会导致 指令实现过于复杂  所以 最好用的是原有的 部件指令操作 

![[Pasted image 20240812140816.png]]

注意四个 周期缩写代表的含义   
其中 他是高级语言代码的解释器是 指令  然后指令的解释器是 每一个取值周期 
在每一个取值周期内可以分为 T0-t2三个阶段  （人为定义）：  其中 每一个阶段可以进行 微操作  
1 如右侧图所示 ，我们把 T0 等称作一个节拍，在一个节拍内可以完成多个微操作 理所当然想到 如果要完成这个微操作的话 ，如果两个未操作占用同一个节拍，他们不可能占用的是同一个部件 ，也就是 说 称他们为相容的
2 并且 微操作存储为一个库，这个库本身是存放来了各种可能的微操作 ，并且 同一个微操作可以在不同的阶段被同时使用  他存放位置是CU控制单元的微存储器的内部 
3不同指令 的节拍数 可能不同 但是我们探究的时候一般采用的是订场的指令周期 =定长的机器周期   
如果 出现不同的机器周期的话     各个阶段所在机器周期不同的话 一般向上兼容  也就是取一个最大值 剩下的部分用寄存器替代 
4 尽量采用 末位优先占据方法 也就是 第一个进入的微操作优先安排在排队的最深处，其他人一次往后  ，这样确保 如果有临时的进来的时候能快速排在门口 

### 硬布线控制器
取值周期的任务是 ：将pc中存放的下一条即将执行指令的地址 经过mar--mdr主存当中寻找对应的那条指令 并且输送到寄存其IR中 以供使用 
1 （PC)-->MAR  
2M(MDR)
3 （MDR）-->IR\
4（PC）+1-->PC

其中 一个CU站在硬件的角度层面去看的话  他的组成是这样的 这是他的信号流通方式 

在CU中
CLK调控的时钟信号的节拍发生器 （一个时钟周期发出一个节拍信号发生器）+IR传输下来的n位的OP 经过操作码译码器 +FE.IND ,EX,INT这四个不同的触发器的信号 +标志位来解释某些机器状态 =对应的控制信号以及微命令 

其中将每一部分拆开来看 
一  对于IR的操作码译码器 ：
指令读取 ：当内存中指令被读取到IR的时候，CU 的目的是啥 CU 的目的是根据指令的操作码部分 也就是IR前面所属的OP部分的信息来 进行操作译码 ，将OP部分翻译成对应的信号并且输入到cu内，告知CU要采用何种操作形式进行
二：节拍发生器：
通过不同的节拍发生器来传输不同的节拍到 机器CU的内部 ，以用来调控时钟周期的发生以及频率的问题 
来控制 每一个时钟周期的特点发生方式等 

三 FE IND EX INT 取值周期 间指周期，执行周期 ，中断周期 
这四个周期来 发出信号告知 此时处于什么周期内 
四标志  来自不同时候的标志来例如PSW  ACC的符号位，等 I/0设备的信息来告知CU 此时状态如何 ，方便CU部件进行合理的判断
五控制信号对应的微命令，既对应一个微操作


在不同阶段每个微操作做的事情 

阶段一 取值周期（每个指令都要经历的事情） 
PC->MAR
1->R
M（MAR）-->MDR
MDR->IR
op(IR)-->ID(这里id指的是上文中提到的指令译码器)
（PC）+1-->PC(这里PC+1的行为 其实在PC 往MAR输送了信息后就可以截止了)

阶段二 间指周期（如果发生所有指令都一样）
思路 ：如果发生间指周期说明这个指令第一步从pc中往IR存的地址 信息不是最终的指令信息，而是下一个真正地址的门牌号 ，我们发生间指周期的目的是找到真正的门牌号 
所以从IR出发再次与MAR互动 申请取真指令信息到IR中
Ad(IR)--->MAR
1->R
M(MAR)->MDR
MDR->Ad(IR)
阶段三 执行周期（不同指令执行周期可能的调用的方式不同 ）

阶段四 中断周期（Interrput Cycle）
就是当遇到一些问题的时候需要保存当前状态信息 ，进而去处理其他事情后再次回到之前保存的状态中进行主线任务
涉及到的微操作序列
1 终端请求检测  
CU-->IRQ (监控中断请求信号)，并且观察中断请求是否发生
2 中断响应
保存当前状态（给当前所处的状态存个档） ：
PC 的值保存到 ---》STACK 栈中  最上方是 栈底 最下方是栈顶 所谓逆生长
目的是为了在处理完中断的相关事情的时候赶紧就从栈中能很顺利的提取出来相关pC的值 以方便定位到具体内容上 
Register-->STACK : 将当前寄存器的内容保存到栈中，这样可以使用寄存器不会丢失数据 
保存之前主线任务的地址+数据  地址用的是栈保存而数据用的是寄存器保存的

3中断向量查找  
	什么是中断向量 ？
	中断处理机制的一环，如同c语言中的指针一样，他指向但是一个特定的内存地址 ，并且这个地址处存储了中断处理的入口点（中断服务例程，ISR）的地址信息
	主要作用是指引处理器发生中断的时候，如何快速找到并且跳转到中断处理程序
	1中断向量表：存放所有中断向量的表格 跟并查集这种类似 ，属于是终端类型指针的 存储位置
	 2 中断向量的生成：中断发生的时候会根据中断源生成 中断的请求号，或者中断的想良好，这个号用于索引中断向量表 
	 
获取中断向量  
IVT-->MAR中：将中断请求中的中断向量地址加载到MAR中 去   目的是准备依靠这个地址访问主存 去定位到真实中断所发生的位置在哪里
M(MAR)-->MDR从内存中读取终端真是地址  并且将其加载到MDR中区 
MDR-->PC 将中断的地址传输到PC 中 然后方便处理器跳转到中断处理的入口地址 信息

4执行中断处理程序  上述获取到地址后 此时PC中存放的是进行中断处理程序的地址 
跳转中断处理程序 ：
   PC-->IR中来 将中断处理程序入口地址加载到指令寄存器IR中并且执行中断处理程序
进行执行环节  指令周期的五大环节

5中断处理完成 支线完成后 申请向cpu恢复到主线的操作行为上来 
恢复装态 
细节：由于是先压入的PC 的值 在压入的寄存器的数据信息
所以恢复的时候是 先取出来寄存器的数据信息  
然后再取出PC的信息进行回复 
然后进行主线接着进行 

任务二 ：微操作时序的分配原则 
原则一：先后顺序不得随意更改：先调用哪个 后调用一切都是由前后联系的
原则二 ：为了尽快达到并行的目的，如果对象不同 安排在同一个节拍内完成，一个节拍尽量干更多可以并行的事情
原则三: 占用时间较短的微操作可以安排在一个节拍内完成 注意先后顺序 如果两个操作时间延迟段 且占用的时间少 的话 那可以在一个节拍内 


总结： 但凡是涉及到跟主存 使用了mar 跟mdr 申请跟主存互动的   这部分一般必须在一个节拍内完成 


执行周期内不同的指令 的微操作时序的安排以及 行为解读 
一 ：非访存指令 
1 CLA：
这条指令主要的行为是 将ACC累加器的内容清零  
除去取指部分  的行为  
执行部分为 ：
0----》AC（ACC）这俩是一个事情 

其从取指阶段到执行阶段全流程为 ：
1 PC->MAR
2M（MAR）-->MDR
3MDR-->IR
4op(IR)-->ID
50-->ACC

分配：节拍一：PC-->MAR中 先将PC的值传输到MAR中 
             （PC）+1--->pc pc的值加1 这条只要等PC闲置后都可以用 
        节拍二：M(MAR)-->MDR:从内存MAR中读取内存申请跟内存存放的指令进行互动
           MDR-->IR
           节拍三：op（IR）-->ID 传输到指令译码器ID 身上   从IR中提取的操作码传输到的ID 身上 
           节拍4：CLA 执行 累加器清零 

 2 COM 执行累加器的按位取反 
将最后一步  0--->ACC 变为 ACC-》~ACC
3 SHR 算数右移
大步骤  ：1 取指  2 解码 3 执行 
在操作阶段分为两步 ：
（1）L（AC）->R(AC) 从左边调到寄存器AC 右边中 
（2）AC0-->AC0  进行算术右移的行为 
4.CSL：循环左移 且可以在一个节拍内完成   
R(AC)-->L(AC)  , AC0-->ACn
5  STP:
stop:停机 
表达方式 ：0-->G
二：访存指令 ：其因为涉及了对MAR MDR的访问操作 即为
(1 ) ADD X:加法指令 隐含了对acc的操作  
在执行周期部分 的主要操作如下：
	`Ad(IR)(地址部分)-->MAR`  中   `1->R`CU发出控制信号是读操作 
`M(MAR)--->MDR` 内存中读取数据到MDR中 
`AC+MDR->AC`  将AC中的值 与MDR中从内存中渠道的厄相加 存储在累加器中
总结：AC+MDR-->AC 调用了累加器的行为 ，从内存中获取对应信息 并且将之前AC 的值跟从MDR中取到的值相加而得到的最终结果 

（2）STA X  存数
核心是将累加器AC (ACC)的内容存储到X 中 
第一步：取值周期 略 
第二步 指令解码周期 略 
第三部  执行功能周期 
`Ad(IR)-->mar`:  `1->w`  指令寄存器中的地址部分传输到MAR中别用 并且 控制信号下达一个指令为写的指令信号  
`AC--->MDR`开始倒着存 ，就是 从ac--》mdr--》mar中 回归内存  但是一定要在进行此步骤前加入 1--》w写操作 
`MDR-->M(MAR)`:将内存数据寄存器中的内容，写入到内存地址中 MAR指定寄存器中去 
（3）LDA X 取数 ：
核心是将内存地址中x的内容存储到ACC中
第一步取值周期 略 
第二步 指令解码周期略
第三部执行功能周期 get
`Ad(IR)-->MAR`    先进入MAR进行加工 确认存放在内存中的位置单元是啥  `1-->R`在进行第一步的时候别忘了 发送相关读写信号，这个极为关键  
`M(MAR)-->MDR`从内存中读取数据 读取的是取数的地址真实信息 
`MDR-->AC`:从MDR读取地址信息 最终流向AC  这是完成了从 内存中取数到AC的决定 

（3）转移指令耗费一个节拍   
1  JMP X 
无条件转移 ：Ad(IR)-->PC 直接将IR的值转移给PC  即将下一条执行指令的地址 

2  BAN X
条件转移 ：当ACC也就是累加器的值为负数的时候 PC 的值将更新伟 指定的内存所在的地址X  以便程序从该位置继续执行下去  否则程序接着执行下一条指令 

其节拍表示如下：
1 `A0*Ad(IR)+A0'*(PC)-->PC` 
表达式解释：A0默认是累加器的符号位 表达的是 AC的内容是否是负数
其中 A0=1 表示AC的值是负   A0=0表示AC的值是非负（0跟正数均可）
若A0=1 的话 既累加器的值为负数的话 
PC=Ad 



中断周期的操作时序 
`A-->MAR`  将地址A 加载到 mar中  存储的返回地址 
`1-->W`  进行内存写操作 
`0--EINT`  将启用中断的信号设置为0 来禁用中断内容 防止 在当前中断处理期间的干扰 
`(PC）-->MDR`将PC的值传输给MDR中 将返回地址进行存档 即可 
`MDR->M(MAR)`将mdr的值存储到mar指向的内存额我只  
`向量地址->PC` 将其加载到PC中  且 重定向到中断处理


微程序控制器 设计思路 在软件层面 ，=把硬件层面的节拍T0--T2 等每一个T 记为一个微指令
所有的微指令构成一个微程序 
每一种指令对应 的是一个微程序

指令=描述程序该干嘛的  
微指令=描述微程序该干嘛的
![[Pasted image 20240812172659.png]]

微命令=微操作 
微指令=n个微操作=n个微命令 

在CU中的微型控制器   基本结构 
![[Pasted image 20240812172840.png]]
取指令 跟用指令   分为两个操作     
先取指令 后在进行运行  指令周期 是用若干机器周期 表示  并且叫做CPU周期 的 
机器周期包含多个时钟周期 
取指令 是 很多个 cpu周期 也就是 若干个CPU周期 
定长机器周期 的时候  对于取指令 去有效地址  这性质领 的机器周期 所消耗的机器周期 各相同  的话叫做定长的机器周期  ，
不定长 指的是 其机器周期 取指令 取有效地址等 所有的周期不同 导致的 

时钟周期： 节拍  T周期 CPU时钟周期
针对NOP的空指令而言 取指周期是等于指令周期的 且这两个周期的长度相同 
取出来就行了 不用管执行 所有没有执行周期  只用取指令不用管执行 

![[Pasted image 20240804153231.png]]
流水线机制 串行达到并行  
控制器（CU） ：协调控制计算机各部件执行程序的指令序列  包括取指令 分析指令执行指令等功能 
控制器的 细节 流程等  
控制大脑  暂时控制这部分的 一些具体细节 主要是生成控制信号来操控他们来保证时序 按照一定先后顺序完成   控制器不直接处理数据 ，而是 告诉数据 只负责管理  安排人手 不负责具体干活儿

### 5.4微程序控制器 
引入软件思想  
高级语言代码--->翻译 机器指令序列 ---->未操作 各种周期 
指令对程序执行步骤描述
微指令 指的是某指令执行 的行为的描述   
套娃描述环节 行为操作
二级连环操作 的行为进行 
微指令 a  b 组合成微操作3 等    一个微指令中可能包含有多个 微操作 的行为 
一个指令对应一个微程序 集合
微命令=微操作 他俩是一一对应 
微指令= n个微操作 或者微命令  他把 一个T0 周期 用一个微指令的方式表达出来 仅此而已 
微指令=   操作控制 +顺序控制  如同cpu中的 op 跟 形式地址  一样 
微程序控制器 基本结构 ：
LDA=  指的是 将主存中存放的信息存放到ACC累加器中进行  

![[Pasted image 20240810143839.png]]
这是他的架构，然后 在 机器段 中 有个存储的地方 ，在某些阶段我们采用的某些微程序的地址指令的是一样的 ，能共用的 不借用 
取值 键值 执行  中断   组成一个微程序 中的组成部分   一共有四部分  
这四部分共同构成一个微程序  
一条指令对应的是一个微程序 结构 
设计微指令的过程中 ，让 组合型，  让各种微指令中  在某一时刻并行运行 
对于这种 微程序控制器的结构图如下：
![[Pasted image 20240813195625.png]]
CU内部的微型cpu 也就是微型控制器内部的 形式
OP(存放的位置是IR中)  IR中的微地址形成部件 
第一步：op-->解析操作码生成对应的微地址 （目的是去CM中查找对应的微指令并下发出去）
第二步：微地址形成部件-->顺序逻辑：指向的是控制存储器中存储的微指令序列的起始位置，并且形成部件基于IR中操作码来获取信息 ，顺序逻辑：控制单元一个重点部分，处理生成微程序指令序列，包括微指令读取  根据op解析微地址后 的地址来读取+解析这个字段，然后准备声场相应的微控制信号，并且驱动CPU各大不见操作
第三步：下一个微指令的地址生成，决定执行哪个只i小姑娘微指令  ，基于当前内容进行跳转  
注意有决定下一条执行的地址的这个细节恩问题 ， 顺序地址中的产生的下调低至可以值由跳转指令引起的 也可以是类似pC 那种自增+1的操作 
第四步 从顺序逻辑->CMAR ：
CMAR：控制存储器地址寄存器：存放当前正在访问的控制存储器的微指令地址 ，是个中心点 注意是存放当前正在访问的 地址  
第五步 CMAR -->地址译码（对应MDR ） 
进行翻译 去映射到CM也就是控制存储器当中，并且 进行CM端内部的信息处理去寻找指定的寄存器内容 为了就是确认最终存放在CM端的具体的位置 
第六步 CM-->CMDR
关于CM：CM中 通常由只读存储器ROM 或其他类型的非易失性存储设备实现  ，按照预设存放并且固定存储很多微指令
存储在CMDR中的指令不会被立即执行 ==暂存==

注意CMDR中的架构 不仅包含此次地址的信息 还可能包含下一次地址的即将执行的信息 
### 1 微指令格式  
顺序 执行 挨个执行   但是可以并行    一个指令执行多个微命令  
水平型vs 垂直型  2种不同的微指令类型 进行判断 操作进行学习 
1 对于水平型微指令：
保障 同一时刻允许多个操作并行也就是同时执行的情况 
主要特点：1宽度：比较宽 且同时包含多个字段 每个字段控制cpu中的一个或者多个独立的功能部件 
2 并行性：可以同时发出多个控制信号 并且 让多个cpu在同一时刻 同批并行进行 ，同一时刻干很多个事情 
3字段独立性  
![[Pasted image 20240813203855.png]]
编码方式 ：
1直接（编码）控制方式 ：
一位二进制对应一种控制方式 直接了当的表示 1代表的是这种方式存在 
但是占地方太大，因为每种方式不一定会启动
![[Pasted image 20240813204149.png]]
哪个是1 代表哪个有效
2字段直接编码 ：分段处理 经由每个段译码后发出控制信号 
![[Pasted image 20240813204336.png]]
（2）字段直接编码的形式  具体格式如下 ：
对操作码进行分段控制 并且 进行 分段后  分别进行编码 、译码等行为 
并行的译码段 以及 互斥 放到 同一个段 内 
为了用二进制区分 他们 可以  互斥的放到同一个段内  让他们不用 一起发出 
重点是：互斥的放到同一个段 相容的分在不同段 
1 相容的意味着他们可以在同一时刻并行去处理，互斥意味着 处理了1号就不能处理2号，因为处理1号的时候的东西被占据了 2号跟1号所用的东西发生了冲突
2 留一个信息状态为 表示本段的是可忽略的 





3）字段间接编码方式 
![[Pasted image 20240813204805.png]]
微指令的地址形成方式 
1 直接指出  断定方式 直接直来直去 写着啥 就是 直接定位到对应的目标地址的方式 采用这种方式进行云心  
2 根据机器指令的操作码 形成    由操作码经微地址的形成部件构成  
3 增量计数法   ：(CMAR)+1---CMAR  这个是叫做增量计数法   
4分支转移  指明判读别方式  并且进行转移地址  ：指明转移成功后的去向是哪里
5通过测试网络  ：经过“内网 ”测试  
![[Pasted image 20240813204850.png]]
6通过硬件直接产生微程序的地址 

第五章 可能会出真题  25考研大题研究出来真题 信息  
设计 微程序控制单元的设计类型的问题  ！
主要思维方法：
步骤一： 分析每个阶段的微操作序列
以 取值周期中为例子 ：最终目标 从pC中的地址经过主存磨炼最终到ID 环节
T0:`PC->MAR中`
`1-->R`
t1:`MAR->M(MDR)     (PC)+1->PC`
t2:`M(MDR)--->IR`
`OP(IR)-->ID`
进行合理的周期分配
上述中的 T0 T1 T2 分别构成三个不同的微指令周期  
有以下细节注意:取值周期第一条地址是由硬件自动给出的 
并且从指令A的下地址表示B的地址 
其中关键的环节是：
在 每个T0-->T1阶段 要及时更新 CMAR中的地址  
且 这个CMAR中的地址 是 根据 CMDR  也就是上一个T0 环节的信息 及时进行更新，即为在当中的每一个海内 都需要进行 
`Ad(CMDR)->CMAR`的操作 行为 确保 能及时的让微型的CM 装置像CU控制单元发送 最新的执行的地址消息 ，而不是上一条中的地址消息 
2 在整体取值周期进行完成后  既OP(IR)的操作数流入微地址形成部件后 最后会继续流向CMAR 去更新 指向下一个指令周期的初始地址   首地址 
![[Pasted image 20240813211241.png]]
步骤二： 写出对应机器指令的微操作命令既节拍安排 既哪些操作可以融合到一起 哪些可以并行 哪些不可以并行
步骤三： 确定最终的微指令格式部分、
步骤四： 编写微指令的码点
硬布线等
`LDA`z指令指的是 从ACC中取数字后 计算后 将其内容进行叠加处理 
![[Pasted image 20240810154408.png]]
每个比特位对应的 某个特定的微操作 的行为  注意 
这两个步骤 是每个微指令设计的时候都 必须有 ，就是必须更新地址 为了方便下一条需要执行的指令信息的时候 使用他们即可 

微程序设计分类 ：
1 静态微程序设计   
一旦写入了ROM 无需改变 
2 动态微程序设计 ： 指的是通过改变微指令跟微程序来改变机器质量年个，并且有利于仿真执行并采用的是 EPROM这个功能进行
3毫微程序设计     在微程序设计下面的 微程序解释机器指令集客  

硬布线 跟微程序的比较 

![[Pasted image 20240810155135.png]]
进行设计   步骤的时候 注意补充跟获取 下一条微指令的微操作部分 即可 

不可以偷懒 少看！！！！！！
要挨个 把流程多次梳理   加油！！！！！！！！！！！！！！！！！！！！！！！！！
不能偷懒！！！！


影响 流水 线因素  
1 结构相关 资源冲突  ： 同步 冲突
互斥：一堆指令 在某一个时刻 统一抢夺 某一个资源的问题  ，是这个问题阶段

在译码阶段进行读操作 ，最后一个阶段执行写操作 ：对寄存器进行写这个操作行为逻辑模式 
同一个寄存器不能又读又写  

如何解决资源冲突  ：
让后面 那个指令暂停一个周期使用 
资源重新配置  如何宠你想你配置呢   导致这种 情况的根本原因是 没有办法容纳个取指跟访存需要访问的cahce 的结构不一样  并且进行合理的资源 合理配置 

本质 是操作系统的互斥问题   ： 1 另外一个 资源 等一个周期 
                       2 再开另一个  
2 互斥 问题 数据冲突 
2 数据相关  互斥冲突 


关于指令流水线的一切：

五大类指令中是否都需要五个步骤进行呢  ：
Rs是源操作器 source   Rd是 目的操作器 ：destination 

1 运算类指令  
加法指令 寄存器+寄存器 
加法指令 寄存器+立即数
算数左移指令：SHL 算法左移 Rd 是目的寄存器  
`shl Rd`
五大阶段  
IF： 根据PC 从cache中取指令到锁存器 
ID：取出操作数 到ID段锁存器内
以 LOAD 跟 STORE为标准进行  的行为 
`beq`   `bne`
![[Pasted image 20240811202333.png]]
![[Pasted image 20240811210854.png]]


## 指令流水线
什么是指令流水线 ：
1 一条指令的执行过程可以划分为多个阶段   其各种阶段具体细节可能会不同但是整体内容大同小异 
分为：取值+分析+执行阶段
各个阶段所做事情大致如下：
取值：根据PC访问主存 取出指令放到IR中 
分析：翻译OP 然后按照指定的寻址方式跟地址字段形成有效地址EA     然后从EA中取出操作数给值性阶段
执行：分析OP 然后去解析 并执行功能 

有以下几种方式执行：
1 顺序执行 （串行执行）
排排站 三个阶段一次挨个执行  ----冯诺依曼机器主要采用的是一下以下执行方式 
![[Pasted image 20240814210150.png]]

2一次重叠执行  
![[Pasted image 20240814210805.png]]
第一次的3t+(n-1)2t =最终时间  划三条线  第一次的三个t+后续的2tn-1个

![[Pasted image 20240814210914.png]]
后续会说明经典的五段流水线指令集操作
两种表达方式 ：
![[Pasted image 20240814211004.png]]
跟操作系统中调度程序工作安排差不多

### 流水线性能指标：
1 吞吐率  2 加速比 3效率
吞吐率：单位时间内流水线所完成的==任务数量== 或者==输出结果数量==
总任务数 是N   
总共完成时间是Tk  
TP：流水线吞吐率 ：  在单位时间内做的任务有多少件

其中定义了两个时间 1 装入时间：假设该流水线最多能支持M个并行  
从0 加载到M 也就是最大的并行数量的时间的过程  称为装入时间
2 排空时间 ，从最大流水线 M个并行到 结束为单个以后一个时间 
对于图示 前面装入时间是Kt后面有n-1个t 
![[Pasted image 20240814211654.png]]
看最后一条  除去第一个装入时间外 还剩下n-1个的t时间 
总共是 kt+（n-1）t=(k+n-1)t
总任务量是 N  则有 N/(k+n-1)t
当n无穷大的时候可以见到  总时间为 1/t
2加速比：
加速比----用了流水线机制后的时间节省了多少 这个是一个比率问题
他具体为  万策划给你n跟任务站的时空区域  
注意 t为一个时钟周期 
加速之后所用的时间 比上顺序执行的时间 
3效率 ：
流水线的设备使用率 =  n个任务占用时空区的有效面积/整个全部并行沾满的面积
执行n个任务假设从0时刻开始 全部占满 分之  有效区域 
![[Pasted image 20240814212642.png]]


指令周期中流水线 五大阶段以及他们可能的影响的环节：


![[Pasted image 20240814212921.png]]
一般 的话 如果设计流水线阶段 需要将每个阶段耗时取一样  ，原本的差值可以通过放入缓存器 来保存该阶段结果 （这个缓存器不是必须要经过的 可以根据实际情况说明）
设计流水线取时间最大值   为平均值

三大因素 
第一大 ：结构相关（资源冲突）
![[Pasted image 20240814213452.png]]
由于串行改并行的阶梯流水线的设计问题 导致 当 一号进行到末尾的时候 3号 与此同时也在使用 这个部件，然而这个部件是同一时刻只能处理一个问题 这就会导致在 该时间段的资源争抢的问题的发生 ，两个资源同时抢夺一个部件 


第二大 ：数据相关 （数据冲突）
指的是 流水线中某条指令是依赖前一条或者前几条指令的结果 ，但是 当执行到此处的时候并没有执行出来的过程 ，这个可以导致错误计算或者流水线停顿
寄存器内部存放的不是我们需要的最新的信息 而是很久之前的信息

数据冲突的 类型:
1读后写冲突：（RAW)
指令1 ：写寄存器R1 
	指令2 :读寄存器 R1 
	冲突发生条件 ：如果 指令2在指令1前就读取的R1 那他读取的不是最新R1的值 
	也就是读取的不是指令1 所写的R1的值 就会发生冲突 
指令2 ：写后读冲突 (WAR)：
等等  

如何缓解呢?
缓解方法1：暂停指令 (Stalling)
(1)硬件阻塞（hardware Stall） 是一个由处理器自动机暂停 ，当流水线检测到数据冲突 硬件自动插入 一个或者多个气泡 （停顿周期 ）等待前面玩策划稿年后子啊继续执行 
全体停顿等待相关解开
(2)软件插入 NOP 空操作 避免数据冲突 ，NOP不执行任何操作 但是占用一个时钟周期  
借助这个 软件修改的方式 例如X64dbg等 阿里达到这个目的 
2 数据旁路技术：
直接将硬件设计部分 把前一条指令结果传递到后续的指令 不必等待写入寄存器 ，
直接指令对指令 不用使用寄存器   
直接减少寄存器环节 从根本上遏制冲突 ，但是硬件的复杂电路增加导致 成本加大 
3编译优化 
通过编译器来优化他们 

流水线的控制冲突 ：
指的是在当中存在的分支指令 （if-else语句，循环语句，函数调用等方面）流水线的后续指令无法确定下一步执行的志林改的值 ，导致流水线等待  
比如 X>2的时候跳转    然后流水线执行的时候迟迟等不来x>2这个判定机制 的发生而导致的问题   
主要发生场景 ：1 条件分支 2 循环语句 3 函数调用跟返回指令  

解决方法 ：
1 分支预测 ：先在结算到最终分支结果之前，先进行猜测，猜测下一条指令结果是什么  ，
分文动态分支 预测 跟 静态 分支制预测 
2 延迟槽 : 缓冲区 通过加入一条跟这个指令无关的 指令 然后不浪费这个分支指令周期 


### 流水线的分类 
一  部件功能级、处理机级和处理机间级流水线：
分别解释 ：
部件功能级流水线 ：处理器内部的功能部件  （ALU 乘法器 触发其 等）常与具体的指令执行有关系，并且 将复杂指令细分为多个阶段 使他们并行执行 
仅限于处理器内部某个功能单元 
2处理机流水线 ：
涵盖所有指令的整个指令处理的流程采用的流水线技术 
主要阶段有：取指(IF)  译码(ID) 执行 (EX) 访存(MEM) 写回(WB)
3处理间级流水线：
分布式计算系统 以及多处理器系统 多个部件之间的冰西瓜协调处理
二  单功能流水线 VS多功能流水线
1单功能流水线：执行特定操作指令  执行固定操作 VVVVVIP服务  只干这一个公的任务
2多功能流水线 :多种指令综合操作 
三 动态流水线 和 静态流水线
按同一时间各段的连接方式  
静态 ：同一时刻各段只能按同一种功能的链接工作
动态 ：同一时间内，某些段正在实现某种运算 ，另一端却在进行另一种
合理分配，不让他们限制 
四 线性流水线跟非线性流水线 
各大功能段是否有反馈信号，可分为线性跟非线性流水线爱你
线性 ：从输入到输出 每个功能如同高山流水一样 只允许经过一次，并且不存在反馈的回炉 
非线性 可以多次经过适合线性递归 运算 适合进行递归算法的运算
![[Pasted image 20240814221302.png]]
### 详细解释 五段式流水线的分布 
有以下五个阶段 ：
1  IF取指  2 ID译码取数 3 EX执行 4M访存 5 WB写回寄存器 
常见的五类指令 ：
### 第一类 运算类指令 
#### 阶段一   取指阶段IF 
目标：从指令存储器中取出下一条要执行的指令 
过程：
     PC的值 是指令存储器的地址   
     取值阶段将地址提供给指令存储器 获取到相应指令后 加载到流水线急促你去（IF/ID）中去 等待下一个周期传递下阶段 
     同时 PC的值会更新为下一条指令的地址 在32位中 以8位为一个字节的话 一共是32/8=4字节的地址   
     所以 会更新

阶段二 译码 ID阶段 ：
目标 将上述取出姨妈 并且执行OP部分 操作数部分的值 
第一步 ：从ID/IF获取指令 
第二步 控制单元进行译码 并且定下来指令的类型  
第三步读取操作数寄存器 既源寄存器 读取
第四部 ，生成控制信号 例如1-->R  等 后续使用 
第五步 如果指令设计立即数 会在这里被扩展 





