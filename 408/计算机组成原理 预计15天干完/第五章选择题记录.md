![[Pasted image 20240805162620.png]]
psw 程序状态寄存器 分为两个部分进行信号提供操作跟行为 
1  状态标志位 CF等 
2 是 控制标志   也就是中断标志  陷阱标志位 
重点在于提供信号  只提供信号  只提供信号 信号 信号 重点说四遍  
所以不会被视为控制器的标志 
![[Pasted image 20240805163009.png]]
指的是数据总线线数 其最多能传送多少cpu的线数
![[Pasted image 20240805163500.png]]
选项A ：PC中总存放指令的地址  
       没错  总是存储指令的地址
   B pc的值 是 CPU在取值周期中修改 属于执行指令的过程中 
   这个执行指令分为多个周期   
   执行指令= 取值周期+执行周期 +xx周期 
   不能把周期 当做指令 弄混
   C ：执行转移指令的事后 PC的值总是修改为转移指令的目标地址  
   不是  他有个前提条件 如果跳转成功后 会修改为转移指令 的目标地址 如果挑转不成功则不会进行修改操作 
  D：PC因为要从MAR 这里取地址 为了保证 位数的一致性  所导致的 PC 的位数跟 MAR的位数保持一致性 

![[Pasted image 20240805165050.png]]
字节地址 解释着 存储器容量跟pc 的联系：

存储器的大小决定了 pc是有多少位 来寻址的可能的内存单元数  
出的题真傻比 

![[Pasted image 20240805165622.png]]
地址译码器 只负责管理  在存储器内 
而cpu 是由运算器+控制器组成 其控制器 里有的是 指令译码器 不是地址译码器 

![[Pasted image 20240805170055.png]]
待学完第五章后解决 
![[Pasted image 20240805203815.png]]
DMA :是针对于主存中的数据说的   他是调配存储器存储数据的一个控制中心台
其中 存取周期指的是 ：
![[Pasted image 20240805205226.png]]
取指令的指令周期内 PC 的指的 修改次数 2次  
首先无条件 不用利用pc作为条件跳转指令去进行跳转 
其次  在取指令阶段 末位 pc的值有+"1"的现象 说明 此时pc的值得到更改 

第二次是在执行阶段的话  PC 被修改为要跳转到的地址 为什么 因为pc存放的永远是 下一条即将执行指令的地址 ，不是当前的指令地址 
![[Pasted image 20240805205518.png]]
b选项中 所有指令 的取指操作是相同的这句话 有问题 
在取指操作中 不同指令的 因为字长不同导致 其取指令的操作会发生不同的改变 不同的指令操作对应着不同的字长  
这会影响到 指令的操作者例如 单字跟双字是不一样的 

![[Pasted image 20240805210621.png]]
第一个机器周期 是 从主存当中取出来指令字  ！！！！
第一个机器周期是从主存当中取出来指令字 
指令字=操作码+地址码 相当于是   其当中的一部分  
选项d  这个 表述出现了错误  

有关机器周期的新定义：
机器周期 ：指的是把通过一次总线事务访问一次主存或I/O的时间定为一个机器周期 
其中有一些术语 ：
1 总线事务：在计算机系统中，处理器与内存之间 或者I/O设备之间通过系统总线 进行的一次完整的数据传输过程  这些总线事务包括 = 地址传输+数据传输+控制信号传输 等 步骤  
是一个完整的 信息传输过程 
常见的有 读跟写 

2  机器周期 是处理器完成一个基本操作（一次数据传输或者指令执行 ）的时间单位 是处理器时钟周期的整数倍
作用：机器周期是衡量处理器执行速度跟效率的基本单位  
他的含义是 在总线事务内 这条数据总线上可以干 这么多的是  
所谓的一次总线事务：处理器通过系统总线执行的一次完整 的数据传输的操作 可能是从主存读取数据或者写入数据 可能从I/O读取或者写入数据  这根线上面可以做很多事情 ，  可以做=主存中读取数据或者写入数据 +从I/O设备中读取或者写入数据

3  利用总线事务这个通道进行访问主存或者I/O的行为： 处理总线事务中  访问的是主存或者I/O中某个数据或者地址  ，读取的指令数据  或者访问I/O进行输入输出都可以

关于多周期CPU的相关定义：
多周期CPU 的核心点在于  原来 存在于单周期CPU上面的  只能在一个时钟周期内完成的指令，拆分分解为多个阶段完成  ，并且 进行合理的调度分配 阶段性调度  
在只能走串行的基础上 经过阶梯流水线思想 进行并行调度分配 达到 合理的利用周期的目的 ，提升cpu性能 
注：这里并没有规定说机器周期数跟 周期长度   也就是说他们俩可变  多长都可以 
重点是 流水线作业 并行操作：同一个时刻下的多作业一起进行 但是他们的开始时间不同 ？
因为 只能串行作业 让他们在不同赛道上走 并且 错开一定时间


注意： 存储器并不认识 存放在内的是数据还是地址 唯一区分他们的防是 去利用一个特定的 指令集架构 或者某些程序设计 来区分他 
区分的时候交个控制器管理 来区分他们 

指令字长  存储字长  机器字长之间的联系与羁绊 


计算逻辑地址的部分 ：
![[Pasted image 20240807171016.png]]
答案是 一号 跟四号 
为什么？
发出的时候 每个时刻只有一个器件发出 信息 原因如下：
1 避免冲突 ：如果在同一个时刻 有多个器件尝试发出信息 会导致总线上的信号发生器导致数据错误跟系统不稳定  这种情况称为总线争用  就是 会抢这一通路 
2总线仲裁：  是一种控制多个策略 目的在于控制多个设备对总线的访问请求 ，当多个设备尝试访问总线的时候 通过总线仲裁来进行访问，并设置相关策略 确保任意时刻只有一个设备能够发送数据 

为什么每个时刻有一个或者多个器件接收信息 ？
1 广播机制： 计算机总线架构的时候，当数据被发送到总线的事后  链接到总线所有器件都可以接受 数据   这种机制称为广播机制 且 在ip地址中也会存在的广播地址 跟这个表述方式一样 ，
处理器 同时发送一个信号或数据 ，同时更新多个设备或者内存模块
2 效率跟灵活性：为了提升效率  多设备 能进行同时接受 多节点操作    例如 服务器 多处理器系统 或者内存同步操作中
3 硬件控制跟逻辑简化 ，能够让 多个器件同时接受数据还可以简化   然后进行选择性接受 

![[Pasted image 20240807173704.png]]
容易踩坑套路 ：
单周期处理器并不代表总线结构一定得采用单总线结构数据通路
采用多总线结构数据通路的目的是 保证数据同一时刻在这条通路上能运行尽可能多的数据 也就是常说的串行数据并行化 的思维模式
所以 选项A 是错的 
选项D中 单周期处理器中的所有指令周期为一个时钟周期  而CPI就是这个意思  
因为选项D 是对的 因为每条指令的CPI是一  如果该指令速度比较慢 会造成其 频率较低  导致其频率没那么高
对于选项C ：控制信号是CU 根据指令操作码发出的信号，并且，对于单周期处理器而言每条指令执行各有一个时钟周期 而在这一个时钟周期内的控制信号并不会发生明显的变化 所以 
如果是多周期处理器的话 则指令执行需要多个时钟周期 并且每个时钟周期发出不同的信号
为啥 控制信号在一个时钟周期内不会发生变化呢？
因为确保信号稳定性 并且  保证去诶多功能个一致性 ，避免了 中间的打断跟数据插入流出功能 


组合逻辑元件 (操作元件）：不含存储信号的记忆单元 任何时刻产生的输出仅取决于当前的输入  
也就是说 他是不存储的无存储功能 这么一个原件 ，其 例如 ：加法器 算数逻辑单元 alu 译码器，多路选择器 三态门 

时序逻辑元件 炸u给你抬u眼见 包含储存信号的机器单元 各类存储其跟存储器 ，有记忆功能 ，并且例如 通用寄存器组，程序计数器，状态 等 以为暂存锁存 等 属于状态原件


5.4 核心题目
![[Pasted image 20240813214416.png]]
关于这个题目  选择 C  
考点：执行公用的取值微程序从主存中取出机器指令后，由机器指令操作码字段指出各个微程序的入口地址 ，通过 机器指令的op字段指示 微程序入口点的位置 

![[Pasted image 20240813214615.png]]
选D  解析：之所以慢是因为 微程序控制器增加了从控制器读微指令 的时间所以才慢
我傻不愣登选了B  
![[Pasted image 20240813215154.png]]
A  硬布线转入微程序控制器的根本原因是灵活性好 易于修改 ，然后硬布线的电路过于复杂导致的 
B 控制存储器 用的是ROM 非易失性  用RAM 易失性的电路 已关机全没了 
C 注意 ！！！！！出题老头的阴谋   微指令计数器决定的是微指令的执行顺序   微指令 对应微指令  ！！！！！！

考点：
辨析：在微程序控制器中，控制部件--->执行部件发送的控制信号称作微命令   ，微命令执行的操作=微指令   微指令=若干个微命令的集合    若干个微指令的集合称作微程序 
![[Pasted image 20240814192735.png]]
这句话说法是错误的 二者作用的范围影响程度不同 
原因是微pC起到的作用是：只是在一个微程序内部，存放即将要执行的下一条指令的地址，
PC 的话是在微程序与微程序之间起到存放即将执行下一条指令地址的目的 与作用 
就是PC作用在微程序与微程序之间 
而微pc作用的是一个微程序内部
![[Pasted image 20240814193012.png]]
这里 三者当中  其中状态条件寄存器是属于运算器的部件，也就是说，在状态条件寄存器内部的值是放到运算器中进行的 由算数指导一些内容生成并且运行 
![[Pasted image 20240814193213.png]]
线索点如下：1 一共有32条指令  从题目中得知 各个指令对应到微程序中的话平均一个指令由两个微指令组成 32条一共是32x4=128  注意别忘了公共的取指指令中2 一共是130  
130=2的8次方=256才能放的下这么多个指令集
![[Pasted image 20240814193837.png]]
这里面选D  
且在 x64dbg 逆向的时候四标志寄存器 肯定课件  还有一个是RBP 类似与基址 寄存其的部分 
1 跟2 表示的是硬件设计师所属的寄存器机系统  呢 就啊哈阿姐
![[Pasted image 20240814201329.png]]
微指令格式 如下 ：
采用水平型微指令编码方式=操作控制字段+判别冲刺字段+后继地址字段组成 
其中三种分别的方式为 ：
1 操作控制字段 ：因为采用的是直接编码方式的微指令格式字段 所以其操作字段的控制数=微命令数 ，
后继微指令地址 由微指令的后继地址给出  证明 一共有多大的容量相当于是多大的存储空间  512x40位= 512个数据由二进制位给出 一共是 2的9次方 也就是9位 +6个互斥的可判定的外部条件
判别冲刺字段= 满足至少6个 也就是2的3次方 8位
9+3+28=



### 第五章 流水线技术 ：

![[Pasted image 20240815142253.png]]关于空间并行性 ：
一个处理机内设置多个执行相同任务的部件
时间并行技术:
将一个任务分解为多个任务不同的子阶段例如流水线技术 

![[Pasted image 20240815142524.png]]
什么是度？ 什么是常规标量单流水线处理机制？
度 也就是说一次只进行一格子 
单流水线说明 只有一行并行 
也就是说 是如图所示 ：
nt+(n-1）t
3t+(12-1）t =14t
![[Pasted image 20240815143822.png]]
超标量进行   度是4  且是流水线处理
4个并行一组  20个 20/4=5组  每一组中 
相当于n=5的单流水线  也就是 3+4t=7t

概念辨析题：
1 指令执行过程中的各个子功能都需要包含在某个流水段中  记住是都需要包含
2 所有的子功能都必须按照一定的顺序通过流水段 
3 虽然各个子功能有用的实际时间不同 （比如IF 跟 WD等每一个小的环节用的时间不一致）但是这几个指令加起来所用的总时间是一致的 
4 流水段可以进行空操作 例如NOP指令 防止数据冲突等问题的发生
5指令译码得到的控制信号需要通过流水段寄存器送到下一个流水段中去 
关于流水段的寄存器 有如下概念：
 1 在某个时钟周期内，其不同流水段之间受不同的指令控制信号控制，并且执行不同指令的不同的功能段，指令译码阶段控制器CU 对每一个指令段发出相同的流水信号  每一段发一个 ，分别在各大时钟周期内被使用，并且通过流水段寄存器流向下一个寄存器段
2  流水段寄存器对用户透明，且用户程序不能通过指令指定访问哪个流水段寄存器 
![[Pasted image 20240815145945.png]]
选B 
3 流水线数据通路中，关于时钟信号的话，有如下指示 ：时钟信号不仅作用在流水段的寄存器上，同时还作用在PC 各类寄存器上，存储器等状态类元件上，并且每条指令的取指令跟译码 阶段都一样 公共流水段，
控制信号发生于指令译码之后 所以，不需要控制信号去控制他们 的


![[Pasted image 20240815150109.png]]
关于结构冒险中 ：
袁春风老师的：解决结构冒险策略两个方面：
方面一 : 一个部件的每条指令只使用一次，且只能在特定阶段使用 ，可以避免一部分的结构冒险 
方面二: 设置多个独立的部件来避免硬件资源冲突，例如 寄存器的写口跟读口分开，指令cache跟数据cahce分离等操作  

![[Pasted image 20240815150542.png]]
部分数据冒险可以通过数据转发 ，但例如 load-use数据冒险：
下一条指令用到本条指令的访存结果，load-use会引起一个或者多个时钟周期的阻塞，哟啊泰安家空rop指令 
slt $rd, $rs, $rt
slt指的是当rs的寄存器 小于rt寄存器的值的时候  rd的指令将会置为1 否则就置为0 

![[Pasted image 20240815153005.png]]
解析：
分支预测技术用于处理控制冒险，
静态预测技术：假定之分支总是不发生 false 或者总是发生 true每次预测结果一样的 
动态预测技术：根据之前的条件判断的结果来预测技术，并且根据预测局部性原理，其预测的成功率比之前的要高的多 

当预测错误的时候，已经之前被错误放入流水线的执行的那部分指令必须被舍弃扔掉才行，不然会导致其产生数据错误等问题发生


![[Pasted image 20240815153835.png]]
A选项 ：适当增加流水线个数 会使得每个流水线内的操作更加简单，流水段延迟更小 缩短时钟周期，从而提高时钟频率，
流水线的柳树段寄存器多，但是增加了流水线额外的缓存开销，所以加倍增加流水段的个数 因为流水段寄存器的增加增添了缓存的空间消耗 ，从而导致无法提升指令效率，
B随着流水段个数增加回到值流水段的控制逻辑更加复杂 多变
![[Pasted image 20240815154158.png]]
想实现超标量技术，CPU 中配置多个功能的部件跟指令的译码电路，并且多个寄存器跟总线 ，

![[Pasted image 20240815155048.png]]
注意：指令格式规整 长度一致   指令跟数据按边界对齐存放 
      只有LOAD/STORE指令才能对操作数进行存储访问  

这个是RISC的特征  
RISC中 具有以下 三种特征  特征一 ：指令格式规整且长度一致 
                        特征二：指令数据按边界对齐存放
                         特证 三  只有LOAD /STORE指令才能对操作系统进行存储访问 并且 在这当中 RISC架构体系中 




![[Pasted image 20240815170549.png]]
选C  也就是 不可以缩短流水线 功能段的处理时间 
即为  流水线功能段的处理时间指的是  各个周期的总的周期总量的值相加 而产生的时钟周期的损耗 

其还存在以下两条特性：
1 能在一个时钟周期内同时发送多条指令 
2 能结合动态调度技术提高指令执行的并行性的问题


![[Pasted image 20240815170830.png]]
数据在功能部件之间传输的路径成为数据通路，且包括数据通路上流经的所有部件 包括PC程序计数器  +ALU +通用寄存器+状态寄存器+异常和中断处理逻辑等 ，数据通路由控制部件控制 并且控制部件根据每条指令功能不同生成对数据通路的控制信号的不同  不包括控制部件 








第五章 特定题型专项训练：
关于阻塞问题 表格分析法：
![[Pasted image 20240815172202.png]]
![[Pasted image 20240815172219.png]]
![[Pasted image 20240815172230.png]]
![[Pasted image 20240815172240.png]]
### 对应的解题依据章法是：
选择题单算  不看解题技巧 凭借分析可知：
首先 搜集相关可能考察的指令：
有 ADD   LOAD  STORE  beq  addi  sub bne   已经考过的 这些 
按顺序排列 分析 每个指令在 IF ID EX MEM WB 这五个阶段都干了啥 

分析可能会产生阻塞的环节 以及情况 ：
上述五大阶段： IF（取值）   ID（译码）   EX（执行）  MEM（访存）  WB（写回）
## 一  ：指令ADD 
### IF 阶段：
	任务：
	（1）从指令存储器中取出当前指令ADD 
    （2）将指令放入执行寄存器 
      (3) 计算并且更新下一条指令的地址 通常是PC+4（32位字节是4个字节）
可能发生的阻塞分析 “
 Cache miss 指令的缓存未命中 ：如果指令存储器 的CACHE 未命中 可能得从内存中读取
 可能会导致流水线暂停 直到指令被成功取回
分支预测错误 ：
当出现 分支并且预测失败的时候，流水线可能得刷新并且取指令 因而导致的暂停
调用的程序：
取指操作：调用指令存储器接口模块   `Imeory[PC]`  
更新程序计数器 ：执行`PC=PC+4`
小结：在初始阶段可能会发生的是 本来想从chache 中去找到命中信息的 结果并未命中 

### ID（译码）阶段
任务：
   取出ADD指令进行译码
   ==读取OP中寄存器 源寄存器 RS跟RT的值 ==
   生成控制信号，用于后续阶段
可能会产生的阻塞:
1 数据相关性：如果op在前面的指令中还未写回，可能导致阻塞 ，解决方法是数据前递也就是数据旁路 或者暂停解决 
2 控制相关性：处理复杂指令异常情况会导致流水线阻塞

调用程序 ：
1调用译码器，解析OP 并且寄存器地址等
2 控制信号生成 ，调用控制单元系统等信号
3读取存储器  rs 跟RT寄存器内容


### EX（执行）阶段
任务：执行ADD 的算术运算 借助ALU 
结果写入目标寄存器 并且传递到后续阶段 
阻塞：
结构相关性 ：需要借助ALU部件，若ALU资源被其他的指令占用的话 可能会导致流水线指令延迟行为发生 
数据相关性：ALU进行相加 操作  如果 所需要的OP还在寄存器中，未准备到位 ，肯呢个需要插入气泡 等待数据救援 
调用程序：
    ALU ：使用ALU进行RS+RT加法操作 
      转发：检查数据是否需要从EX /MEM极端 或者 MEM/WB阶段产生你转发，防止数据相关性检测 

### MEM（访存阶段）
任务  ：ADD不涉及到任何需要访问存储器的阶段   所以 这一步没有
这一步会空出来 
### WB（写回阶段）
任务 ：将EX执行阶段的结果写回目标寄存器 ,存储：(Rd)
阻塞分析 ： 寄存器写回冲突：多个指令尝试同时写入，可能会导致阻塞 都想写入某个寄存器 就堵了
调用的程序 ：写寄存器 

## LOAD指令 ：从内存中取数据到寄存器
### IF(取值阶段)
任务：
(1)从指令存储器中 取出LOAD指令 
  （2）把指令放入到IR 也就是指令寄存器中 
      （3）计算并更新下一条指令的地址(PC+4针对32位的值)
分析阻塞问题：
1 指令缓存未命中 ：指令从CACHE中寻找的时候 没命中 ，无奈只能去主存中寻找对应的结果 
导致 没指令可读引发的流水线暂停 
2 分支预测错误：之前指令是分支指令 且预测错误，流水线可能清空并且 重新获取
调用的程序  ：
取值操作  `IM[PC]`
更新PC的值 PC=PC+‘1’


### ID（译码阶段）
任务：
   (1)将LOAD指令译码。并且提取OP 、目标寄存器跟地址基准寄存器
   (2)读取地址基准寄存器，并计算访问的内存基地址 
   (3)生成控制信号 
可能会产生的阻塞：
  (1)数据相关性：基地址寄存器中的值 依赖于前面指令（前面指令在调用）且并未写回，流水线可能需要等待并且处理数据
  (2)控制相关性：分支指令或者异常处理 引入阻塞功能
调用的程序 ：
1 指令译码器 
2 控制信号
3 读取寄存器 


## EX（执行阶段）
任务：
1 用ALU的计算的内存地址  基地址寄存器+指令中的偏移量 
2 生成内存访问的有效地址 

阻塞：
1 结构相关性 ：如果其他指令在此阶段占用了ALU的资源 ，可能会产生延迟 流水线功能 
2 数据相关性：基地址寄存器的值 未准备充分 ，的话 需要插入气泡等待数据 气泡指的是nop空指令那种 


可能会调用的程序：
1 ALU操作  ：调用ALU阶段进行 MADD =Rs+Offset  基地址+偏移量 
2 数据前递： 如果有相关性 ，则需要从EX/MEM阶段 或者 MEM/WB阶段转发数据到这里 

### MEM（访存阶段）
任务：
1 访问数据存储器  计算有效地址 进行内存访问的地址 
2 从内存中 读取数据 并且暂存到流水线寄存器中    （每个相邻阶段各有一个流水线寄存器 ）

可能会发生的阻塞：
1 数据缓存未命中 ：内存访问未命中缓存 ，可能需要从更慢的主存中读取数据，这会导致流水线暂停  （类比于刚开始的IF取指阶段 ）
2 内存访问冲突 ：若其他指令或者DMA（外部访问内存的一种通道）正在占用内存总线，可能会导致阻塞发生


调用的程序 
读存储器：调用存储器模块 读数据
存储数据：将内存中数据存储在流水线 寄存器中 以便在WB阶段写回
也就是说主存跟流水线寄存器的唯一的交互是 先直接将数据写入到寄存器中 在进行对应的写回功能 

## WB(写回阶段)
任务：
1 将MEM阶段 从诶存中读取到的阶段写入目标寄存器   
可能发生的阻塞：
1 寄存器写回冲突：多个指令同时尝试写入寄存器文件 ，可能会导致阻塞发生 
调用的程序：写寄存器模块，将数据写入目标寄存器 


## STORE指令(存数指令)：寄存器的数据存储到内存 

### 1 IF(取指阶段)
任务：
1 从指令存储器中取出 store指令 
2 指令放入IR中 
3 计算并更新下一条指令地址 
阻塞分析：
1指令缓存未命中  cache 中未命中指令的缓存 可能得从主存中读取 
2分支预测错误 ：
调用：
1 取值操作 ：指令存储器
2 更新程序计数器PC 的值

### 2 ID 译码阶段
任务：
     1 将‘STORE’指令译码 获取如下 三个地址  1 提取OP  源寄存器 目标寄存器 以及内存基准寄存器 这四个的内容  
     2 读取源寄存器 将要把数据存入内存中的寄存器Rt的值  
     3 读取内存地址 基准寄存器的  RS 是用来计算内存地址的寄存器
     4生成控制信号 
阻塞分析：
   1 数据相关性 ：如果Rs 跟Rt 值依赖于前面的指令 并没写回  ，需要暂停流水线等待数据 
   2 控制相关 ：如果存在 分支或者跳转 可能会引发阻塞 

调用的程序：
指令译码阶段：调用译码模块 解析OP 以及寄存器 的地址信息 
控制信号生成 ：调用控制单元 产生信号 
读取寄存器 
### 3  EX(执行阶段 )
任务 ：
1 调用ALU计算内存地址 ，通常是基地址寄存器的RS的值+指令中偏移量的值 
2 生成内存访问的有效地址 
可能会造成的阻塞分析 ：
1结构相关性 ：这个阶段要调用ALU  如果ALU被其他指令占用的话 会导致延迟 
2 数据相关性：若RS寄存器值依赖于未完成的指令的话 ，可能要插入气泡以等待数据
调用的程序 ：
ALU 操作  ：使用ALU计算我需要调用的内存的地址地址
数据转发 ：检查是否需要从EX/MEM或者 MEM/WB 阶段转发数据 ，避免数据以相关性阻塞 

### 4  MEM（访存阶段）
任务：
    1 使用EX阶段计算的有效地址 ，将寄存器的数据写入内存
      2执行内存写操作者