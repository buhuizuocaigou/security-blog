指令=操作系统+地址码 
不同体系的  架构支持的 指令集不一样  
x86  的架构 跟 arm架构 不同 
电脑是 基于x86体系的指令集  运行  而手机中是运行的arm 架构的  

ISA规定的指令集架构如下图所示：
1 指令格式：指令的寻址方式，操作类型，以及每种操作对应的操作数
2 操作数类型 是按照大端方式还是小端方式存放 的
小端序：低位放在较小的地址数中 高位放在较大的地址处中
从低到高分别为 对应着地址的从低到高
大端序：低位放到较大的地址书中  高位放到较小的地址书中
地址从低到高分别对应着 内存的从高到低

指令分为操作数（操作 码）+地址码 

操作码指明干啥   地址码指明去哪干

指令字长 是指的是 这条指令的字长 可以固定也可以 人为定义 ，跟机器字长 ，存储字长 固定值没有固定的联系 

但是 会设置 ：
1 单字长指令  ：指令长度=机器码长度 
2 双字长指令：指令长度=二倍的机器码字长 
3 半字长 指令：指令长度= 2分之一的机器码长度 

指令长度与机器字长关系对应了  效率不同 ，因为 机器存取 一次撑死能取一个机器字长的玩意儿 
指令字长：指的一条指令包含二进制机器码的位数 

定长指令结构：所有的指令长度都是相等的  
边长指令结构： 指令长度可以发生任意的变化

因为主存按字节编址 ，即使 在怎么变 指令一般都是字节的整数倍方便存取计算  



指令格式：
划分为 op+a  
op指明了用户想让cpu干啥去这个房子里面干啥  地址码指明操作的房子的地址
指令分类 ：
1 零地址指令 ： 关中断，空操作，停机指令  
2 堆栈计算机 隐含放在 栈顶跟次栈顶   计算结果压回栈顶  例如后缀表达式  
默认会 直接放入栈顶这个位置 



注意 : 指令表达中    A1 指向的是某个主存地址     （A1）表示的是指向地址的内容 

类型二 ： 一地址指令 
进行三次方寸 先取指令 然后读取a1指明的东西  然后再忘了往回写 
![[Pasted image 20240801153340.png]]
注意 此时存取一地址指令 的次数是 分解为 ：
1次取地址a1 +1次取op操作数 进行操作  +1次将结果放置在A1=3次存放

二地址指令   
op  a1 目的操作数   a2 原操作数
![[Pasted image 20240801153505.png]]
二地址指令 ：存取一次需要交互的次数是 
1次取a1 +1次取a2 +一次取op后三者进行操作  操作后 将结果存放到指定位置1次 =4次访存
三地址指令中  
op a1 a2 a3（指明 a2跟a1 当中进行的操作后  将结果放到a3中）
前几次类型中 执行完后 PC+1  存放即将执行下一条指令的地址   
![[Pasted image 20240801153715.png]]
交互次数：4次  取指令 1次 +取俩操作数2次 +存结果一次 
注意A3存放的是 最终的结果

四地址指令:
![[Pasted image 20240801153854.png]]
op   a1(目的地址) a2（源地址） a3（存放结果） a4 存放下一条即将执行指令的地址 
A4充当PC的值 存放下一次即将执行指令的地址  

定长 指令扩展操作码  
阶梯递减形式 并且是 最后一个数字给下一级别去做 
具体 看截图 
![[Pasted image 20240801154010.png]]

第二节 解决如何找到地址码所指向的地址的东西  
跟 程序计数器 PC 有很大的关系 
(PC )+1 =pc
(pc)指的是pc的所指明地址的内容 是多少 


10种寻址方式地址如下：
![[Pasted image 20240801201203.png]]
一共![[Pasted image 20240801202738.png]]

### 指令的寻址方式 ：
寻址 方式是指的到指令或操作数 有效地址的方式  目的是 确定下一条即将执行指令的地址
### 4.2.1 指令地址 VS 数据寻址
4.2指令的寻址方式：
1 寻找下一条指令的地址 也就是即将放入PC(程序计数器)中指令的地址称为指令寻址 ，
寻找当前正在执行的指令的地址称为数据须知 
（1）顺序寻址  
PC=PC+"1"这个1 指的是 下一条 或者是下一组的指令的地址 ，这个地址根据所表示指令的不同来表示  例如 如果他是16位  根据八位一个字节 来看的话  他就是需要用2b 的空间
也就是说 PC=PC+2 的 因为需要确保跳过当前所处的指令的位置 跳转到下一条指令的位置上 

（2）跳跃寻址 ：
根据转移类指令实现，即为转移类指令 ----跳跃给出下一条指令 jmp 等类似跳转指令 
具体是否跳跃则看的是状态寄存器 也就是OF 等指令的存储的模式来决定的 是否跳转 
分为 两种
1 绝对转移 ：直接给出目标地址的值 存放在哪里 就放哪里 
2 相对转移 ：比如地址放在80这个位置上  给的值是偏移量（这个偏移量是相对于PC给出的结果） 可以解释为 比80地址偏移了多少的位置的值 
由于cpu 总是根据pc的值去主存取  四舍五入相当于是给pc赋值了 
2 数据寻址 ：
指令中表示一个操作数的地址  其中  会将指令某一部分抓成寻址特征附加到指令的整体的结构内
具体如下：
![[Pasted image 20240801222007.png]]
重点关注这个寻址特征  的值  往往揭示了 寻址的一些方式以及特点 的

其中地址码的字段并不代表操作数真实地址 而是形式地址  不同的形式地址 与方式不同导致了最后中国结局不同  
结果被称为EA 有效地址 的方式 
寻址方式分为：
1 隐含寻址：
  不明着给操作数的地址 然后给 隐含操作数的地址   但制定地址指令 实际上将操作数 的值 周到主存中的地址中 并且跟ACC中的第二个操作数的值合并去处理 
  但是 在题目中只给出了 A的一个地址          
2 立即数寻址：
采用的#  +补码的形式表示    
其中直接指定了操作数在哪里  也即是值是多少 ，不需要搞内存  
在其指令表中展现为 #+一个值  为立即数地址 

3 直接寻址 ：
EA=A  既有效值即为最终操作数的真实地址  就访问一次就可以了 ，而且 A几位数相当于是 直接访问几位数  ，但是缺点是操作数的地址不容易修改 

4 简接 寻址 ：中转站寻址法：
借助一个存放在寄存器的中转站也罢 ，还是说直接存放在主存中数据也罢 A---B----C--》D
这样经过多轮的迭代已经多轮次的折腾后 ，用于简接寻址 ，但是坏处是 需要多次访问存储器并且占地方太大了 
5寄存器寻址 ：在某些寻之中直接 给出的不是主存的值  地址存放到比访问主存更快速的寄存器中，这样可以加快地址以及主存的访问速度 
6寄存器间接寻址 ：
经历了 寻址地址 ---》寄存器----->主存中 ，这样 经过寄存器一个折叠后  进行二次访问 
7相对寻址  ：（PC）+A 
其中PC 是存放下一个需要执行的指令的值 +A （距离基础地址 也就是操作数的有效地址的基础地址从而生成的有效地址的值 ）
注意顺序 CPU优先执行后 马上PC+1   就是记得pC要随时随地别忘了加一  
这时候PC的值可以任意指定 也就是可以指定任意的值作为PC这个玩意儿的开始的地址的值 
A是相对PC的政治怎的偏移量    
其广泛应用于转移指令 这样在转移后 就方便不用随便跳转到任意的值了就直接干 
8 基址寻址 
基址(BR)寻址器内容+A也即是基于标准显得偏移量  
其中BR可以采用通用寄存器 也可以采用的不是通用寄存器而是 专有的寄存器BR  
basic R 的寄存器的值  

其中这段操作 只有在操作系统中知道 在普通程序员的视角是无法讨论并且得知的这段真是的地址的值的  
其可以将其原理应用到栈溢出以及等 特定网络安全攻击手段当中 这是其背后的原理部分组成逻辑 

9变址寻址 

就是 变址寄存器IX 这个可以人为规定的值 +指令字A 的偏移量 
EA（最终的地址）=（IX）+A 的值  其中 IX存放了人为自定义的 地址  。因为如果起跑线不是0 的话而是 10的话 利用变址寄存器 可以将IX的值设置为10 这样做的话就相当于在10的基础上进行便宜  

其变址寄存器中的由哪个地方开始 是可以main相连接用户进行 
而且这个可以跟数组进行联动 并且 通过不断改变寄存器的首地址的值 来达到 循环遍历的目的 
变址寄存器 因为是面向用户主要处理的是数组问题 ：可以指定特定数组进行 

而基址寄存器中 由于通常有操作系统决定  非常有利于程序的并行操作的执行  而再多道数据中分配存储空间的值 ，进行并行操作 ，面相系统  然后A 的值改变也就是改变偏移量 但是不改变起始点

10堆栈寻址 ：利用堆栈的数据结构 以及 SP这个堆栈指针进行进一步的寻址过程 


### x86的汇编语言 的操作 
1 mov d，s  把s 操作数复制到 d 的位置   表示数据移动从s移动到d部分 
2 如果出现了数字 是立即数   
3 如果  ```
```
mov eax ，dword ptr[af996h]
```
其中  【】指的是内存的地址 内容 ，
而在 `[ ] `之前的内容  例如 dword ptr 这个 指明了 其 内存的 读写长度 
分别是 :
```
dword ptr ----双字 32bit
word ptr ----单字=俩字节= 16bit
byte ptr -----字节 8bit
```

![[Pasted image 20240802211838.png]]
这是他们一坨子的寄存器  
只需要记忆这几种 即可  
其中E 代表的是32为的意思  
主要是 后面  ESI 跟EDI 这两个寄存器即可 
I 是编号的index     ESI 是变址寄存器   
esi ：是 源操作器的 寄存器  EDI 是 目的寄存器  
变址寄存器 可以用于线性表 字符串 的处理 


如果是 AX  BX以及CX 中的话   相当于是 16bit 
在细分是  AH  高位8bit   AL  是低位 8bit
很少出现 ax bx ah bh 中的 

寄存器间接寻址的写法 
```
mov eax,dword ptr [ebx]  //这指的是寄存器的简介寻址 在寄存器 中的 地址输送到 EBX的 所在的主存地址中 
mov eax ，【ebx】如果没指明读写长度的话 ，默认是32bit 进行 
```

```
jmp EAX  
jmp 128 
jmp [999]
```
jmp 指的是跳转  跳转到eax 或者 跳转到128 亦或者跳转到 主存999
指的是PC 即将跳转下一条指令的值 存放到 后面那个地方  
这是无条件爱你跳转指令  
如果在汇编语言中看到了 这种  ：
![[Pasted image 20240803142009.png]]
带：的意味着 是 自定义的程序的指令的值 
其标号前的数据是可以自定义的  去自定义书写的方法的值 
用标号 自定义的值 让他跳转到对应位置即可 

条件转移指令  
![[Pasted image 20240803142151.png]]
`cmp a,b `比较a跟b 这俩数    对比 a跟呃 的值  
`jg NEXT ` 如果a>b则pc 进行跳转 
注意 这个跳转是针对pc 进行 的 

![[Pasted image 20240803143115.png]]
这个 f1 指的是一个标记  可以当做 成函数的标号 也就是标记的指令 即可 
会把函数名当做标号   从起始地址进行便宜    
CMP  进行减法运算
```
cmp a,b  计算 a-b 用alu进行i下昂iJan  然后  OF
```
![[Pasted image 20240803143401.png]]
会被放到标志寄存器   
psw程序状态字寄存器  被称为 标志寄存器 进行标记位的学习并且记忆  根据标志位来判断到底是否发生跳转 

```
inc edx //的含义是 inc 的方法对edx 的值进行递增 i++

```
![[Pasted image 20240803145059.png]]
注意有两次 cmp  注意两次 判断 ，也就是在循环开始判断的时候判断是否直接跳过循环的条件 ，
```
add eax ,edx  //也就是说 实现result++ 也就是 让result++ 让edx 中的值加山上eax 的值并且存在eax当中   
```

新指令 loop:
```
mov ecx,500 # 用 ecx作为循环计数器中   注意 在 ecx中默认是循环计数器  
looptop：#循环的开始 进行 
。。。
。。。
loo Looptop： #对 ecx 进行--  如果 ecx 的值不为0的话 直接跳转到绿泡泡【
top
```
如果使用loop指令 必须配合使用的是 ecx的寄存器
且loop指令的话相对于 代码更加清晰 清楚  没那么狠 
loopx  x 指的是某种条件  代指的是必须满足 某种条件
```
loopnz ==当 ecx！=0 的之后 且 ZF==0的时候会继续循环 这条指令 
```
其z 是  zero  

### 函数调用的机器级表示 中 ：
这片内存区域实现函数调用的栈   进行函数的调用操作 
利用ret 返回指针 跟  call 调用这个指令的相关信息 

函数的栈帧 ：（stack frame）：保存大括号内的 定义的局部变量 ，并且保存函数调用的相关联的信息 

```
CALL 指令的作用
```
1 将ip的旧值 进行压栈保存 保存在函数的站真的地步  
2 设置ip的信纸 无条件转移到被调用的函数 的第一条指令 

```
ret指令的作用 从函数的栈顶 找到ip旧值 并且回复其出栈恢复ip寄存器   起保存在 函数栈帧中
```
在函数调用中 如何传参并且调用返回值呢？ 
如何访问栈帧里面的数据呢？

![[Pasted image 20240803153524.png]]
关于这个 的 一切 秘密 
ebp 指向的是栈帧的底部  ，esp 是指向的是栈帧的顶部  
x86 系统中 默认4字节 为栈的操作单位    
上面是底    4字节 为一个单位 ！

push 跟pop 
```
push  立即数  寄存器 主存地址  入栈  
pop 可以是寄存器 主存地址  出栈 
```

ebp是指向的是栈底  
esp指向的是栈顶 

入栈 是 先动盖子 再 塞数据  
出栈是 先出数据 在动盖子 

mov 指令运行前提是 要具有足够的空间 也就是栈 的话先开盖子 再进行数据 mov的移动等 从寄存器糯香站   
而且 可以
```
add  esp,8 
sub esp ,4 //可以通过这个 暂时性的将其移动到指定的位置上  也就是让其栈顶或者栈底的指针进行指定出栈的过程 

```


栈底 是高地址 
栈顶是低地址 

所以栈顶下面  栈底上面 
ebp 指向栈帧的底部 
esp指向栈帧的顶部 

gdb是基于16b的进行 操作的行为  


![[Pasted image 20240803170924.png]]



CISC  一个指令完成一个复杂的功能   
采用封装的思想   可以采用功能丰富的指令  进行存储程序的设计思想  
复杂的 很多指令
指令执行时间相差过大 


RISC 是 一条指令完成一个 多个 构成  ARM 架构 

并行 进行  流水线设计      主要是一个指令对应一个 精简简单 一般小于 100条 
保留很精简的简单的指令系统体系设计方式  
定长指令集结构   
解析速度 
寄存器较多  有load store指令系统  


Load ： 加载指令  ：将数据从内存读取到处理器的寄存器重
Store ：存储： 将处理器寄存器中的数据写入到内存中来 
并且 可以用于数据的读写跟传输工鞥  


常用汇编指令大赏：
1 


