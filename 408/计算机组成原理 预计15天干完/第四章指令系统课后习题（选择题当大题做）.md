![[Pasted image 20240801154337.png]]
1 易混淆 A 跟B  
其中  PC指的是存放下一条即将执行指令的地址 既指令地址在执行过程中 从pc这边那 
B中的指令的地址码字段是说指出被操作信息的地址 保存的是操作数的地址 而不是执行的地址

2 程序的控制类指令用于改变程序执行的顺序 循环  等等 

3![[Pasted image 20240801154822.png]]
无条件转移指令：不给任何条件判断直接跳转到指令
JMP（Jump）：直接跳转到指定的内存地址
CALL（跳转到子程序并且保存返回的地址）
RET 从子程序返回到调用处

条件转移指令：
   根据程序的某些真假排判断指定位置   例如某些标志寄存器配合使用 
一般是带J的为多数
比如 在x86汇编中 
JE/JZ： 当ZF=1的时候跳转 用于判断相等 
JNE/JNZ 当 ZF=0的时候跳转 通常用于判断不等
![[Pasted image 20240801155435.png]]
4 可能在某些指令当中进行隐式操作 也就是说 操作数跟地址码中并不会特别显式的表示出这些指令的 具体操作  
进行隐式计算  ，此多存在于栈类型的寄存器中 
主要是在堆栈类寄存器中  运算类的指令不需要显式地给出操作数的地址 而是直接取用栈顶的值进行默认操作  相当于地址取跟存默认规定功能的

A 累加器跟寄存器：常见的操作数的来源 ，累加器暂存计算结果 其他的寄存器用于存储操作数
B 累加器跟暂存器 ：暂存器是临时存储的寄存器 通常用于暂时性的存储数据部分


![[Pasted image 20240801160220.png]]
具体解释这段问题：
堆栈指令的访存次数与其只i修改你操作类型以及堆栈的特性密切相关 ，主要通过pop跟 push来完成  涉及到 访存（内存访问）的计算 
 名词解释：
 双目运算指的是对两个操作数进行的运算 
 硬堆栈：由硬件直接支持跟管理的堆栈结构，其依赖于处理器中的特定的寄存器跟指令集
 特点：（栈溢出常见的位置）
 1 硬件支持：通过cpu直接支持 特定的指令集 直接从cpu中给出干净利落的指令 告诉要干嘛 管理栈顶位置跟栈底的入栈跟出栈的操作 
 2 SP 栈指针的寄存器 ：有专门的寄存器存放顶部位置的 修改指针来完成入栈 
 3直接由硬件管理  且是cpu中寄存器跟内存的一段固定大小的区域 大小区域在 最开始已经固定
 不会随机增长 
 4 可以嵌套 调用  自动保存返回地址 回到现场 并且可以及时的保存快照装阿嚏 
 5递归：递归依赖硬堆栈管理递归层次 
软堆栈
特点软件管理  由软件来实现 通常通过内存分配  复杂的数据结构等  
上述这段话中  软堆栈 的话 一共采用了四次访问内存：
1 取指令 从内存中取得相应的指令 
2 取源数1 ：从内存中获取第一个操作数
3 取源数2 ：从内存中获取第二个操作数
4存结果 将计算结果存回内存  因为是在软件层实现的所以需要频繁地与内存进行交互  
硬堆栈：
内存访问的次数就一次  直接从内存那  因为归于寄存器直接管理 速度就是快 直达核心


![[Pasted image 20240801161850.png]]
我的理解是 ，字长32位  16mb 也就是容量是 2的24次方这么大的东西  半字也就是一半 变为8mb =2的23次方  这么多 cpu一次只能处理原来一半的数据用于寻址
所以选B 


指令寻址相关题型：
1 采用不同的寻址方式的目的是：缩短指令字长 扩大寻址空间 提高编程 灵活性 ，寻址空间的范围变大了 但是变复杂了 导致最终的译码需要的位数甚至变多了 

2![[Pasted image 20240802142535.png]]
缩短指令中某个地址段的位数  
首先排除 立即寻址 跟间接寻址 因为 涉及到主存内的地址值 ，主存中存放的地址有多长  他就有多长 
注意 强调的是地址段的值，地址段指的是整个段 地址长度的大小 
地址段分为：对于变址寻址而言 其分为 两个 一个是 IX的值 这个是可以人为规定的 基础值 +A 形式地址 的也就是偏移量，这个形式地址 最终依旧回落到存储上面
也就是说 地址段=IX+A  A的变化会牵扯到整个地址段的变化

对于寄存器寻址而言 存放的是寄存器的值  
地址段位 OP+寄存器号  ：寄存器序号明显比地址段要少的多  

易错点在于地址段区分不清楚导致的问题 
3![[Pasted image 20240802143602.png]]
首先 跟PC 没关系 为啥呢 PC 是针对于 相对寻址而言 
排除A  其次 
有两种寻址方式 一个是变址的基础上加上间址  
变址 是人为定义这个地址 ，就是 IX取数据 作为基础地址 然后 在加上偏移量 
地址码是A 偏移量是A  然后编址寄存器中为X  其取数据为 (X) 得到这份数据后，在进行A便宜 
这取得数据 作为EA的地址码进行  对主存的访问  
迷惑性最大的点在于 看到了是有效地址 排除A跟B 落到数据上 但是 间址证明了不是这样的 

4![[Pasted image 20240802152707.png]]
线索点：1 主存地址位16位 ，意味着 一共地址的总空间是16位 ， 
机能能完成97种操作的前提下 操作码  二进制表示方式是 2的 6次方-2的7次方  
为了能撑得住 97种操作方式需要2的7次方这么多 操作码  64-128之间 
7位操作码固定  一共能提供 7位 操作码 
在这操作码当中 =  7个空间当中 有  六种寻址方式 至少得占用 3位的 格子来用二进制表示这6种 
然后 7个空间 3个格子


从头再看一遍   
16位的指令字长 = 操作码 7位 + 寻址方式3位+偏移量 
所以偏移量=6位 
这6位的数字 因为是相对寻址 用补码表示  ！！！！
补码中 6位 
正数  0 11111 32-1=31 
     0 00000
负数 10000
      直接算价值 不用考虑符号位啥的   就是 1 是权重是-的 同时-32 
      111111  -32+16+8+4+2+1  = 相对较大
不用管取反加一判断标准 计算符号位权重 的值 算上符号 
![[Pasted image 20240802154009.png]]
其中 知识点如下 ：
PC中存放的是下一条 指向内存的地址 ，也就是说 内存多大 怎么表示 他怎么表示 
IR 中存放的是 指令 寄存器  

这种比较易混淆 

![[Pasted image 20240802154118.png]]
20题中 翻一倍就行  
8 --->1200H
其中8 是进行寄存器寻址  
8中的1200H 作为间接寻址的地址号 
注  提问的是 有效地址 不是地址存的值！！！！！！！！！！
![[Pasted image 20240802161957.png]]
其中   这几个有很多坑点 
坑点一 ：以低字节为低地址
坑点二 ：补码的符号位是以扩充符号位为标准进行扩充的
坑点三：取出指令的时候题目中提示了也得算上 
三大坑点 掉一个直接g
其中 突破口是  从240--290 前进了50 
但是 因为指令是自动取出 又有一个op两个A 也就是说内存的存取次数达到了3次 也就是与pc互动的次数达到了3次 
所以  在 pc执行偏移之前 ，光存取指令先加3  也就是pc实际上是从243 到290 这个过程 
也就是偏移地址为47  ---47转换为补码 正数 表达为二进制 的 101111 补码 且为正数 也就是说 不变 
注意 此时补全 为一个字节 也就是 00101111  转换为16进制是 2F H     且对于以低字节 为字地址 也就是以8bit为单位进行排序    低字节优先 高字节实际上就是符号扩展位 所以说  低字节 二号字节 为 2FH  而更高的三号字节为 00H  因为正数 符号扩展 为 0 
而在PC 当前值为240  向上移动到200  也是先动3次  243-200=-43   注意 此时隐含了一个坑点  ：坑点就是 在向上移动的过程中 跟向下移动不一样的点在于 ，向上移动的时候 取指令的时候PC的值是加 而不是想当然的减号！！！！！！
所以 是从243 -200  向上动记为 -43  =1（符号位）101011
变为补码是：110101然后符号位扩展到8位字节 1111 0101  =F5H 
其中满足  低位 也就是二号位是F5H 高位 3号位是 补码的符号位扩展 是FFH 也就是全1 
![[Pasted image 20240802164114.png]]
四个选项   
概念性 
A ：要考虑隐含寻址 指令 
B：移位  通常用于把指定的两个操作数左移或者右移一位或者多位 
C：转移指令 子程序调用 与返回指令 用于解决的是指令调用次序需求 不是数据

![[Pasted image 20240802164259.png]]
在这当中 首先避免的坑是 PC 转移  不用考虑取几次内存  几个字节取几次 
2个字节 一次操作是2  
也就是说 PC+2 2000H+2 开始的PC的值 +06=2008H pc的值 目标地址是2007H 

![[Pasted image 20240802171300.png]]
分析  判断无符号整数中 比较大于的时的指令是 A-B  加上是无符号整数  不存在溢出 跟 符号标志 
故 没sf 跟of这俩   
zf  是零标志  也就是当 A-B=0的时候 他们俩相同  ZF的值是1 否 则的话 ZF的值是0
大于不包含0 也就是说 他们zf 取0  且 CF中 借位  发生借位 进位 这个 如果发生就1  不发生就是0  
不管是1 还是0  他们做 或运算后 肯定是0  然后取反就是1  
这是针对 大题而言 如果是选择提的话 通过做题技巧来说 直接 不考虑sf 跟of 直接秒了 

![[Pasted image 20240802173035.png]]
首先 32位的定长指令字 
32位=操作码字段8位+ 从基址寄存器可使用任意的一个通用寄存器来推断出 基址寄存器 可能是16个通用寄存器中的任意一个 需要用 2的4次方 也就是4个格子表示 +直接寻址 16个 4个格子 
  注意这句话  源操作数跟目的操作数 分别采用  中的分别这两个字 段 ，
  32-8-4-4=16位 
  16位的补码是 -32768 ----32767

操作数的有效地址是主存中存放的地址 

![[Pasted image 20240802173712.png]]
2100H-2000H =100H =256
double 是64位 也就是8个字节 sizeof 是计算doble的字节数 
256/8= 32  也就是 进行32次循环 计算8个字节 凑够 256 


  汇编语言部分 ：
  ![[Pasted image 20240803211137.png]]
  这种类型的题目  
  分析  bx+ax的值存放在ax 中 
  其中  注意  ：其所操作的一切都是补码 存放的数据 不会变 也就是从16-2进制翻译后 的值  是补码的形式解释的  第一位是符号位  数字并不会发生任何变化

信息梳理 补充：
OF 溢出标志位 ：在补码的运算中 其=1 表示发生了溢出  =0表示未发生溢出
SF  符号标志位  表示算术运算结果的符号表示    SF根据最高有效位 阿里设置  补码 中 0表示正数 1表示负数  他会反映出结果的正负 
如果是SF=1 结果是负数  如果SF=0 则结果是正数
CF 进位标志位 ： 指的是进位或者借位的运算 ，最高位的是否像高位产生进位  
如果 发生 CF=1 如果未发生 则cf=0 针对无符号数而言的 
ZF 零标志位 ： 观察是否运算为0 主要是针对 CMP比较指令而言的  本质上cmp时进行减法运算不存出结果  当减法结果是0 的时候 zf 位被设置为1  否则的话zf位被清除为0 

这道题木而言  
rax FFE8H = 主要就看高四位 也就是  F +7 = 1111 +0111 =1000 其最后 一个正数 +一个负数 到最后 是一个正数  因为位数 把 1 排除了    因为地方不够放 但是并未发生溢出 
这时候有个混淆 ：==其 多出来的1 是因为 不够放 导致的1==  只能放得下16位而导致的1  并不是因为自己的加减运算  因为 在补码的表达形式中，一个负号 跟一个正数不可能产生溢出  

![[Pasted image 20240803212434.png]]
首先  线索关键词  1 小端存储 ===  低位存放的是低地址  高位存放的是高地址 
而后 imm=-3  表现为补码形式 时刻谨记 表现的形式是补码的形式表达的 
补码 =     而imm是-3  也就是3 的二进制形式 是 0011  其   负数的补码转换时 进行取反+1 
0000 0000 0000 0011 取反+1 后的值是 
1111 1111 1111 1101  也就是转换为16进制是 FFFDH  这个数字 
后来 由于 高低址去高位  也就是就按个这个 FF 是高地址 去高位 
而 FD 是低位 去低位 
注意 这时候不要去动2d 而是动后面的  xxxx 也就是 FDFF  这书序交换 3DFDFFH  
而 7+3 同号 不会产生溢出 故 of的标志位的 值是0  


时刻注意按补码存储 并且乘法如果是倍数的话 平移 先计算正负号在进行平移 时刻谨记！！！！

![[Pasted image 20240803214054.png]]
这个是  判断 满足条件  进行跳转  
注意  此时跳转的时候
jle的值 执行 就是 小于等于的时候发生跳转  并且 其 重点在于 执行后 将会转移到的指令
虽然便宜指令是 0d  jle后面跟了一个xxxxxxxx  其位数是八个字母 也就是说 是2个字节 的值 
不可以忽视这个 2个字节的值  记得加上直行道最后的地址 因为 得放进去 就是说  得算上橙子啊jle的位置的地址 


