三个进制 ： 二进制 ---八进制（3组一砍）---16进制（4组一砍）
注意小数的转换
2.1.2 定点数的编码表示：
真值 ：机器数代表的实际值 ，就是咱们平常怎么表示他们 就 表示成啥样 
机器数 ：数编码后存放到信息的值 为 机器数  
2.1.3 机器数定点表示：
分为定点表示（小数点固定 ）     补码整数表示整数 且 源码小数表示 浮点数的尾数部分 
定点小数 ：小数点固定 首位是符号位 其中0表示正数 1 表示为负数 ，并且
定点整数：首位是符号位  其小数点默认固定位置 在最后端   
其中尾数指的是 除了符号位后其他剩余的位置 

2.1.4 源码反码补码 移码
分为有符号位 首位为1  跟无符号位 首位是0    
源码 ：定字长 一般默认是8位 首位是符号位  其他位置该转换转换 然后 左端那零补充上就可 
表示范围是0-2的n次方-1 
注意  0的源码表示有 +0跟-0 两种 分为 00000000 跟10000000
优点：1跟真值一一对应     

补码： 补码是 分为 正数跟 负数  也就是符号位是0 跟1 的区别 
若符号位是0 的话 则补码跟 源码表示方式一样   
若符号位是1 的话   除了符号位 其余满足 各位取反后末位+1   如果是 补码转为真值的话  也一样  除了符号位外 各位取反 然后末位+1 
注意这是 补码跟 真值的 转换 不是 补码跟 源码的转换

源码跟反码表示在数轴对称 且 二者均存在 +0 跟-0 yishuo   
补码跟移码   移码的情况是在补码上面将符号位取反即可 
通过这么做 移码可以侧面反映出 源码乃至真值的大小情况 方便计算机进行比较各种数据的大小内容 的问题 

2.1.3 整数的表示 
1无符号的整数表示：
定义：都是二进制位无符号位  无0 1 位 其均为二进制位 ，其省略了一个符号位的存在 所以能表示的比 有符号的要打 范围要打 ，可以用无符号位进行地址运算 以及指针的运算 

2 有符号整数：
这个是 高位代表有符号位，既 高位0代表的是 正数  1代表 的是负数  他 原码反码 补码 均构成了有符号的整数位  补码 表示的话相对于 原码 反码 移码等有一些优势  其优势在：
1 0的补码是唯一的  不存在 +0 与-0 一说
 补码不能表示-0 是因为 -0 的反码是1111111111   然后 他的补码 末位+1 后表示为0000000 造成溢出的一位不算  
 2 移码是 补码高位取反 也就是 符号位 变一下   0 的补码就一种表现形式 因为 移码是针对 补码进行变换得到的 所以说  移码也相当于是 0只有一种表现形式 

3 对于源码而言  其最高位 表示符号位  如果取反的话  表示为反码的 话  +0 000000000 -0 1111111111
有两种表现形式  


所以综上所述  只有针对 与 补码的 变换以及移码的变换  这两种类型的变换 无+-0之分  其他两种源码跟反码是可以有+-0 之分的 



2.4.1 C语言中整数类型 及转换  
c语言中各种字符型变量所占的字长：
1 char 8位  
2 short   16为  
3 int 32位 
4 char 默认的是无符号整数   其他的  类型 如int  short  int 等不指定的时候默认有符号整数  
注：无符号整数中无符号位 即为有符号的绝对值  是这个类型的数值  
2 有符号数跟无符号数的转换后
强制类型转换     进行强制类型转换会改变位数 
规则是：高位 速度安慰地位 是  保持为的值不变 

当出现无符号数跟有符号数共同参与进来运算的时候 其c语言规则规定的是 统一按照无符号数字类型 变换  


当长的  变成短的 例如 int 型占4b  short 占2b   当从int强制转换为 short的时候 ，直接截断高位 只保留低位的   
16位的除了符号位以外 高八位直接截断  其余第八位直接继承  （转为16机制后执行 ）


当低位数的 低八位转为高八位的情况下的时候：
当原数字是无符号数字的时候 直接用0填充  当原数字是有符号数字的时候 扩展符号位   


课后题：
2的16次方=65536
2的15次方=32768

注意 ：
补码操作 是将每一位都取反 在加一  包括符号位 

其强制类型转换时候 是 先把原有的数字 取补码，然后 数字不变  看待方式发生变化  注意 当取完补码的时候 是原数字保持不变  一定不鞥改变 然后看待这串数字方式会发生变化  


## 2.1运算方法跟运算电路

逻辑运算学科 《离散数学 》
数字电路知识补充学习  ：
逻辑运算： 对比逻辑值的真假  进行运算 与或 非  异或 等 
算数运算： 实数  加减乘除等 

都得有输入/输出 

与：
Y=A · B       A B 同时为1 真的时候   Y 才为真 1   A && B =1  
与门 输入的一段是一条直线  
可以简写为 Y=AB  
 或 ：
 OR  
 y=A+B   只有  A与B 为0的时候 才全为 0  但凡有1 的时候 均为1 
 或门特点 是 弧线  输入的时候 是个 弧线  

非： NOT  
Y=a否    
输入一个逻辑值   取反       图形中是加一个原点小白点 


与非  NAND  
A·B 取反   先向与 再取反     

Y=AB 取反  

或非  ：NOR 
一个或门 +非门 来实现  结果  最后总共取反 

异或  ：XOR
不同为1 相同为0  

![[Pasted image 20240719113134.png]]

同或 XNOR  
相同 为 1  不同为0  

多路选择器
MUX  守门员 ：
 只允许一个 通过  其他输出   在多路中 只允许其中一个数据通过mux 中  
 控制信号的位数 >log2k 的bit  1010101  位数 2bit 就是 一个 坑有10 两种 
 至少得 有4个坑才可以   
 
 就是  电路中的  通常用虚线来表示  数据的是用实线表示信号 
控制信号的op中  表示闸门 相当于 op=几  相当与放人  
![[Pasted image 20240719120127.png]]

### 三态门

单路线守门员 只能守单线程  
当控制信号为op=1 的时候 放人  
当op=0的时候让他趴下 

  
 ![[Pasted image 20240719120319.png]]
 什么是高阻态呢  ？
 高阻态 相当于是0阻  态       虚线是控制信号的表达形式  

注意 非门没控制信号  也就是无虚线 但是 三态门的话是有控制信号的 内容


### 加法器

![[Pasted image 20240719143707.png]]

Ai=加数 位数的信息  
Bi=被加位最后一位的信息 
ci=进位的信息 
一共有两种情况 进位与 不进位  并且分别进行考虑 

![[Pasted image 20240719143855.png]]

串行 有延迟  ，不行  我得让他顺下来     这个是一级一级串行  
加法器运行速度取决于 进位产生或者传递的     串行进位=行波进位    

并行加法器  （输入端输入 多个比特 ）

进位方式 ：由于进位方式 是因为串行 产生      加法器属于 串行进位的加法器 

改造 后  进位信息同时产生 会更更快         如何改造 不用深究  
只关注加法器的逻辑功能   


### 带标志位的加法器 （逆向寄存器的值来了 ）
OF = 溢出标志位 ：判断带符号的数字的加减运算是否产生一处 OF=1 溢出 OF=0没有一处 
CF =进位/借位标志 ：判断无符号数是否产生一处  CF=1溢出  CF=0未溢出  
SF = 符号标志  带符号数的加减运算 正负性  SF=1 结果是福 sf=0 的时候结果为证  
ZF =零标志  判断加减运算结果是否为0  ZF=1 结果为0  ZF=0 表示结果不为0  


基于电路改造而来的 
![[Pasted image 20240719145525.png]]

这是 四大典型标志位对应的信息点 

![[Pasted image 20240719145603.png]]
逻辑表达式 得关心   
ALU 是算术逻辑单元   
具体细节如下 ：
ALU 是实现各种逻辑功能 是运算器的核心      
加法器是 ALU 的核心  核心是个加法器  
ALU功能： 算数运算：加减乘除    逻辑运算  异或  与 非  同或等等 


ALU 支持k中功能  然后  一共有  控制信号 的话  1010010  只能表示1或者0  然后 通过这个表示出塔的种类数  也就是  k用101001表示   看究竟有几位 

直送 ：怎么进 怎么出    
求补码 是自动进行求补码的过程  
ALU  的 运算数 运算结果位数 跟 机器字长相同 本就是从 机器上来  当然要从机器上走  

alu的标志位的 信息 通常会被送入psw的寄存器当中 进行信息处理
PSW 程序状态寄存器 称为标志寄存器  是FR 代表了存放的ALU标志位的信息  

Cin 是 进位输入信号 COUT 是 输出信号 


## 移位运算 

算数移位：
1 后移放大  前移缩短  
改变位全 等价的  实现乘除 

原码的算数移位 ：  符号位保持不变 ，仅对数值位进行移位   高位用0补充 
仅对数值位移位

正数处理 的方式 是 跟 原码的一样 


对于负数 的移位问题 由于 算数移位中 取反 1相当于0 0相当于1  故补位的时候全是1  相当于是全是0  一个概念 

![[Pasted image 20240719152343.png]]

逻辑移位 直接高位补0 后面直接扔    
相当于无符号数的移位  

循环移位 
![[Pasted image 20240719153152.png]]循环移位的位置  
注意    这中百你还  

由于原反补码   表示有限 ，所以会导致 精度丧失误差 


原码的加减运算 ：
正+正  绝对值 做加法  结果不变 
负+负  绝对值做加法  结果 保持不变 带符号 
正+负  绝对值大 的-绝对值小的  符号位 听绝对值大的 占比大的  
减法的时候 可以将后面 的取反 后  转换为 加法进行操作 







补码的加减运算  ：
取补码的时候  符号位不变 其他的取反+1 
b 的补码 转换为 -b的补码 的话需要所有位全部取反 +1 
溢出的判断问题：
![[Pasted image 20240719164254.png]]
计算的时候 规则 一会儿总结  
一共有三种方法总结 00
计算规律待会儿再总结也不晚  


一共三种类型 
第一种   原码的加减 
第二种   补码的加减
第三种   溢出判断

### 无符号数的加减运算 
带符号数：
补码加法 ：符号位正常参与运算 
补码减法  以 a-b为例子，将 b 的补码转换为-b的补码 ，并且 按照加法进行运算 
ps：将b的补码转为-b的补码的方法是 所有的位 取反+1 后从b的补码得到-b的补码
将 a-b--->a+(-b)

无符号数字：
补码加法 正常加就可以  了  
无符号的减法 ：
补数  ：  b +b的补数 刚好=256  这个值 
A实际上加的是  b的补数 
A-b---》A+b的补数 的值    这样就可以换算成     减法变加法  然后 前提是 B与b的补数 换位 256  这个数字

考试  ：无符号数判断溢出  
手算：确定无符号数多少个bit  0-2的n次方-1   超出范围 就是溢出  8bit 溢出只能表示 0-255的   手算只要确定他在不在这个范围内就可    
机器的是：
1 无符号数加法的溢出 最高位产生的进位=1时发生溢出  是否会往前拱导致 本来应该存在的8bit 的格子 不够了  ，就可以直接判断    
加减法 相反了  
无符号数的减法溢出是： 减法变为加法 且最高位产生的进位=0 的时候 发生溢出 否则则不会发生溢出
减法  的时候 反倒不能再 规定框带着   必须 往前溢出  

加法的时候 反倒 多一个1 会导致溢出 这种情况减法的话则不会发生 


补码的减法 运算  的电路表示 

注意在电路的时候不可以忘记    要加入cin  的值  这个指的是 低位 的时候 因为1+1 =0从而产生的进位的信息 
![[Pasted image 20240720145634.png]]

例如 这张图 不要忽视 来自 cin 的产生的信号  一定要加起来这个  

补码  的加/减法 
以及体会标志位 如何生成 的 


乘法运算的实现过程 ：

![[Pasted image 20240720153511.png]]
注意手算模拟一下 
进行加法 移位操作  可得到最后的值 


补码的一位 乘法              
![[Pasted image 20240720154710.png]]
补码中符号位参与运算   参与这次运算的 规则  


注意包含符号位的 

补码的乘法   的中 算数右移  取决于 政府  



## 浮点数的表示 


浮点数的作用跟基本原理
 重点是浮点数的规格化 ！！！

浮点数  当 数据二进制位数不变 如何增加浮点数的范围呢？

![[Pasted image 20240721151403.png]]
分为 阶码跟尾数部分  
阶码   是 证明有10的多少次方的  
尾数是反映数字的精度的部分  


定点数 ：  小数点的位置固定不变 

阶码 ：常用补码或者移码 是定点整数  
 尾数 ： 原码或者补码的 定点小数 

```
3.933*10 的 11次方   记为  +11 +3.933  在二进制中通常默认为底为 2的次方数  
原因是在二进制中的话 2的1次方 相当于 这个数字右移的记为数字  可以类比为 19禁止的科学计数法 进行讲解   

注意 后面精度的判断 
阶码 e表示浮点数的小数点的实际范围  尾数的M 反映的是浮点数的精度问题     
```
阶码 由，区分符号位  
 0，01;1,1001
 分别翻译  ;前面是阶码  后面是对应的给定的表示方式  ;后面表示的是尾数 
如同  科学计数法一样  能省0 全省掉   
不管是左移 还有右移 就   就对比科学计数法就可以了  


设置双0 让他多一个符号位   由一个符号位变为俩符号位 由 0  变为 00  dobule符号位处理即可 

采用双符号位的话 当溢出发生的时候 可以来救火的时候 可以挽救    

最高的符号位 可以反映 本来该存在的符号   可以挽救某些溢出的     现实当中最可能被利用的部分  
原码  表示的尾数规格化：
注意： 科学计数法的    次方值记得加减  ！！！！！！！！！！
规格化 最小值 是 
0.1 1111111   最小值 是 0.1000000
首位是符号位 1 跟0 注意 首位是符号位！！！！

规定是 ：  当补码表示正数的时候   如同原码一样  

负数的是    必须保证  1.01   1.00  有个零  进行分割  标准的补码分割位 是这样的  
是补码还  

补码 算数左移  低位 补 0      补码算数右移 高位 补1

![[Pasted image 20240721154352.png]]

## 浮点数的标准
![[Pasted image 20240721155308.png]]
移码的核心是 移码=真值+偏置值   

偏置值一般去 2的n-1次方        

另外一个标准 偏置只 是 2的n-1次方 -1  
在这里面有个默认的规则 是 mod 2 的8次方 这个规则标准进行的  
如果 被减数比减数小的话 可以加2的8次方 在来一轮然后 再次求解 

无符号数的移码  越大   让他  的真值 表示的越大 

IEEE 754标准是  
短浮点数  float  
长浮点数 double
临时浮点数 long double 这个表示 的 


754  标准中  全111111跟 全 000000   用作特殊用途    
全 11111 用作 -128    全0  是 127  

 ![[Pasted image 20240721160123.png]]


高位的1 原本是隐藏值 即为 隐藏的信息   
也就是对于 尾数部分 的是 1.M 是这个部分、




![[Pasted image 20240721162303.png]]
你他妈说的


阶码溢出是真正的溢出   

课后题总结 ：
关于双符号位的溢出的问题：
关于双符号位 如何判断溢出的问题  有如下分析：
分析1 ：关于双符号位的溢出问题  
00  11   
其中00 代表的是正数  而 11代表的是负数 
所以 在其中 如果出现了 01   的话 代表的是正数  （最外层是 0  溢出 ）
既 第一号位代表了符号  而 第二号位代表了是否溢出  10 发生了负数一处  01 发生了正数溢出 而 00  11 均代表未发生溢出 

当计算机内部加法器进行计算的时候 
计算 x-y  相当于 是 计算 x的补码 +-y的补码  
在当中利用加法器运算的时候    其sub 提供了 1 还是0  1
带标了进位 取反+1 的操作  然后 电路中只能进行取反 不可以进行+1  


补码的乘除 关于2 的计算是可以通过移位来表示的   
！！！！！
