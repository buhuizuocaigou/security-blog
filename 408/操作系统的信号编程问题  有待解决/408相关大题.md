不要惧怕大题 开干！
![[Pasted image 20240923195635.png]]
分析 ：首先 对与以上三种算法的并发性 
排序 如下  1 检测死锁  2 银行家算法 3 资源预分配 
原因以及分析如下：
步骤一 检测死锁：
并发性最强 ，因为检测死锁的时候关键在于允许无数种资源运行，只需要检测是否会发生死锁即可，如过有的话 进入中断来达到接触死锁的目的



步骤二 银行家算法：
核心在于 对资源的分配  ，对于银行家算法而言 ，则是对资源的模拟过程，也就是说 他对资源进行合理的模拟训练的过程 ，这个过程中 他是允许死锁的发生 ，但是也是
判断是否处于安全状态
步骤三 资源预分配：  对资源及逆行模拟分配的额过程 主要是  预先分配的过程 ，默认不允许死锁发生 保证百分百的正确率 否则不会下发资源给后面


死锁四个必要条件 ：
1互斥 2 请求并保持 3 不剥夺条件 4 环路等待条件 

![[Pasted image 20240923200908.png]]
对于每一个元素而言 他们获取的资源量是 必须保证自己 k(n-1)+1 <M   也就是说，他们必须保证自己获取的资源量比他们的最大需求量要大的多 ，即可 想像成一个圆环 里面每个人左手拉右手 形成一个死循环，若把其中任意一个人单独孤立出来后，其他的人就可以刚好分享最大资源数据   
![[Pasted image 20240923214416.png]]
