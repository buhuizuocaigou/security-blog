1 PCB   PID  UID    （数据都存放在pcb中 ）
每个进程被分配为一个 特殊的身份证号，这个身份证号就是pid 
PCB创建的时候 是操作系统 在进程管理的时候 所存放的信息  
PCB供操作系统用的 
程序段跟数据段时 给自己看的 用的 
PCB是个代称  代称的时进程的   PCB  
2内存中除了数据段 以外 还会有指令段组成
故 一个进程的实体（进程映像） 是 由  PCB+程序段+数据段 （这三者房子啊内存中） 这三者 组成的     进程映像 也是进程实体      进程实体的运行过程 并且是操作系统中的资源分配与调度的一个基本的组成独立单位  相当于是快照
 且进程是动态的，进程实体 是在不断变化过程中的 
进程是系统进行资源分配跟调度的一个重要程序节点 
3 特征  ：动态性（程序一次性执行的过程 是动态产生并发并且消亡的）  并发性（内存中多个个进程实体，并且 各个进程可以并发执行） 独立性（进程独立运行  独立获得资源的基本单位）  异步性  结构性  
任务管理器里面的一部分 


### 二 、进程状态以及 转换   
1 创建态+就绪态 运行态  阻塞态  终止态  
进程被创建的时候 是”创建态“ 初始化pcb  
就绪态 ：进程创建完成后的状态是 就绪态     当cpu  运行的时候   操作系统空闲  选择的时 就绪态 程序 进行 转换为 运行态的过程  
阻塞态  
剥夺 这个进程的使用权 ，就是事件发生前进程无法继续执行 ，操作系统 会让进程下cpu 进入阻塞态
运行的时候  被挤占 剥夺了  
终止态 
一个进程执行exit 系统调用了  请求操作系统终止进程 该进程进入“终止态”操作系统会让该进程下cpu 回收空间，你进程都终止资源了，进入“终止态“  让进程下cpu 回收内存空间等资源 回收该进程的pcb

进程状态转换 

几个cpu 就意为这同一时刻有几个进程处于运行态 
创建态->就绪态->运行态->阻塞态             运行态 ->阻塞态  ==主动发生== 是系统调用方式申请某种系统资源 
 阻塞态（等待态）-->就绪态  ==被动发生== 

运行态-->就绪态 （当发生时钟中断的时候 可能会发生 ）例如 “当时间片到了  时间片用完了 或者处理机 也就是cpu被别人抢了 

操作系统如何记录状态的呢   在进程pcb中会有一个state表示进程当前的状态
阻塞队列 指针 
执行指针 
等待打印机阻塞队列的指针 
磁盘阻塞的指针 
各种指针  进行连接 并且 规定组织 以一种链表的方式 进行组织并且进行访问的过程 
进程的组织 ：索引方式  


控制进程相关源语 
![[Pasted image 20240901100429.png]]

![[Pasted image 20240901100450.png]]

![[Pasted image 20240901101035.png]]
进程因为何事阻塞 就应该由何事所唤醒

### 进程通信 IPC  两个进程间产生的数据交互的行为  ：
各个集成之间  拥有的内存空间 相互读李 
一个进程不能访问领一个 进程的地址空间 

一 共享存储 
进程 中 会有 共享存储区  为了是  同意拍你共享内存区映射到各个地址的进程空间中去 
![[Pasted image 20240901104220.png]]
注意 各大进程对共享空间访问应该是互斥的行为 
如何 保证 呢  尽心个 内核提供的同步工具  也就是pv操作  来进行同步互斥的工具来 进行  

高级通信 ：
划定的共享存储器  数据  然后 这些 区域由进程控制 不是操作系统  然后 这种 速度会很快 
低级通信 ：
基于数据结构进行共享  ，共享空间存放长度为10的数组  共享方式速度慢 限制多 低级通信的方式进行 的 
### 消息传递：
格式化消息为单位进行  系统提供发送接收消息 进行数据交换的行为 
![[Pasted image 20240901104808.png]]
消息头  消息体 分别是什么很关键   
直接通信跟间接通信 
我是谁 我要发给谁 

管道通信方式 
`whoami | grep "$a=1"`
管道是特殊共享文件 是个pipe文件 其实是在内存中开辟一个大小固定的内存缓冲区 进行开辟大小固定的 内存缓冲区的过程 

管道通信方式=隧道 的形式 
fifo 的循环队列  的形式进行 的 
管道支持的时半双工  在某些 时候实现的是单向的通信 
各大进程访问的时候是互斥 
当管道写满了 写进程阻塞 到读进程取走 换血写 
管道一旦读出 就彻底消失 
所以才会采用的时 多个写一个读 或者多个写 多个读 linux方案 


### 线程的神奇奥秘 
一个进程当中 可能包含多个线程  其中cpu轮流对 线程进行服务  的话  他可以 让一个特定程序 中 同时运行多个事情并且执行他们的过程  
引入了线程后 ，线程 成为了程序执行流的最小单位

相当于一个进程中可以同时干多个事情 也就是干多种事情即可 
同一个 进程内线程的切换 相当于熟人之间 的联系   不需要切换大环境，反正都是在同一个的框架内 ，不如直接去做 
TCB是线程控制块 tcb结构  线程 也有 就绪阻塞 运行 

线程只管调度  资源还是在进程内部的 
进程=不同的程序app 
线程=程序app的不同功能 


#### 多线程模型 
用户级线程+内核级线程 
ULT  用户级线程  早期unix  只支持进程 ，不支持线程，它由线程库来实现的
用户级 的线程库  因为是程序员自定义完成的，所以 他就是线程库完成的 而不是内核直接完成的相应的程序方式的问题 

操作系统不管你干嘛 ，只能意识到 进程 存在 他不知道线程库后面的线程是干嘛的 
操作系统支持的线程是内核级别线程装4
操作系统分配操作系统现成的时候十一 内核级别线程为依据进行执行的过程
内核级线程 中进行阻塞后 ，然后 多对多 模型进行 内核级线程  

阻塞的话  当 内核级县城全部都堵了才算堵 


现成状态跟运行 只关注  就绪  运行 阻塞 这三个状态 的内容 

进程是pcb   线程的控制块儿是 tcb  tcb是线程   
线程控制的内容 跟进程 是一样的 
线程的区域比较大 ，所以 需要保存的堆栈指针进行运行 学习内容  
![[Pasted image 20240902201818.png]]
注意这种结构的转换问题 


### 进程创建原语的执行过程 
涉及操作系统的 如何从现有的进程生成新的进程，包含以下步骤 
步骤一 系统调用的发起 
当程序 需要创建新进程  首先调用操作系统提供的进程创建系统调用  在类unix 中 常用的是fork()  window中是 createprocess ()
系统调用发起成功后 会将控制权交给操作系统内核系统 并且执行进程创建的具体操作 

步骤二  为 进程分配pcb
为新进程分配pcb 进程控制块儿 pcb  然后这个pcb 包含进程的标识符、状态、优先级、程序计数器、内存管理信息、文件描述符、其他上下文信息 

初始化进程的pcb 并且继承父进程 属性 （进程ID 、父进程ID、资源限制等）
同时为新进程分配唯一的PID 身份证号 

步骤三  分配复制地址空间 
为新进程分配地址空间。
在unix-like中  fork()；中 子进程 通常会继承父进程的地址空间，==子进程最开始内存布局与父进程相同 ，但是并没有实际物理内存复制==  而是通过写的时候复制 的机制  cow机制 ，当子进程或者父进程尝试修改数据的时候实际进行分配新的内存 

步骤四  资源复制或者初始化的步骤 

操作系统会将父进程资源，打开文件描述符等复制到新的进程中，并且初始化新进程的资源 
fork()；的系统调用中，儿子会继承父亲的 并且 这样可以让父子进程进行合理的通信 
此时 资源会进行重新分配的问题

步骤五 初始化子进程状态 
操作系统会将新进程状态转换为就绪态  
此时 新进程的PC 指向程序开始执行的地址 ，如果fork呗调用的话 ，pc可能与父进程相同 

步骤六 将新进程插入就绪队列中
新进程创建完成初始化后 会被插入到操作系统的就绪队列中去，并且 等待调度器的调度 
就绪队列 的进程都是准备好但是尚未被调度执行的 
此时 具体啥时候调度采用 操作系统的调度算法 比如 fcfs 先来先服务 的短作业优先等算法内容 

步骤七 返回新进程的PID 
fork调用中  父进程获取子进程的PID作为返回值，父进程可以管理子进程并且跟子进程进行交互内容，对于子进程而言，fork返回0 表示在子进程中执行的路径
步骤八 子进程执行 
操作系统的调度器选择执行新的进程时候 新进程会开始执行路径 
在fork调用中 子进程跟父进程从同一个执行点开始  通过返回值区分父进程子进程 并且做逻辑处理判断 

步骤9 清理 管理 
当进程创建失败的时候 操作系统需要清理工作，并且释放已经分配的资源 等 pcb 跟内存空间等问题 
同时管理新旧进程之间的关系 维护父子的关系  等  等  确保资源不浪费 

什么情况下会导致操作系统的新进程被创建？
1 用户启动了新的程序 
命令行或者图形化界面 （调用了fork()跟exec()这俩函数的内容 来创建一个新的进程  
双击应用程序图标 ：双击某个程序图标 能创建新进程 
2父进程创建子进程 
fork()系统调用  fork是linux系统中创建进程的语句  子进程会复制父进程的空间，并且开始独立执行 
fork后 父子进程可以i不能够i选哪个执行 ，子进程可以继续接管父进程的代码  
也可以用exec（）调用加载一个新的程序

3系统进程管理 
后台服务 守护进程  当系统启动后 由init系统或者服务管理器启动 用于执行系统管理任务 ，处理网络连接并且处理调度任务等功能 

系统启动，会创建多个关键进程维护系统正常运行 
4 任务调度跟自动化 
计划任务  cron 和脚本+批处理功能 
5响应外部事件  ：
网络请求  
信号处理 
6 并发+并行处理，
并行vs并发处理 在hpc环境中 某些app需要并行处理大量计算任务 应用多核初期器进行 分配 
多进程编程模型 
python 的multiprocessing 模块中 创建多个进程来并行处理任务 
7 虚拟化+容器化 
虚拟机 +容器化技术 docker kubernetes等 

第二章 调度的概念 
进行调度  
高级调度 vs 低级调度  
高级调度  从外存 调度到内存  进入一次 初入一次  进入引入 PCB
作业调度 的时候 是 妙想作业 相当于是从 外面预备役 转为正式役
低级调度  ： 进程调度 cpu调度   主要是 设计到 进程之间的设置的问题 ，取决于谁先谁后的问题等 
中级调度 ：主要是 挂起  就是 就绪态 挂起态等等 那种   中级调度的问题 

![[Pasted image 20240904172145.png]]
挂起状态   的 七状态模型   暂时调到外存等待的进程状态成为挂起状态，进入了挂起态

性能切  挂起态 （就绪挂起，阻塞挂起）
挂起状态相当于是计算机  那种休眠操作 ，就好比是计算机中的程序进行休眠的内容  

五状态模型--->七状态模型  

cpu利用率 指的是 cpu正在忙碌的时间占据总时间的占比   
这个 多道的并发的话 详见课后习题讲解学习  

系统吞吐量  ：多少道作业 /总共花多少时间  
10/100=0.1![[0131EF46.png]]  单位时间内完成的作业数量 

周转时间  ：作业从提交到完成 
指的是作业被提交到系统开始，到作业完成为止  这段的时间间隔  
包含三部分  ：作业  周转时间 =作业完成时间-作业的提交时间  
平均周转时间=各个作业的周转时间之和 /作业书 
更关心作业的单个作业的周转时间   
平均的时间   
带权的周转时间=作业周转时间/作业的实际运行的时间= （作业完成的时间-作业提交时间时间）/作业实际运行的时间  
平均带权周转时间 =各个作业的带权周转时间的和/作业数

等待时间：作业等待 cpu处理机的时间的和是多少  
作业有后备队列一谈之说 
平均等待时间 以及平均 带权等待时间的相关学习 


进程调度的时机：
1当前运行进程 主动放弃处理机 （cpu）进程正常终止 或者运行过程中发生异常而终止 进程主动请求阻塞 等待I/O 的国策会给你
2当前运行进程 被动放弃处理机： 分给进程时间片用完，更紧急的事情需要处理 I/O中断  更高优先级进程进入就绪队列

不能进行进程 ：1处理中断的过程中  与硬件
               2进程在操作系统中内核程序的临界区中国
               3 在原子操作过程中  原语不可中断 一气合成  中间不能进行进程切换 
问题 ：什么是 程序的临界区 什么是 内核程序 的临界区 
程序的临界区：指的是这个部分可以共享资源 供线程或者进程进行访问的操作跟行为 
操作系统的内核的程序的临界区指的是内核中某些需要被保护的代码段，这些代码段设计到对某些共享资源的访问，  
其有个机制 多个线程或者进程会同时访问这个代码段，我们不需要 这会造成数据的不对称性，这就可能导致一些列问题 ，这种问题出现在操作系统内核这关键区域是很要命的，所以给临界区是设置了一个机制 ，引入同步的机制 确保的时同一个时刻只有一个线程或者进程，能够执行临界区的代码 的行为 
而调度一般不可能发生在内核的临界区当中，但是可以发生在user也就是普通外围用户下的临界区中  
保护临界区方式：
1 禁用中断  确保不会有“第三者”插手进行打断 
2 锁机制：使用锁 来保证只有一个线程或者进程去进入临界区
3信号量：利用信号量机制来控制他们保障他们同步运行 （wait -singal）



进程调度方式 ：
非剥夺调度方式  ：非抢占式  方式 ：只允许进程主动的放弃出奇迹   早期批处理的系统 
剥夺调度方式 ：抢占方式 ：谁更紧急处理哪个任务 有vip的通道 
按照时间片轮转的  通过时钟中断的方式进行执行  分时 实时操作系统 


进程的切换 与过程部分 ：
狭义的进程调度跟切换  
1 下一进程调度  就绪队列中选中一个运行的进程 ，让出处理机 
进程调度过程 有两个:
1原来进程的各种数据的保存  
2 对新的进程进行数据恢复工作 PC  PCB 等等 PSW等等 各种数据寄存器处理现场信息等   
类比对游戏的存档恢复工作 

进程切换有代价的  不能太频繁切换不然等于没切换 

调度器、调度程序 
什么时间或处罚调度 呢 
1 创建新进程  2 进程退出 3 运行进程阻塞 4 I/O中断发生（可能唤醒某些阻塞进程）

非抢占的 ：运行进程阻塞 被阻塞 通道堵了没了     或者退出  无奈的exit 才能触发 
抢占的：每个时钟中断或者K个时钟中断触发调度程序进行工作 


内核级线程 调度的基本单位   >线程 


闲逛进程： idle  这个是 调度程序的备胎 ，闲逛 优先级最低  可以是0地址指令  占一个我那成的指令周期 （指令周期末位例行检查中断 ） 能耗变低等 


### 重点！调度算法 
FCFS 先来先服务  
SJF短作业优先 
HRRN 高响应比优先 
作业调度（高调度）VS进程调度（中调度）
是否会导致饿  

作业调度：哪个作业先进入后备队列   
进程调度 ：考虑的时那个先到到就绪队列 

FCFS 谁先来 先来先到  来做的
进程 到达后 有俩状态  要么在等待 要么在运行态 ，所以   当   又有计算  又有I/O操作的金层 
的等待时间 = 周转时间-运行时间（CPU运行的时间）-I/O设备服务的时间

短作业极其不利，还得等长作业进程的累赘 
不会导致饿 
2 SJF 短作业 优先   
最短的作业 /进程优先得到服务  进程要求服务时间最短导致的 
短作业  用于作业调度  进程调度 是 短进程优先算法 的进程  
默认非抢占式 
抢占式  最短剩余时间算法 
每次调度 事后是运行时间最短 的时候 并且 一道道 且运行时间最短 的作业/进程 
已到达 且运行时间最短的作业/进程进行 调度算法计算 服务

抢占式 的 是最短剩余时间优先算法 SRTN 这个 



HRRN 高响应比 优先  
响应比=(等待时间+要求服务的时间)/要求服务的时间 
非抢占式    只有当期那作业进程 主动放弃处理机的时候才需要调度 才需要想放弃相应 



时间片轮转算法  RR算法   
算法规则 轮流让哥哥进程执行时间爱你片  当进程 未在一个时间片执行完 就剥夺处理机
只有进程才有资格进行 

抢占式的算法  发出时钟中断 通知cpu时间片到了 
介入就绪队列 并且 如同数据结构里面 的 队列 隧道一样 每次只运行队头的调度 
队头的上处理机  结束 over  ！
重点是引入了队列的操作   头部进行 运行时间 
在就绪队列中 选择谁去上处理机的过程的话 是谁优先谁上处理机 的 
在就绪队列中 按照优先级组设置谁先回复 
根据优先级是否可以动态改编 分为 静态优先级跟动态优先级两种 
其中静态优先级是：创建进程的时候确定，其之后一直不变，
动态优先级是: 创建进程一个初始值 后面会根据情况动态的调整优先级 的类型 
系统进程优先级高于用户进程 
前台进程优先级噶欧阳后台进程 
擦欧洲哦i下哦他那个 更偏好 I/O进程  I/O繁忙进程   如果 尽早处理I/O繁忙行进程的话   可以让I/O尽可能投入工作 并且 效率更高 的效果 
相反的是 计算型的进程 CPU繁忙型进程 的问题 


如果是动态优先的时候 什么时候该调整进程的优先级呢 ？

折中算法 的规则    
### 多级反馈队列调度算法  ：
抢占式算法  的时候 如何应用规则呢 ？
![[Pasted image 20240904222859.png]]
金字塔领导分红模式 
高层分蛋糕，分到下面越分越少  ，当领导来了后，不管下属干啥必须打断让领导插队 

如果是时间片特别大的话就会转换为先来先服务的操作  


































