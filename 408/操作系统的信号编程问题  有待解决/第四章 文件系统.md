为什么要设立文件系统？
文件的一堆数据的集合 的体系 
同一个目录下不允许有重名的文件 ：
一个文件的属性 ：
文件名 创建文件的文件名 方便用户找到文件系统 并且建立标识符系统 
类型：指明文件的类型  type 的类型  
标识符 ：唯一的一个标识符  是相当于文件的身份证 且是唯一的 
位置 ：文件存放的路径 ，在外存中的地址 操作系统使用 ，但是对用户不可见  用户不知道但是操作系统晓得内容的

保护信息 ：文件保护的访问控制信息  它所分配的 所有者是谁 ，分配合理的权限给操作系统中
.txt是二进制跟字符流组成 且无结构文件 ，是一个数据库表的文件。
数据项是文件系统的基本单位 

文件（有结构文件  无结构文件 ）
目录2  用户可以自己创建一层加一层目录，各层目录存放相应的文件，并且一层一层目录合理有序组织起来
关于神奇的目录 文件组织形成的一个树  与文件夹系统  
创建文件功能 使用的是操作系统中的create  创建系统调用功能

读文件使用的操作系统中的read 的系统调用 目的是读取文件信息并输出到屏幕上 

保存是 写文件 进行的是write 的调用功能 
删除的时候 用的是delete 的系统调用功能 
打开 open调用 （读写前是需要用open文件调用功能）
关闭 close 调用 

文件如何放在外存中呢？
外存的存储单元承担了这个责任 
内存块  是 块儿内地址的位数 是十位数据

离散的磁盘块中 如何记录并分析 这里 的相关顺序呢 ?
文件共享 vs文件保护 功能 
文件逻辑结构 ：用户看来 是如何组织起来
物理结构 是站在操作系统的视角观察他是如何组织起来的 


无结构 ：流式文件 ：无明显结构特性 可以进行讨论进行 

有结构  ：有关键字ID  数据信息  记录的文件信息 
 记录长度 是 定长记录或者可变长记录两种信息 来源 
 文件大小是否可变  ，这个为可变长记录  就是 内容信息可以进行伸缩问题


穿结构 链式存储 顺序存储  跟  数据结构 
链式存储  =  无法随机存取   必须从头摸到尾巴 
顺序存储=可变长 无法实现随机存取 只能从第一个记录依次往后找 可变长  无法分配空间，大了容易浪费 少了不够，又是顺序存储 ，不是指针 相当于牵一而发动全身 

顺序文件 是物理上的顺序文件  


索引 ：引入索引表机制 进行运行   索引号 长度 指针 一共是他的选爱过
然后引入一个索引白哦中的指针 瞎几把只 ，指到针对的逻辑文件的地方
对记录进行分组 ，并且每个分组 对应的  mysql数据库一样  
进行索引表是检索机制    对每一个部分进行拆解   mysql中的外键 跟内键机制一样 


多级二叉树  数据结构里面多叉树 的机制
多级索引顺序文件 ：
多级索引顺序文件 ：内外键机制 
![[Pasted image 20240919093735.png]]
文件目录结构 进行的 问题 ：
 1 文件控制块  PCB  文件目录的关键数据结构   文件控制块儿的 指示  
 2 文件目录 ：1 单级 2两级 3 多级 4无环图目录结构
 目录就好比是个表格  揭示了文件名 跟具体的文件物理的地址信息  方便与辨认 
 会查询根目录的文件，找到对应的目录项 并且 根据存储的位置 ，来展示具体的信息细节
 物理位置 对应的是对应的 外存的物理位置 
 FCB核心是 对应文件名 跟物理地址（文件在外存存放的地址的信息）的映射  这个是重点 
FCB 是早期的文件目录项 针对于现代产品 的话 他们如下所示：
1 Inode 索引节点 ： 在类Unix 文件中  Inode 是更灵活的文件元数据 
MFT ：NTFS 系统中  他是管理文件元数据的信息  相对与FCB 更加安全跟灵活

单级目录表 ：一层 目录表 
多级类似与 一个多叉树的模式
多级中 
第一级  是主文件目录  MFD   用户文件目录 UFD  
山一样的映射  这个允许不同的用户的文件重名
两级目录 允许不同用户重名 ，并且 实现访问限制 的功能并且检查是否匹配的操作的行为逻辑信息
从根目录出发的路径称为绝对路径  
一层一层调用  简称为抽丝剥茧的过程  

当前目录的路径是相对路径的信息 
树形目录基础 =有向无环图  ：不同的文件名 指向同一个文件ps ：无法进行进行逐层映射的问题 

对每个文件设置为一个共享计数器  来表示这个文件有多少个目录进行使用并且进行共享文件 
索引文件 FCB的改进  ：
文件名直接 进行索引获取减少中间的经过的中转站 
当文件名匹配的时候在进行搜索信息 放入索引节点进行索引搜索，文件名的描述信息放到里面来进行操作 
直接给一个索引节点的指针 
每次查询20次这个目录进行所搜 学习，大大提升文件的检索的速度恩替 
外存中的节点 磁盘索引节点，放入内存中的内存索引节点信息 的相关体系系统 

文件物理结构  文件分配方式 数据应该如何存放在外存中。。。。
连续分配 链接分配 
操作系统中 磁盘块大小=内存快=页面大小相同 这样交换数据会方便很多 不至于产生很多误差跟出入
文件 的地址 （逻辑块儿 ，块儿内地址 ）

文件分配空间是 以块儿为单位  一个块儿的大小可能是有很多个行  
用户操作的时候 是 用块儿为单位进行操作系   相当于从物理到逻辑的映射 

连续分配 ：站另一组的连续的块儿进行组成 
记录存放的起始的块儿号跟长度问题 ：
物理块儿号=起始+逻辑块儿号 
连续分配访问支持 顺序访问   从头按顺序访问，随机访问的是直接访问也就是随机选择性访问

磁盘移动磁道的位置距离考虑，这个需要考虑在内。
连续分配 从头到尾飞速读取速度最快
连续分配的话 迁移耗费较大开销以及问题 
利用率低 并且产生难以利用的磁盘碎片 ，在磁盘占用一组连续的块儿 ，缺点是不支持直接访问
链接分配 ： 瞎几把指
利用指针链接起来 
隐式链接：记录了文件的其实块儿号跟结束块儿号 并且进行连接读取 内容 即可
链式本质是数据结构的链条   链服务 
 数据结构 链式存储跟顺序存储的优缺点 的问题 

显示链接（硬链接）：用于链接文件个物理块儿指针显示存放在一张表中 ，文件分配表  FAT
其中 实际上是把物理数据块儿与不同的文件名绑定，并且所有的硬链接指向的均为同一个文件 的内容 
物理连续存储 且每个表示的相同 
查询FAT表的时候直接一步定位信息内容即可。
特性：多个文件名可能指向同一个数据块儿也就是同一个物理存储我盒子 
修改同步：一个修改其他跟随更新 因为他们指向的时同一个数据保持一致
当都被删除后才会 删除
只能链接文件 ：同c语言一样 只能到数据 不能到指针 
目录=指针  文件=地址存放的数据
应用FAT读取表的过程不需要磁盘的操作行为 


隐式链接VS显示连接 ：
隐式链接（软链接）：编译的时候确定了所需的外部库， 程序启动的时候会自动加载这些库文件
window下 通常为动态链接库 dll文件 
隐式链接不指向符号内容 而是直接指向文件路径 如文件的快捷方式等 
更换箭头 指向的额箭头  如果文件本身被修改 或者交换位置的话，就可能会导致链条找不到对应的目录内容从而形成死循环系统 
默认是隐式链接的内容 

文件物理结构 是 文件分配的方式 

页与物理页之间的映射关系  索引表为索引块儿  ，磁盘快的时数据块儿 
通过建立索引报的形式来连接物理块儿号跟逻辑块儿号 
索引表中的块儿号是独立的 
索引分配支持随机访问 
当一个很大的文件子啊一个 索引表所在的存不下 
1 链接方案： 一个索引块儿人放不下  咋办  
一个进行拆分  并且 将每个部分 进行指向下一个索引块儿的指针信息即可

索引块儿 的话 如果想找到第二个 索引块儿人的话  必须得从第一个表单的256 才可以  不行  

建立多级索引表进行：
类似与树的模式去进行拆解并且建立
顶级索引表的采用的索引快号是多少 
各层索引表的大小不能超过一个磁盘块  文件最大长度因此而来
  在查询的目标数据块儿的时候是需要访问3次的磁盘I/O 的功能
  记得乘以 计算磁盘块大小 
  如果采用k层索引结构 的话 访问一个 数据需要k+1次度盘操作
  在计算最大文件长度的时候 记得区分直接地址跟 简介地址的区别 
  小文件的索引是一种小文件访问的方式。
  读取顶层一次+每层读入加一次的形容内容方式 


逻辑结构 VS物理结构 
针对于用户而言 的话，逻辑结构的启用至关重要，所以 针对物理结构而言 的话 是针对逻辑地址而言的 


 
套娃机制 ！！！！嵌套机制！
文件存储空间的管理 的问题 
以及几种管理方法：
文件存储的空间管理问题：
1 磁盘分区  的存储空间的划分以及初始化 逻辑卷 逻辑盘当中的信息 内容 
FCB 主要目录存放文件的目录信息 磁盘存储空间管理的信息  
文件卷由多个物理磁盘组成并连接的 
采用的是套娃的机制 进行分解运行并判断 

第一个方法：空闲表法：
主要采用的是连续分配的空间 因为此时空闲盘的块儿数的
采用的是套娃机制  比如 针对 首次适应算法 在那片区域进行这种算呢 
回收的时候注意表项的合并的问题 ，并且进行删除某文件并且进行系统回收的问题 占用 并且处理的问题 


空闲链表法 ：
空闲盘块儿链：用盘块儿作为一条空闲链

空闲盘区链：盘区为单位一个空闲链

数据结构中的链表结构 的系统 挨个串起来排排站 ，离散分配物理结构 
可以次啊用 首次适应 最佳适应等哪些算法机制进行 

位视图： 0表示空闲 1表示分配 行列号代表矩阵机制问题 
![[Pasted image 20240919225324.png]]
行列号 推理到 转换公式 
注意细节问题 ！
 
盘快号为A ，A/n=i(字号)。。。。P（位号）
ni+P位号

成组链接法 UNIX系统是采用的这种方法进行管理模型
设置超级块儿 （记录了下一个模块的数量跟空闲块儿号）
块儿号  
最后一个盘块儿人数 的分组的是 少一个 
每一个盘亏树结构  套娃  就是类似与多层索引机构一样 还是套娃 


文件基本操作  
创建文件  ：
create' 文件的系统调用功能，提供系统主要参数 
1 所需外存的空间大小  
2 文件存放的路径是。。。
3文件名是。。。

（1）create   外存所需的空间大小的内容 

（2）根据存放的路径信息 找到对应的目录文件  创建改文件对应的目录项，包含了文件名 外存中存放的文件信息 

删除：delete：
根据文件 找到相应的目录文件 
2 找到外存存放位置并且回收文件占用的磁盘块儿
3 删除文件目录对应的目录项内容 

open ：进程自己打开文件内容的表 
还有系统 本身的打开文件表  指明那个文件个进程的表单 
（打开计数器 指的是被几个进程打开了 的呢绒 ）

read 的文件 read系统调用 read 的系统调用 完成写操作 打开文件指明打开文件表中的索引号的时候 指明读了多少个数据信息 
指明是哪个文件 提供问价你在打开文件表中的索引号即可，需要指明写出多少数据信息  等 等 内容

写明指定大小的数据并且 规定了一个写指针去执行相关操作以及内容 
他会插入一个打开文件表中  文件描述符=打开文件表的索引号 的内容 


文件共享 ：
索引节点 硬链接 
符号链接 软链接  

多个用户共享一个  只要一个用户互相影响的联系内容
索引节点 抓出来一个 文件 然后 目录瘦身 ，移入索引节点指针  来指向文件真实的物理地址的内容体系
硬链接的时候 由于指针 连接到位置  如果应删除的话就 会导致指针指向的东西缺失从未导致报错 防止指针悬空的事情 


基于符号链的共享方式 （软链接）

不是直接指向 而是有中间人  创立一个指向文件来 作为标志牌，然后索引的指向的信息指向的为真实目录的地址信息内容 



文件保护 ：
口令保护
设置一个口令（密码) 正确的口令存放的时FCB的 地方   ，口令
加密保护 
使用某个密码进行加密 密码算法 比如哈希 密码加密算法，sha-1
 等等 
 密码学 ！  
访问控制    每一个FCB  增加一个ACL 中的表 访问控制表  记录了各个用户中 可以对文件执行哪些操作的行为 逻辑

可以人为创建账户来达到任何临时访客内容信息表单项目

文件系统的层次结构问题：
用户接口：上层提供简单的功能的接口功能

从上到下 依次 是 
1 用户接口
向上层提供的功能接口的信息内容 执行read  write  open 等close 的系统调用内容工鞥



2 文件目录系统
通过文件路径来访问文件的 需要根据哦一个用户给出的 we你阿基诺路径找到对应的FCB或索引节点，并且根目录 ，目录相关管理工作在本层挖槽呢灰姑娘，等 

3 存取控制模块
文件保护

4 逻辑文件系统与文件信息缓冲
记录号转还能对应的逻辑地址  记录号-->逻辑地址转变
5物理文件系统 
逻辑地址变为物理地址的转变
![[Pasted image 20240920111403.png]]

### 文件内系统布局 ：
逻辑格式化   ：线分为扇区可能会遇到惠山区  他会有备用扇区进行准备操作的行为 逻辑
物理格式化 ：对电脑进行磁盘分区，他会哟mbr 不分 主引导记录 以及 CDE三个磁盘文件的内容，会跟空闲空间管理的位视图的结构   
![[Pasted image 20240920111939.png]]
注意各部分的内容以及名称 
连续存放在I节点区的内容  索引节点是连续的存放内容来获取具体信息 

逻辑格式化灰色的部分 是一些自带的主引导区域 的部分  mbr的引导块儿 的作用 是逻辑格式化后他就会出现了一个 

### 内存：用户区  内核区
内核区：目录的缓存  系统打开的文件表   进程打开的文件表内容 
 open 系统调用打开文件的背后 的过程 ：
第一步：用户态-->内核态 
open 空间系统的调用 首先是 触发 user-->kernel转换 处理文件系统调用的接口 
2参数解析 
传递的数据如下：
```
int open(cinst char *pathname,int flags,mode_t mode);

```
解析如下：
文件路径 panthname ：告诉他们文件在哪
打开文件方式 flags:有如下几种 
只读 O_RDONLY 读写O_RDWR  追加 O_APPEND 创建O_CREAT
mode:使用O_CREATE 创建文件，mode 参数指定新文件权限位 rwww 101001 二进制表示的位置 3个为一组

进入内核态的时候首先验证的标志 ！ 提权的重要思维逻辑
路径解析：
区分绝对路径跟相对路径
1针对路径首先进行路径遍历 ，同时找到目录后验证用户进程是否有权限
2符号链接解析：os先按照符号链接中转站进一步找到下一步该走的位置上 
3文件系统锁定 ：并发的环境下 保障单一占用 只能我占据别人不许站！


### 权限验证：
定位到文件后 ，内核检查用户进程是否有权限执行  
比如 ：
1 读 O_RDONLY :
   验证用户对该权限是否有读的权限信息
2 写 O_WRONLY  / O_RDWR：
   验证用户是否具有写权限
3 执行权限
文件类型的权限检查功能
4 父目录权限  检查父目录手法会有读写 
比较方式 是用 UID  跟GID 对文件权限位比较书写内功 

### 文件系统操作流程：
ext4 NTFS NFS 等  文件系统 差不
OPEN流程 ：
1 用户态调用open函数 
`fd=open("file.txt",O_RDONLY);
2用户态切换到内核态 
open触发函数调用，os将控制权从user 切换为root 
传入参数被复制到内核空间处理
3参数检查跟解析
路径检查：检查pathname内容保持路径合法 
标志检查：flag检查  确保合法组合 O_RDONLY  O_WRONLY  O_RDWR等相对等 
保证合法组合
模式检查：使用了O_CREAT标志检查传入模式  mode
4路径解析：
目录便利+符号链接解析
5权限检查  如果用户使用了`O_CREAT`创建新文件，检查父文件是否有读写权限
6文件系统操作:
打开已有文件：打开文件存在且权限允许，系统在文件中查找文件节点`inode`
创建新文件节点：
设置标志：传入标志 `O_APPEND 、O_TRUNC`相应的设置打开方式
7分配文件描述符
查找空闲文件描述符：内核进程分配空闲文件描述符 内核对象产生关联
更新文件表信息
引用计数
8返回文件描述符
文件成功打开，open()调用返回分配文件描述符
`O_CREAT`open返回-1 设置error表示错误原因
9后续 
打开文件后继续进行下面操作


### 虚拟文件系统或者虚拟文件系统挂安装 
啮合文件系统部分  
VFS：计算机内部  UFS  NTFS  FAT  的文件系统 
不同的定义的 参数不同 导致了具体表达方式有差异 
虚拟文件系统的目的是 为了让操作系统兼容不同虚拟的文件系统，将不同的信号统一成一种类型的型号进行输出即可 
特点：上层用户提供统一标准的系统调用接口，屏蔽底层具体文件系统的具体实现的差异化问题

VFS的几大特点 ：
特点一  ：每打开一个文件 VFS主存中新建一个vnode 统一的数据结构表示文件  无论该文件存储在哪个文件系统中 去的
特点二  ：针对上层文件 的话  是提供了一个统一的函数模型 这样不同的文件系统可以统一用一类命令来进行掌控（统一数据结构  保证他们的文件扩展名等相同的机制）
特点三   : 底层兼容机制 ，要求下层文件系统实现某些规定的函数的工鞥 ，必须让下层 的文件系统也满足这种VFS的要求

vnode ： 文件名+文件大小+创建者+文件格式+函数功能的指针  
只存在于主存中
inode  主存外存都用

VNODE： 是VFS的表示文件对象抽象数据结构 是抽象层  
1 Vnode 是vfs中表示文件对象的抽象数据结构 属于抽象层，适用不用的底层文件系统
2 vonde 是vfs的抽象 ，给不同类型的文爱你系统提供统一的接口层次
3 vnode 是封装了文件曹组

INODE： 类unix 的系统  如同pid 的身份号一样  一个文件有独一无二的INODE
 且 INODE 不储存文件名  inode 通过indoe 号来标识文件信息 ，
 2层次 ：
 vonde 是VFS层  且 他是将所有不同的文件统一成一个的对象
 inode是文件系统层，负责存储元数据  查找文件的实际位置 等大小内容
 3数据结构内容 
 vnode：
 文件系统类型  EXT4NFS等
 文件操作函数指针 ：读写等
 指向文件的元数据结构指针  指向inode的指针 类型数据
指向底层文件系统 的虚拟化结构 并不会存储具体的文件信息在上面


 vnode 通吃  而inode只适用于他自己的独特的文件系统 
ps  ：函数功能指针 :
特性：呈上启下 自己 vnode 的指针  

文件系统的挂载 
1vfs注册新挂载的文凯你系统  内存中的挂载表 包含信息 文件系统的类型跟容量大小等 等
新挂载的 必须想里面添加新的函数地址表 
新文件系统的挂载点更为关键 













