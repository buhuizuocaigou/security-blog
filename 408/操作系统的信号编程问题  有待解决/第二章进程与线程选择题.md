![[Pasted image 20240902204935.png]]
选项解释  
选项 A：
协处理器执行程序指的是 计算任务或者指令集，他是系统中协处理器做的 
不是主处理器  ，主处理器指的是（CPU中央处理器直接执行）
协处理器是一个专门化的处理器，并且通常设定用于执行特定的类型的任务 
由主处理器  设计执行特定类型的任务 减轻主处理器负担 提升性能
协处理器类型：
1 FPU 浮点运算 协处理器 
2GPU 专门处理图形渲染的 现代的GPU 偶然会处理并行计算的任务
3 数字信号处理器 DSP 处理数字信号，音频视频的信号的处理  
4加密的初期里

协处理器用于帮助 主处理器分担任务 的一个东西 
C  ： 进程映像主要的部件是PCB 跟 程序+数据的结合体是他们的组成部分 

![[Pasted image 20240902211107.png]]
选项A跟选项B :
CPU现场指的是 ：线程在运行的时候所需要的一组寄存器的值，包括pc ，psw，通用寄存器 跟栈指针等，线程切换的时候，os会保存当前的线程的cpu现场 进行存档 并且回复下一个线程的cpu现场，并且保证线程的正确执行 

B 线程没有自己的独立地址空间，共享其所属进程的空间 
线程是进程中一个执行路径或者执行单元，一个进程包含多个线程，并且他们共享该进程的地址空间资源 ，每个线程拥有自己的栈跟寄存器 可以存储局部变量跟调用信息 

目的是提高自己的性能并且追求共享空间 的运行方式 

![[Pasted image 20240902211610.png]]
对于 D  跟A 
并发进程 可鞥因为等待资源等被抢占cpu进而 暂停 其生命周期并不是连续的，并且 执行速度会影响进程，之家能执行顺序跟内存冲突的问题，导致不同的操作结果，
一定想要 ：并发进程之间会造成制约能力的问题 
![[Pasted image 20240902212232.png]]
选C
 解析  ：并发进程的相对速度有进程的调度策略有关，并且 进程调度策略决定了那些进程可以获得处理机，并且获得处理机时间的长短问题，并影响进程的创建的效率 

详见笔记 进程创建源语的执行过程 
![[Pasted image 20240903165316.png]]线索点 ：1 单处理器系统  2同时存在10个进程 
可能出现的情况：
1 10个全走不了 卡住了 都处于阻塞态 
2 1个占用cpu 剩下9个准备就绪 
不可能出现的情况 ：
10个都处于就绪态
![[Pasted image 20240903165536.png]]设备打印机交互跟资源管理类型的题目
隐藏线索点：打印机 （独占资源）只能老子独占 别人不许跟我抢 
打印机由进程请求跟释放，针对独占资源而言 ，当一个进程请求打印机的时候 如果一个打印机已经被其他的进程占用，那么请求该打印机会进入wait状态 等待队列状态 ，直到打印机被释放 等待队列中的下一个进程会被唤醒 ，从等待--->就绪状态 准备继续执行 

选项分析 A：
自身进程指的是 当前正在占用并且释放打印机的进程，当释放打印机后，自身进程可能会执行其他的任务，他状态可能会发生变化，进程在释放打印机后可能会从阻塞态变为 就绪态 或者从I/O态变为执行态
一般下 我释放这个设备不会导致进程发生打的改变，他会继续 等待对应资源 
选项分析B：
输入输出进程 指的是所有进行I/O操作 的进程，但是题目中没有明确提到是哪个io进程  抓住核心店 打印机是独占资源 ，跟打印机无关的 不会受到任何印象，只有等待这台打印机的进程 才会收到影响

选项分析C ：
另一个等待打印机的进程 :
当某个资源被释放的时候，最先进入等待队列的进程会被唤醒，这个唤醒的改变导致了进程状态的改变，选项反应了操作系统的行为 

选项分析D ：
所有等待的打印机的进程不会同时改变状态，==只有最先排到队列的第一个的进程会被唤醒 其他仍处在阻塞状态直到被唤醒为止 ==
![[Pasted image 20240903171116.png]]
对于发起I/O请求跟 I/O操作完成的详细分析如下：
1 发起I/O请求：
当一个进程发起I/O请求时候需要等待外部设备相应，I/O操作的速度比CPU慢很多 
进程在等待I/O完成的时候 无法继续执行 。所以会从运行态变为阻塞态，此时进程不在占用cpu ，并且等待I/O操作的结果
2 I/O操作完成:
一旦I/O完成后外部设备通知操作系统 并且 通过中断，操作系统会将之前被阻塞的进程 从阻塞转为就绪，
进入就绪的进程表示已经准备好再次执行 等待cpu调度 
区分为两个  一个是在完成中，。。。另一个是已经完成 后 
在完成中  

选项A ： 时间片用完后被调度器中断调度的时候 ，一个进程运行完一段时间后，时间片用完，此时调度器
进程从运行转入 就绪 然后调度下一个  
重点在于 重点1！！！！！！！！！  这是在操作系统完成中的状态变化 
不涉及运行态到就绪态变化

选项B ：当进程发起状态变化的时候  从就绪态变为运行态  
选项D： I/O的完成后最典型变化 是 阻塞 一旦I/O操作完成的时候 从阻塞态切换为就绪态 并且再次获取cpu的执行 
选项D ： 正确      

![[Pasted image 20240906101610.png]]
三个等级调度的不同职责 
1 高级调度：
决定那些作业进入到合适的系统进程中 
功能：负责从作业池子选择 作业往里面装在  形成进程 
主要是 入围赛，选择谁以及那个进程可以入围 
2中级调度 ：合理分配内存资源 ，将突入入围赛的人 合理分配资源给他们
3初级调度：决定哪个进程获取cpu的执行权
负责就绪队列进程调度，选择分配cpu执行，并且保障高响应化进行

![[Pasted image 20240906102004.png]]
这里面最突出的就是 互斥性 
对于互斥性而言 ：1调度的核心目标是资源的分配不是进程的同步
                 2互斥性是同步机制决定的并且解决的  并且依赖于同步源语 ，这个互斥性的是根据进程之间的同步 消息同步处理解决的 而不是单纯的进程谁来获取cpu来决定的
                 3调度算法不负责资源使用顺序：
                 决定哪个进程或线程进入就绪状态获取cpu时间，是由进程同步机制处理的
                 4调度为全局层面的问题，互斥 的是局部资源保护的问题 
    调度的算法核心目标是分配cpu时间
    而互斥 是解决进程同步跟资源管理机制的问题来决定的
    ![[Pasted image 20240906102324.png]]
解决问题的核心在于：不管你是谁，也就是说不管解决 进程 或者用户是谁 都能按照时间片这个规则做统一的分配 获得的时间片是一样的而且人人都有份 的那种

![[Pasted image 20240906102914.png]]
关于进程上下文的定义 ：
说白了就是 游戏存档保存的时候存放的当前人物血量 等 以及一切信息   
当 我随时读取存档的时候，当前游戏所处的状态能快速的被找到 的一种状态模型
放在电脑内主要有以下信息：
1 用户堆栈 ：函数调用本地变量，返回地址等信息，用户切换的时候，堆栈保存进程执行中调用的函数，局部变量等 
2 PCB 进程控制信息：包含进程ID、优先级 装阿嚏等  
3进程的现场信息  PC 通用寄存器  SP 等等  
中断向量表 IVT 处理器定位中断处理程序接口的数据结构  
不属于进程上下文的原因：
中断向量表 就是一个无情的提供中断发生后该执行那个该怎么处理的一个表格 
这个不会保存现场任何信息，他其实就是个无情的“指路牌”
所以不属于进程上下文 

![[Pasted image 20240906104214.png]]
cpu忙碌 的  也就是只要保证cpu是忙碌的作业就可 所以采用的是先来先服务的机制算法进行调度操作 真的么？
![[Pasted image 20240906104337.png]]
实时系统的进程调度 核心在于当外界来了一个 vvip事件的时候能得到及时的处理 。。
![[Pasted image 20240906104922.png]]
其实本质上是选择 谁是主动触发进程调度 而不是被动触发的那一个 
A时间片用完后 意为当前进程不能再继续运行  必须选择其他进程调度继续运行
B：出错后直接触发  被动技能 
C运行进程等待某时间发生 进入阻塞装阿嚏 被动触发 
D 当新进程被创建的时候，操作系统会将他放在就绪队列中，就绪态指的是被执行的进程，进程放入后 不会直接触发 调度，当当前时间片被用完后 ，才有可能被选中触发调度机制 并且执行 内容 
执行调度机制工作 
![[Pasted image 20240908083141.png]]
响应比=（等待时间+要求服务的时间）/要求服务的时间
总共算上等待时间干了多久 跟他服务时间的性价比
老板来洗脚，老板一天能赚3000元 ，然后从等待座位到结束洗脚回去占他服务时间的比例 来判断这个洗脚的时间性价比是否亏损 

![[Pasted image 20240908084424.png]]
出题人的恶意  时间片轮转是完全依赖于时间盘  而绝对可抢占指的是依赖时间片的行为 
![[Pasted image 20240908084619.png]]
(1)周转时间=完成时间-到达时间= 
比如  P2是16完成的  所以是16-0.4
![[Pasted image 20240908095849.png]]
重点问题！

![[Pasted image 20240908100242.png]]
系统开销指的是 需要切换cpu比较少次数的那个 
首先排除 B 多级反馈队列  频繁切换cpu 进行 调度
对于先来先服务 直接 谁先来把这个服务做到死再换，不用像时间片响应比一样会重复使用某个进程。导致消耗CPU 较少

![[Pasted image 20240908100453.png]]
饥饿现象产生是 由于在某种规则下 ，进程A可能会永远得不到处理 永久被放回去
![[Pasted image 20240908101435.png]]
![[Pasted image 20240908103010.png]
I/O设备跟 计算的CPU之间的一次调度问题 ，一次资源竞争度的问题 
资源相互竞争计算所需的资源的值跟
在同一时刻 只能有一个任务使用计算 这个功能 
同一时刻 只能有一个任务使用是I/O工鞥
所以在同一个时刻 计算跟I/O功能可以并行运行 兼顾
互斥锁 先V 后P 先释放后再上锁 的方式 进行 
生产者消费者问题 解决 


抽烟者与供应者  的问题
三个抽烟者 跟一个供应者的进程 
同步的话 是前V 后P   必须发生在后面的三个吸烟者都需要轮流吸烟  
设置I  让I%3  来保证让他们 循环去做吸烟的事情 这样就可以让他们吸烟了

读者---写者问题 
并发运行 并且共享一个文件 ，读者 不听的毒  写者不停的写 
 读--------框架--------写 
注意 读 进程同时读是可以允许 ，但是 写只能仅有一个是写的操作  
 写进程进行写的时候 其他的进程是无法访问这个文件的  
 当 任意写者进程2  进行写入 的数据 部分
 读写进程的核心 是 写者进程必须 
 读跟读可以同时访问  
 写跟写 的话 只能互斥的访问共享文件，通过这个进行访问文件，如如恶化设置信号量并且进行共享文件互斥访问 ，写是单独处理
 必须设置count 进程来记录 到底有几个读进程在访问这个文件的过程  
注意 只有第一个读进程 才会对文件进行加锁执行的是p操作 ，只要有一个大于0的话  其他的不用加锁  
第一个读的进程负责加锁，其他的是解锁   读完了就进行解锁 

导致这些问题的原因子啊与 对count的变量以及检查 赋值无法一气合成的问题 ，可以让很多读进程互斥访问这些变量 并且保证他们的互斥访问 进行  
读进程更高的优先权  
  不止要对 读者 进行限制 同时还得对写者进行限制  
  必须对双方进行限制处理的问题 过程  
  读写 相对公平的先来先服务 的原则 
  关于死锁的问题 ：
  信号量机制保证临界资源互斥访问 不能避免完全死锁 

![[Pasted image 20240914203132.png]]
进程等待的优先级 不能破坏死锁的必要条件  
即使拥有高优先级或者低优先级进程 他梦管不了或者战友了不可抢占的资源 ，形成了环路等待 ，那么死锁仍可能发生，优先级并不会影响资源发生的必要条件 
优先级的多少并不会影响到资源分配 
![[Pasted image 20240914203522.png]]
核心点一次分配所有资源方法是当进程需要资源时候 一次性提出所有的请求 ，并且若IQ给你球所有资源均满足的话则分配  注意是请求 请求 ！！！不是资源本身 ，也就是 提出的是请求而不是资源本身的值

![[Pasted image 20240914203829.png]]
避免死锁  ： 核心是 防止系统进入不安全状态 就可以让他不产生死锁  不产生死锁 
而C 选项是破坏死锁的四个必要条件之一 指的是死锁的预防 而不是避免 

不剥夺条件指的是 进程一旦占有是我的就不可以被其他的进程抢走的过程 
![[Pasted image 20240914204200.png]]
资源的有序分配 破坏了死锁的循环等待的条件 的情况 
循环等待 的核心是 A等b放 b等c放 c等a放 构成死循环 所以相当于破坏资源有序分配 机制

![[Pasted image 20240914204329.png]]
什么是资源静态分配策略？
进程![[Pasted image 20240914204329.png]]开始前 就一次性处理好，而不是进入进程后边进入边处理的静态分配策略 属于系统改的出现死锁的手段之一  
![[Pasted image 20240914215955.png]]
死锁不采用的方法是 ：从非死锁进程中抢夺资源 ：为什么呢？答：因为死锁的核心是资源分配抢占问题，而解决的方法不是从非死锁的地方抢 这样只会改善一个资源，如果需要抢夺的话，必须要从死锁的进程处抢夺资源内容 这样可以解开他们的死循环的扣字 
![[Pasted image 20240914220343.png]]
答案是 B  资源剥夺发的核心是 打破请求与保持机制 
而 B 中的撤销进程的本质 是打破请求跟保持功能来达到破解死锁的目的

![[Pasted image 20240914220516.png]]
在资源分配充分的情况下是绝对不可能发生死锁机制的 
矩形框表示的是资源 而其中圆点表示的是资源的数目多少
圆圈节点表示进程  

![[Pasted image 20240914221204.png]]
互斥资源中 无法破坏的是互斥资源 
原因是 ：互斥资源中 ：指的是某些资源同一时间只可以被一个今晨占用，不
本周内智商是排他性的，互斥性指的是自愿本身只能有一恶搞资源给cpu ，而不是共享式的访问，互斥条件是无法破坏的 

![[Pasted image 20240914221535.png]]
这条是 分析 资源分配策略 是 导致饥饿现象的发生  
相当于是 某个资源一直让出自己所拥有的资源 把它分配给比尔那，然后自己一直得不到对应的资源从而造成的这种现象的产生

颠簸：颠簸指的是计算机系统频繁的进行资源切换如内存的调入调出 导致大量的自己算资源被消耗在处理这种切换的操作上，而实际的有用的动作很少 在虚拟内存的系统中 进程频繁请求内存也导致频繁页面转换，不停的频繁地转换导致了抖动本身的发生

回退：检测到某个错误或者故障的时候来进行的回退失误的操作，在思索检测中  回退 就是 玩偶习中的回档操作 

![[Pasted image 20240914223211.png]]
相当于是 得让他有一个单独的资源独立存在   是这样的么 

