内存的基础知识 框架 
内存 的定义 ：内存的定义 内存可以存放数据的位置 
每个数据跟地址进行编号  各种存储单元的集合 他是各种存储单元的集合系统
如果按照字节编址 ： 按照1个字节 1b 8个2进制为
16位计算机 按照字的话  是 占用16个bit位置的数据
2的10 是1kb  2的20次方 是1m 的  
等等  。。  题目中会告知 内存大小是多少 并且确定的地址长度 多好  多少个2进制存储单元 

指令工作原理 寄存器中断指令的工作原理   
指令 = op +内存的地址位  
基于地址找到那些数据信息 进行数据地址编程   机器指令 告诉cpu来 连续存放地址 物理地址 
逻辑地址 ：相对于某个基址的地址 
物理地址：物理地址指的是实际存在的地址信息 

如何把逻辑地址转换为物理地址  三种解决地址转换的问题“
1绝对装入 运行前装入  （编译器来完成解决的 ）
编译的时候 在放入之前就已经晓得在那个位置上，装入模块的地址 将数据装入内存 。。。。
单道程序的方式  。

2可冲定位装入 ：静态重定位 （多道批处理系统）
地址是从零开始的逻辑地址 模块 ，模块装入内存中的起始地址是100 
已知 起始的地址模块是100还是 啥  
必须分配全部的内存空间大小，静态重定位 是具体地址无法中间修改 并且数据无法修改  

3 现在是动态重定位  ：
动态运行的时候装入  
使用的时候是逻辑地址   --------重定位寄存器 （专门存放内存中的起始地址 放到起始位置的地址上进行运行的 ）
4系统投入部分代码即可开始运行  
动态申请分配内存  可以向用户提供一个很大的运行空间 进行  写到程序运行方向 
动态ld dll文件以及链接环节 ，这个是进程动态的运行的环节 

三种连接的方式 ：
1静态链接 ：运行前就将他们链接起来
2装入时候动态链接：各大目标模块装入内存的时候，边装入边链接
运行的时候动态链接 ：边运行边链接 

内存空间的分配跟回收 
1 os如何分配数据往操作系统内部 
2操作系统负责分配跟回收代码  
虚拟性 的体现 是 虚拟空间  对内存的空间进行扩充操作 
地址重定位 ，需要操作系统负责 保证程序员写程序不需要关注物理内存实际情况


内存保护：
1 一一对应  进程只能访问自己的内存空间 
方式 是 cpu中的上下限急促你去的设置
2 采用重定位寄存器 （基址寄存器）  重定位 寄存器+界地址寄存器 
3越界异常  相加判断是否越界 
进程内存影响  
代码如下：
```
const int b=2; //const 这个代表了只读代码区域的内存地址，他是一个常变量，并且他是一个程序志林且是只读数据流，他执行后存放在只读代码/数据区域进行 执行  
```
![[Pasted image 20240915140145.png]]进程运行的时候 可以确定浙西紫色区域的只读区域的 代码 变量是多少
并且是全局静态变量，
![[Pasted image 20240915140237.png]]
heap 堆溢出  堆 对应着malloc的这一方面的函数区域有多大 数据区域有多大 
共享库的存储映射区  ： 库函数 以及各种函数的代码 
宏定义中不专门分配存储空间，当预编译的阶段 会将代码 的x替换为1024的话 
const 的 ![[Pasted image 20240915140600.png]]
左侧中共享库的存储映射区 ：共享库(.dll或者.so文件)映射到多个进程的虚拟内存空间中，并且让这些进程可以共享存储库的代码跟数据，占用每个进程单独加载一个脚本

通过内存映射的机制存在，核心思想 文件内容直接映射直接映射到虚拟内存的地址空间中去 
使用相同的共享库的话  少内存的代码段并且减少内存浪费 
![[Pasted image 20240915140912.png]]
内存中的覆盖技术以及交换技术 
虚拟存储技术 
覆盖技术 ：对 之前已经存在在内存中的数据进行调用学习 覆盖技术 
共享覆盖区  利用了覆盖技术  采用共享技术  也就是说 部分的程序 共同覆盖到某个地方的值即可 
必须由程序员 声明覆盖 并且操作系统自动完成覆盖，缺点是对用户不透明的技术
交换技术：内存与外存中的某些进程进行互相交换的技术问题 ，内外存相互进行交换的技术问题
进程的pCB   
讲的是中级导读 内存调度 的问题  ：暂时 换出外存 把外存中的具备运行条件的进程换入内存中 基础呢灰姑娘在内存与磁盘带你动态进行调度 
挂起态 ：挂起态 suspend
文件区存放文件  

关于操作系统的交换技术swapping 交换技术
是一种内存管理技术：将进程全部或者部分内存移动到磁盘中来，并且释放内存空间给其他进程使用的东西，进程需要重新执行的时候 操作系统 从磁盘调回内存。需要的时候调回去  
主要概念：
1 交换入：进程需要被重新调度或者执行的时候 ，操作系统从磁盘加载到内存中
2交换出 内存资源不足，等会将内存移出到磁盘上
3多任务系统中  swapping交换的技术存在是为了让任务能更好的从内存中调度到磁盘当中 从而产生数据交换  
4 交换会产生交换抖动现象的发生以及产生
![[Pasted image 20240915152052.png]]
文件区 ：file area
磁盘用于存储用户跟系统文件的区域 ，包括文本文件，二进制可执行文件等 ：
     文件系统管理：os中的文件系统进行管理 并且负责组织文件的存储 目录结构 权限控制等 
     随机存取：文件区 的文件可以随机存取 ，对文件用户 存取是在文件区进行操作 
     数据保持持久性  
     碎片化管理 求最大的利用空间

对换区 swap
为了内存管理而预留的磁盘区域 物理内存不够了 充当临时虚拟内存 
对换区 会放入大块儿的内存页放入磁盘中 不会像文件区那样进行细粒度存储 随机存取 


插入 ：几种常见的文件系统的特点 ：
1 FAT32 : File allocation talbe 32 
历史悠久且广泛的文件系统  
特点：兼容性：高度兼容文件系统
啥系统都可以用 
2 NTFS :微软为了windows 系统设计的文件系统 ，并且现代操作系统的默认文件系统 
          大文件支持：NTFS支持单个文件 最大16gb
          分区大小 支持16EB大容量存储  
          NTFS存在文件夹跟文件夹访问控制列表  ACLS  允许管理员在这个表那边设置文件目录权限 
          NTFS支持文件系统级别加密 
          可以提供日志记录回复功能 ，并且有硬链接跟符号链接 两种  链接方式  
3EXT4：linux 的默认 的文件系统 ：
延迟分配技术 ：优化文件写入磁盘的位置  
有日志工鞥呢

访问控制列表  ACLS 
WINDOW中的acls 的基本概念 组成 
资源：resource 需要进行访问控制的对象 ，文件 目录 网络端口等 
主体：subject 请求访问的资源实体  用户＆用户组
操作：op ：主体可以对资源进行执行的操作  read  write  execute delete 等 
permission  权限问题 

操作系统通过查询acls 来确定该进程具有那个操作系统权限 
     1主体发起请求：尝试访问一个资源  文件目录等 
     2 检查ACL  读取资源的acl 查看其中是否针对该目录的条目 
     3 判断权限：观察acls 的变化来查案 
     PCB会常驻内存 ，不会被换出外存 来 PCB 依旧会停留在内存中 即可 



固定区不会进行调入调出 然后再覆盖区是可能会根据需求进行调入调出的 


### 连续分配管理方式 ：
内存空间分配与回收 ：
各种不同的分配方式   
连续分配  是 分配的空间必须是连续的内存空间并且是连续的内存空间 进行的分配方式 

内存中的只能有一个用户程序  且用户程序的时候独占整个用户区  
无外部碎片 不会成为碎片化处理机制  并且 采用覆盖技术扩充内存 等

只适用于单用户的操作系统  
注意 单一连续分配内存的话  只能有一个用户陈故乡 会浪费很多

固定分区分配方式 ：
固定分区 的就是用户区 分配跟多个固定大小的区域  或者不是固定大小的区域  每个区域装入特定的对应大小的分区 进行操作即可 

使用与一台计算机控制多个相同对象的场合进行 即可  

### 固定分区分配 

分区说明表  ：当前的分区大小 起始地址 状态等等  
数组表示这个表 进行 链表 表示 等内容  
并且简单无外部碎片产生的方式进行  
产生内部碎片 利用率极低 
动态分区分配 （可变分区分配 ）  不会预先划分内存分区  进程装入内存的时候 根据进程代销 的动态的建立分区 
分区分配以及回收操作 行为 
两种常用数据结构 ：
1 空闲分区表
用表进行存储  
2 空闲分区链
链表方式进行连接起来 指针指向的地址进行 链接方式进行 
动态分区分配算法 ：
空闲分区分配需求 选择那个进行 ？



如何分区分配回收 操作 空闲分区表  进行如何分区 
如何回收的话 ：
分区表 的话：
 内部碎片 ：指的摸进程内存区域中有些部分用不上 
 外部碎片：指的是内存中某些空闲区域太小了难以利用 
动态 分区不糊理由额奴婢碎片 但是有外部碎片 

紧凑技术来让他们更加紧凑的需求 进行紧凑的 算数 算 的内容 
  首次适应算法 ：
首次适应  ：每次 从低地址开始找 找到第一个能满足大小的空闲分区 
分两种 一个是空闲分区链 另一个是空闲分区表 一个链 一个表 简称链表 
最佳适应算法 ：
动态分配分区 连续分配方式 ，分配一片连续的空间 进行分配  ，当大津城到来的时候大片的空间 空隙拿去 
优先 去 用空闲的最大的分区表进行 分配  进行分配 考察  先把剩下的最大的进行分配 
最坏适应算法  ：优先使用最大的连续空闲区 

不许思维惰性  ：

邻近适应算法 ：
每次分配的时候从上次查找结束的位置开始查找  可空闲分区链 
基本分页存储管理的概念：
重点是非连续分配方式 
分页存储：
一个分区是 一个 页框=页帧=内存块=物理块=物理页面=物理页号 进程 的逻辑地址空寂爱你是也有页框大小相等的页面号，页号从0开始

一个页面 放入到对应的页框中  相当与是油画跟画框的关系 

页表记录者页号+块儿号的映射方式  进程界面的内存块跟内存号的映射方式 
 ![[Pasted image 20240915162341.png]]
一共 有4kb的页面大小=内存块儿大小   总共氛围多少个内存块二 然后---->求出来字节多少 后 b并进行最大的块儿号的运算即可 
如何实现物理地址 ：
逻辑地址 如何黄钻混到物理地址 
逻辑地址 -偏移量 

金策会给你页面的内容是连续存阿芳  虽然
取余页号 去证书 是  页号  
逻辑地址 除以页面长度 整数部分是页号  余数是业内偏移量 
如果是2的k次方的b 的话 用二进制数字表示逻辑地址  末位的k位为业内偏移量  其余部分是页号 的值 
页面大小的号+页内偏移量 进行 操作 

基本地址 变换机构 ：
原理以及流程 
逻辑地址 页面 内存中存放的位置 即可 
PTR  页表寄存器 进行 页表的其实地址F 跟页表长度 M 是 放在PCB中


内存中的系统区读 相应PC的值 并且  转换为 页表寄存器  页表起始的地址F  跟页表长度M  这两种可能性 
页号 页内偏移量 首先 用页号去找页表寄存器 中的页表起始地址 F  并且 相加后  去页表查询到对应的内存块儿号，并且能得到最终物理地址的值 

最开始  页表的起始地址 +页表的长度放在 进程控制块PCB中，当进程被调度的时候 操作系统内核会把他们放到 页表寄存器中并且引入他们的值 
页号 跟对应的页表想的地址  页表的起始地址 F +页号P *页表项的长度 问题 
页表项长度指的是 每个页表项占多大的存储空间  
a 
一个页内便宜狼 反应华丽页面大小


快表 tlb 的机制  tlb  访问速度 比内存快很多的告诉缓存 
相当于是个cache 缓存机制，然后速度特别快 比在内存中的页表的速度要哦快的多 
所以叫做表  页表 慢表

TLB的神奇之处 
![[Pasted image 20240916092716.png]]
神奇的tlb 的功能以及机制问题 
这是他们查询速度 的关系 
页表放到TLB中  。。

最近的书放到小书包里面去 
![[Pasted image 20240916093016.png]]
#### 快慢表的变化规则  
逻辑地址 首先去快表那边看看是否有页号 如果找到了对应的页号的话 去直接访问内存单元 
这样访问了一次内存 
如果没找到匹配的页号的话，就需要访问内存中的页表部分 ，找打页面内存的块儿号，找到对应块儿好后 若快表未命中的话 ，则按照算法对其进行替换操作 的行为逻辑

基于局部性原理
关于操作系统中局部性原理的相关理解  
局部性原理描述了程序子啊运行中 对内存的访问模式  一共有两种 
1 时间局部性原理：
指的是在某个时间点被 访问过的数据，在接下来的时间段内可能被再次访问 
例如：
循环计数器 递归调用等
常见的场景 是程序计数器 ：也即是PC 的值  PC 会保存当前执行指令的地址 指令是按序执行的  ，所以计数器是变化递增 PC=PC+"1"
应用： 1缓存机制 ：cache 将最近访问过的数据保存到快速的缓存，缓存的速度是远大于RAM从内存的RAM中提取数据的速度的机制的 
所以对于chache而言，同样的数据再次被访问的时候，无需从较慢的主存中获取数据，而是直接从缓存中读取
 2页面算法优化：LRU 最久最远时间算法优化 ，将最久未被访问过的页面淘汰等机制 

#### 空间局部性：
指的是程序访问了某个地址的内存位置，接下来有可能会访问相邻的内存地址 
以块或者段的方式 
举例：数组遍历 ，当顺序访问数组的时候 数组通常存储在连续的内存位置中，一次性访问的吸是相邻元素的值，的话表现出来很强的空间局部性
顺序栈执行的指令：程序指令按顺序执行

应用 ：
分页跟分段内存管理：  虚拟内存按照段页式进行管理 来达到页面置换的目的，当页面架子啊到物理内存你的时候  进行两次访存 ，
可以通过修改tlb或者



两级页表机制 
页框指的是一个大框包括了很多页表项 去运行 去执行相应的内容的东西
页框是一堆集体的页表的合集 
同金策会给你在内存中必须连续存储的问题 
离散分配的话再建立一个页表 是

分组 分组 在分组 进行分组进行推理 推断
  进行多级页表的判断    就是 一级一级进行映射 慢慢映射到最终地址 的值 
  多级页表 两级页表
就跟图书馆放书一样 瞎几把指乱指 一层一层唐朝接 就可以得到最终的物理地址
进行分组 

解决 不让整个也报常驻野村，进程短时间内需要访存几个特定的页面 

多级页表机制的话 各级也报大小不能超过一个页面
瞎几把乱指 多次进行指 针乱指 随便指 


基本分段存储管理  离散的时候分配的基本单位不同 
什么是分段 ？
什么是段表？
如何实现地址变化？
每个段从零开始编址的 ，他是 各种不同的段 是有段名

每个段 都会占据某种连续空间，并且用户编程更加方便 程序的可读性更高，
分段的A单元的值读入寄存器 
并且 寄存器存放在b单元中

编译程序会将段名转换为段号 

分段 究竟会分为多少个段呢
16位的二进制数 最多表示 2的16次方 也就是64k 的段的位置 

比如
```
LOAD 1,[D] |<A>;//分段D 中的A单元内的值读入寄存器1 
STORE 1,[X]|<B>;//将寄存器1中的内容X 分段的单元B 中 
写程序 用的[D]  还有[X]会被编译器翻译为 段号  
<A>以及 <B>会被翻译为段内地址 的值  
```
段表：
段映射表  各种映射表 
段表 页表 前面的个护总表 
基址 对应的是内存的其实位置  
注意 可能会有段长这一个说法

![[Pasted image 20240916111457.png]]
段表项的长度是相同的 ，各个段表项的长度书香桐的 
段号可以是隐含的不占的存储空间 
主要是 要俩信息 一个信息是 段表的起始地址  M 然后 后续 的段号 的值
段号 +段内地址 是 用的是逻辑地址 的地址变换 ，访问的逻辑地址变换为物理地址 的信息 

还是系统区出来的段表寄存器   
段表的长度  一个是段表的起始地址   放在内存中系统区的pcb这个软件当中  

如果访问的逻辑地址A  
判断 段号   本身 跟 短表长度 M  是 进行对比  是否达到这个值 的内容
分段  的机制的话方便执行这种消费者生产者集成的共享功能
分页分段的空间的优缺点 的分析   
分页 空间利用率高  
但是段式管理  来 采用紧凑技术来凑成一个较大的管理内存空间的内容 的值
分段 是 行为过程是可见的 但是页面段地址是二维的

段式管理方式是二维的  页的管理方式是一维的  信息 

## 虚拟内存(开骗！！！)方式进行 分配管理内容 



总结 ：为了合理分配内存空间，能及时清理那些不必要的内存所在的空间 
传统存储管理：
一次性一步到位：作业无法运行 
作业必须一次性全部装入内存才能运行 

容量过低，太大：
驻留性：作业一旦放进去了 就一直留下 但是我只想用一下某个部分的内容，很少，比如 存了1gb的内容 但是我只用里面的1mb，由于一次性存放的资源过多导致某种浪费的发生 

1连续分配
2 非连续分配：

局部性原理：

时间局部性（反复执行某种代码）
与空间局部性（一个点连带一片数据）：

先部分调入内存 剩下的放外存，如果需要的话在进行调入也不迟。

虚拟内存有以下三个特征的发生：
多次性：无需一次性装入
多唤醒：无需一直常驻内存，允许运行的时候 多次交换
虚拟性：用户以为内存量很大 实际没多少东西

跟离散分配技术相对应 
从外存把信息抓到内存中，进行内存与外存之间信息的交换 
有个功能：请求调页 内存空间不够，操作系统负责将内存暂时用不到信息换出到外存中去用 
页面置换功能是这么建立起来的 
请求掉段 进行段置换的能力

主要两个功能的实现：
1 当信息不在内存的时候，我们需要从外存调入内存到内部，然后再执行程序
2 当内存不够的时候，操作系统将内存中暂时用不到的信息放入外存中去
主打一个页面置换功能 

缺页中断机制 ：
缺页中断的处理终端机制  缺页的机制阻塞的过程 放入阻塞队列后 在完成后进行唤醒的过程  
比如当内存出现空你惨的时候 放入该块儿 修改也报 等 内容

缺页中断机制 属于  内中断 ：内部异常  
                        故障 
                          终止
外中断：I/O中断请求
         人工干预
         

请求分页的时候 有以下五个模块 需要考证：
1 内存块儿号 
2 状态位
3 访问字段 
4 修改位 
5 外存地址
内存 不够内存暂时用不到的地方换到外存
步骤1：请求调页  
1 虚拟内存+物理内存 
虚拟内存：操作系统提供一种机制  每个进程提供一个看似独立的内存机制  
那个页面放到内部  进行 确认到底是哪个指标放到了操作系统页面内部的机制
2 状态位：表示是否已经调入内存 
3 访问字段：页面访问了几次 
4修改为：标记是否被修改过  
5页面中的位置：外存地址的相关的值 
缺页中断 核心是 从外存调入内存的过程 
当访问页面不在内存 的时候 告诉操作系统 我该与外存进行互动，并且开始调入内容
然后 由操作系统中缺页中断处理程序 处理中断内容 
此时缺页的进程阻塞 ，得暂时存档 让他去一边去（让他待机） 执行完 页面调入后再次将他唤醒
外存此时将信息 尝试调入内存 分配 ，但是 得看内存中是否有位置让给他
当 内存中有空位的时候 ：刚好进程中有空闲块儿 并且 缺页放进来
如果内存中无空位的时候： 由页面置换算法 选择一个页面进行淘汰 （四种调度手法）4然后如果页面这时候在内存中曾经修改过的话，外存中还没这个修改完的备份 不行 ，所以此时 将内存中修改过的 在外存写回 并且做好备份 
默认外存>内存   其中未修改的当然不用写回
可以理解为内存的空间相当于一个代表性的东西 。代表了外存 的一部分 如果页面置换中的cache一样 
缺页中断发生：内中断   （陷阱 ，故障（可以被修复的中断），终止 ）
发现 并未产生空间或者并未有空间的话会发生中断部分
请求调入页面  +页面置换 +修改新增表象  
如果能在快表中的 检测的话 一定在内存中有 ？
	为什么？
	答：TLB机制 的引入的目的就是为了加快内存到外存之间的转换机制，搭建合适的桥梁进行转换操作 ，而且tlb讲究的是效率，效率为王 如同地址转换跟指令映射中cache的作用一样 ，我只留下来有用的，没用的会从我这里删除机制，TLB 命中的话  快速内存访问 ，
	为了保证效率问题，如果这个页面信息是不常用的 经常性未命中，则他会被tlb踢出去

![[Pasted image 20240918152956.png]]
第一  读跟写 的指令 的时候 写是修改 访问位跟修改位 读指令并不会
第二 当处理普通中断的时候 需要保护好现场  
换入换出 的时候 是需要启动是I/O很慢 的操作   ，在修改页表的时候 同时还补充相应的页表想 

有限查快表 
然后再查慢表 

#### 页面置换算法 ：
  OPT  FIFO  LRU  CLOCK 
  最佳置换算法 OPT ：以后永远不被使用的页面 
  从发生需要替换的 页面往后看 看谁离他远选择那谁出来  就是选择最长时间内不会再别访问的页面的问题 
页面未满  或者发生替换的时候  这是缺页中断  ，当内存块站满了后 再次挤占空间这故事页面置换  
前提条件 是 需要接下来访问的页面序列是多少 

FIFO 栈  先进先出  
开火车算法 ：穿隧道开火车的算法 

belady 异常 ：只有FIFO 会产生 那种 进程分配物理块儿增大的时候 缺页次数不减反增的过程 

LRU最近最久未使用的页面 （LRU）
每次淘汰最近最久没访问的 就可以 
从开始往前看 谁离得远用谁 
需要专门硬件支持

CLOCK  时钟置换算法 ：
简单clock算法  访问位 1 表示最近访问过  访问位为0 的话是最近没访问过 
淘汰一个页面会经过两轮扫描 
被扫描过的 页面会被置为0   
开始扫描逐渐 走 时针 遵循上述过程即可 执行 相关内容 

有限淘汰没有被修改过的页面  还要考虑页面有没有被修改过 
修改位 位0 表示页面没有被修改过  修改位为1 的时候表示页面 被修改过 
然后开始进行访问  
最多会进行四轮扫描 
设置两个标志位 (访问位，修改位 ) 设置诸如此类页面即可 求得 
永远淘汰 为(1,1)这种界面 去及你给访问 


页面分配策略
驻留集：系统花大量时间来解决缺页 实际用于进程推进时间少  当前驻留留存在物理内存中部分数据
助留集大小  是 存放进程快  能存放多少个进程块儿 

固定分配：刚开始分配固定的数目物理块儿 进程运行时候不改变，内存分配策略之一 ，为么给金策会给你分配固定数量的内存页跟内存块儿 ，每个进程先分配一部分 在去做 
可变分配  ：随机适当调整大小的值 随时随地修改


置换 ：局部置换：只能选择该进程自身的页面进行置换，不可能影响其他进程 
        全局置换 ：所有进程的驻留集中选择一个页面进行置换，不是限制在单一的进程中 ，更灵活 可能导致剥夺个呢更多内存
        

操作系统 固定分配 局部置换：
策略跟局基础呢灰姑娘大小 优先级来判断进程分配的内存块数
固定分配局部置换 
可变分配全局置换：只要缺页就分配物理块
可变分配局部置换：但凡缺页就要换 
合适调入页面：
预调页策略 ，预测不久后可能访问的页面并且将他们优先导入内存中去用 预测  进程首次的调入 去预测 到底那些该先用 
请求调页 ：当运行的时候发生缺页的时候 将缺页调入内存中去使用 进行 


从何处调用呢？
对换区 ：采用连续分配方式 
文件区  速度慢 离散分配方式 
unix 方式：运行时候进程数据全部放在的是we年去   基本上文件区调入到内存的内容是已经确认不修改的内容 ，然后内存中选择调出的数据 跟速度较快的对换区进行代换操作的行为逻辑 ，而不是直接跟文件区进行兑换 

如果对换区空间足够的话  因为速度快 所以由他根内存交互
如果对换区空间不够，必须让文件区挪地方 把必不可修改的文件放到内存中 然后内存还是跟对换区交互后复制到文件去 

一切原则以速度优先 
抖动现象 ：
就是频繁的访问 进出内存 造成的现象 
工作集：某段时间间隔内，进程实际访问的页面的合集
某个时刻内往前看 的窗口尺寸的页面 
窗口分那么多 工作集小于等于  如果发现小的话 可以把窗口缩小 

所有进程你分配的必须得比工作集所实际访问页面的集合 的要大 
也就是工作集要必须小于驻留集

传统的文件访问的方式：
直接从磁盘 中拉一个指针 到进程的映射文件的起始地址 按照访问内存方式去访问数据，并且从起始地址开始后  用指针指向指定的数值 即可


多个进程可以映射同一个文件 ，文件还是存在于磁盘 中不糊一遍  虚拟大猴子空间 可以去映射同一个文件的内容  
可以通过多个 金策会给你可以共享物理内存以及 统一个数据
