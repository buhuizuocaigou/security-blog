死锁类型的问题：
此类问题 归结为 扩展的单行线类问题 ：

![[Pasted image 20240923110721.png]]
模型如下：
### 一 单行线模型 :
1 基本原理 ：
进程常使用多个资源   分配 聚恒打破循环等待条件  
四个条件：1 互斥 ，2持有并且等待 3 不剥夺 4 循环等待条件 

2核心逻辑：
将所有的模型资源编号 并且按照编号的次序严格执行请求 并且释放的时候按照顺序相反的方向进行下去 
并且编号的顺序是唯一 的 ，构造一个虚拟栈，这个栈里面请求资源的话按照编号从小到大顺序 ，释放资源的时候按照相反的顺序释放 ，
规则：
1 逐步请求资源 不能违反规则
2 资源不可用时候必须等待（这也是造成肌饿的最关键的因素）
3不违反顺序

### 二 单行线扩展的模型：
将资源跟进程请求分成多个优先级 单行线，多条单行道 并且 子啊基础呢灰姑娘满足某些条件时候进行串线处理 
2.1 多级单行线模型：
将资源分成多个优先级的单行线，每个资源中有自己请求顺序，必须安装哦按所在单行线的请求资源 ，注 ：单行线A跟B 之间存在优先级关系 
高优先级的可以中断低优先级的资源  


在上述代码中的核心点在于 ：
![[Pasted image 20240923112100.png]]
这里揭露了当 P1 拥有 y的时候  P2 必须等待Y 才可以运行 
那么 如何判断他们是符合单行线扩展模型的呢？
此时需要思考以下三点内容：
1 是否对每种资源有明确优先级或者编号顺序？
2 进程是否严格按照某种顺序请求资源？
3 是否符合单行线的先后顺序的严格要求？
答：
1  p1进程中 ： x1--->y  
2  p2 进程中： X2---->y 他们分别放在独立的P1 P2 中 且相互互不干扰 并且  他们唯一可能产生竞争的条件是y  
那么此时有可能发生两种情况 ：
1 此时 P1优先级比P2高 
2 P2 优先级比P1高  
首先 从代码中并没看出来那个优先级高 所以只能人为假设两种情况的发生 

不同优先级 决定了 谁先执行 ，而单行线的模型 又决定了必须严格按照顺序执行，如果上面没释放的话就不许坐后面的 
这时候考虑一种情况  就是高优先级的那个进程P1 或者P2 ，由于优先级较高 他不说释放 P2是无法执行的 
也就是 高优先级的 一直独占某个进程 这样会让低优先级的永远分享不到资源  


