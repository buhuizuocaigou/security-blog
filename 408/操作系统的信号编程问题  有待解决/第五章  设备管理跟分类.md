
资源管理者的设别管理 提供的功能类型

I/O设备指的是输入/输出设别
1按照速度分配   2 按照质量分配 3 信息交换的单位分类 ：块设备 字符设备I
I/O终端 ：是一种类型的 中断驱动方式 
机械部件 是用来执行具体操作者 I/O操作 
 电子部件 是插入的一个控制草 
 
 控制器功能:
 1 接受识别cpu发出的命令 ：CPU发来的read /write 命令并且有对应的控制寄存器存放命令+参数
 2 cpu报告设备状态 ：各类状态寄存器记录I/O设备当前的状态 1 空闲 0忙碌的装阿嚏
 3数据交换  寄存cpu发来的数据在由控制器传送设备 然后cpu数据寄存器中取走数据信息
 4 地址识别 
内存地址，区分设备控制器 哥个寄存器 特定的地址，I/O特定的“地址” CPU 读写 哪个寄存器

### I/O控制器的组成 
输入输出控制器 管理cpu数据传输重点组件 ，负责处理设备与内存之间的联系跟内容
### I/O控制器组成部分
1  数据寄存器 Data register
      是I/O 控制器存储数据的临时位置。负责暂存I/O设备读入写入的数据 
     设备交互关键节点  允许数据 通过总线内存菜传输到I/O设别 
2  控制寄存器：Contorl Register
    存储控制信息 ，控制I/O的操作 启动或者停止设备 设置读写等 
    通过写入特定的值控制寄存器 OS 或者程序可以改变I/O的行为 
3 状态寄存器 ：（status register）
存储当前装泰信息
4地址寄存器： 设备的物理地址信息，通过他存储标识特定的设备跟内存具体位置
5 中断处理：使用中断机制向cpu报告时间，设备就绪 完成I/O操作或者发生错误的问题
6 DMA控制器：允许设备直接与内存进行数据传输不经过CPU 
               特定内存地址块儿直接读写数据
7 总线接口 ：各种接口进行同哦想你 

控制跟设备的接口信息 ：
是数据输出数据到存储器中数据存储器存储数据信息
![[Pasted image 20240921104333.png]]
I/O逻辑相当于I/O这一套设备的大脑组织机构 ，进行内存映像 的I/O设备以及寄存器独立编制进行 
内存映射I/O 的haul 寄存器跟内存记性统一编址
![[Pasted image 20240921104540.png]]
CPU 控制器的接口：
cpu与控制器之间的通信 ，控制线发出命令。通过地址线指明操作者设备 以及数据线取出设别 
内存 映像 I/Ovs 独立编址 ：
寄存器 是跟内存是一套地址 
独立编制 是 把寄存器独立出来从零开始编号 ，属于跟内存处于一个系统还是俩系统 

I/O控制方式 ：
1 程序直接的控制方式 
2 中断驱动方式 
3 DMA 方式 
4 通道控制方式：

程序直接控制方式 
read /write操作 
cpu向I/O发出读指令 ，I/O逻辑 设备的接口 控制器接口信息
CPU速度比设备速度慢很多
挨个检查状态  

CPU 会不停的轮询检查循环设备 
数据寄存器改为0 ，循环检查为0  的状态
 一 、程序直接控制方式
 
五种控制流程
1 cpu控制器发出读指令  ，设备启动，并 读指令设置控制器 为1  （未就绪的状态）
2 控制器与设备的接口  是控制线  链接的时控制信号  
cpu不停的检查数据是在轮询状态 cpu不停的在进行轮询转台 
并且传输给控制器并且报告自身的猪肝提 
4控制器将输入的设备放到数据寄存器中 并且状态改为0 

cpu发现设备就绪  内存读入cpu的寄存器中 内容放入内存 
再次记性cpu发出读指令接着循环执行

![[Pasted image 20240922102549.png]]

场景预设：当I/O设备插入了一个接口后 CPU尝试与这个接口产生联动操作 进而产生的一系列的行为逻辑问题 ：
cpu-->I/O状态   
1 I/O到cpu状态  检查状态的错误条件  CPU-->I/O cpu向I/O模块发出读命令 进行读操作
2 读取I/O模块的状态 I/O->CPU CPU检查I/O模块的状态 确定是否准备执行数据读取 
3检查 ：准备好：继续执行下一步  
        为准备好：cpu进入错误条件 等待 I/O准备好后再进行下一步操作 
4从I/O读取字：CPU 从I/O读取字数据单元 
5 数据写入存储器  ：此时把数据写入到指定的存储器的位置中
6完成检查  ：检查 I/O操作是否完成 
如果已完成  继续执行 如果未完成  继续发送读取  

cpu跟I/O行为 不停的发生模块儿状态变化 判断是否发生传输效率 ，此举动效率较低  
浪费CPU的时间 ，不停的等待I/O是否处理完毕
会产生错误条件 

==注意：！！！！！跟高考不一样！！！考不好 不会有任何人责怪你！！！！！！！==
==跟高考不一样 ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！考研跟高考不一样!!!!!==
==500w里面有100w能坚持到最后== 
==！！！！！！！！！！！！！！！！！！！！！！==
==不是必须上  ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！==

1 轮询操作
2 cpu干预的频率 ：I/O开始前 跟开始后 都需要CPU的介入   ，每次 读入读出的介入的是一个字 

注意 CPU 跟I/O只能串行工作  CPU 需要一直轮询检查 长期会处于一种忙等的额装阿嚏中 并且cpu利用率会很低 


中断驱动方式 ：
核心 ：CPU发出I/O后等待I/O的时候 的时间可以拿来做别的事情 的内容 
注意  CPU会在每个指令周期末位 检查 终端  
终端 保存快照的运行环境 ，如果频率太高 会降低系统性能问题 降低 等问题发生 。
CPU 在等待I/O完成后  可以做其他的事情  
数据传输 一个字！！！！！！！注意是一个字！！！
读  I/O-->CPU --》内存 ！
CPU 跟I/O可以串行到并行的过程  
频繁中断会产生一定的代价问题  ，读入读出 的数据的时候会产生cpu的问题 
DMA方式：
直接存储器存取 ，对付块设备   他不是一个字节 而是一个大块儿  
而是 数据流向不会直接流入CPU 直接 跨过cpu直接流入设备的过程
指明此次进行 

CPU直接指明需要什么操作 然后 dma直接根据cpu的要求 进行 cpu介入中断的过程 
DMA控制器 ：
![[Pasted image 20240922105514.png]]
数据传送的单位是多个连续的块儿 
通道控制方式 ：识别 并且执行系列通道指令
cpu 发出I/O指令 记性 通道程序 任务清单 跟数据的处理  通道程序的首地址  访问I.O设备 
发出I/O指令  走通道  向CPU发出中断信号

各个层次 是 从最高层到最底层 为  用户层软件  --设备独立性软件 --设备驱动程序--中断处理程序 --硬件   
从高到低：
用户层 ：向用户提供接口以及服务的功能，实现用户交互接口工鞥 使用层提供的库函数 
操作系统内核：
涉及到四个层面的东西 ：
第一层：用户层软件：提供用户跟 操作系统的交互的接口渠道 
内核层 ：设备独立性软件:采用系统调用的桥梁跟用户层软件进行连接 进行    比如 printf 会被翻译成 write 调用  系统调用window API 也存在与这个层  上面  

设备驱动程序 
设备硬件无关的程序全在这里面
设备的保护  设备独立性软件  设备驱动策划给你续  特殊的文件 不同用户对设备保护
设备驱动:独立性软件 设备进行处理
设备分配与回收：设备进行分配跟回收的功能问题
建立逻辑到物理的映射关系  然后选择独立程序  
指明 我用的I/O操作的逻辑设备名 ，用户看到的时逻辑设备名 
从物理设备董安逻辑设备的映射关系是  LUT一个表逻辑设备表 ，记录了逻辑设备物理设备的地址  驱动程序入口的地址 问题 

操作系统吧设备当做一个特殊文件进行映射关系  

LUT  ：1 一张LUT 单用户操作系统 
       2 树结构 跟索引的那种类似树结构 进行树结构的层级映射方式
       每一个用户 使用一个LUT 的哦逻辑设备表，这个使用与多用户操作 并且 他是逻辑设别名可以从夫，并且系统会登录的时候专门使用了PCB 进程存放他们的内容 
   注意 ：不同设备不同驱动程序 每一个设备 的型号 不同 一个机器适配一个心痛模型 
不同设备驱动的型号会不同的
各种设别 不同的硬件特性不一样，所以分配不同的程序 给他们 已达成不同的目的 的问题
注：驱动程序是一个独立进程方式


数据缓冲区管理的 屏蔽设备管理大小的问题

中断处理程序
当完成I/O时候，I/O会发送一个中断信号，根据中断型号的找中断处理程序并且执行  然后 判断后根据规则判断不正常
如果正常的话 设备读数据 经cpu放到内存缓冲区中 去 
中断处理设备  中断是属于 游戏进行存档的操作  保存当前文档 供下一次使用的过程

各个层次的顺序 
用户层--->设备独立性软件-->设备驱动策划给你续  -->中断处理程序 -->yi硬件处理程序 




最底层：硬件 



分为字符设备 块儿设备 以及网络设备三大类 功能 
字符设备接口：get/put get从设备中读出一个字符 
                     put 是从设备中写进去一个字符
块儿设备接口：read  跟wirte 的设备调用 间接读写指针位的多个字符 修改读写指针的位置 上面 


网络设备接口： 网络套接字 的socket 的接口
socket 的系统调用 创阿金网络陶洁字 加入 bind tcp 跟udp的系统 套接字绑定到本地端口中，并且 套接字链接到地址
用于不同主机之间进行数据通信的编程接口 ，并且允许应用app在网络中通过标准化的编程接口进行数据传输 
套接字指的是：允许应用该程序通过网络首发数据 每一个套接字与特定的协议 tcp udp跟网络地址的关联，app可以使用套接字在网络发送接收数据包 

socket的原理：
1创建：用socket创建爱你套接字  指定协议族 AF_INET ipv4系统  
	套接字类型  `SOCK_STREAM `表示TCP链接    `IPPROTO_TCP`表示tcp协议等信息 
2绑定：使用`bind()`套接字绑定具体的ip地址跟端口号  告诉在哪个ip地址上执行监听请求 
3 监听跟链接：
     服务器端使用`listen()`函数进入监听 ，且等待客户端请求
     客户端用的是`connect()`链接到服务器IP地址跟端口号
双方依靠这个提供链接通路以及端口号应用程序 
4 接受链接 accept ：收到后 用accept接受链接 
5数据首发  直接拿传输 

陶洁字的类型  1 流套接字  2数据报套接字 3原始套接字4 
总结 ：建立 套接字 收发端口上 ，然后 建立tcp通信机制 
```
bind   指明端口并且链接到套接字的端口上 
connect 是链接到诚地址 
read/write： 是直接采用读写数据 
fd 指的是用户空间中操作文件的系统内容 
采用通讯 层层之间剥皮往里渗透 进行渗透进入 
输入输出设备接口:
键盘 等 鼠标的你 是属于键盘块儿设备
设备驱动程序接口 ：
层层 跟包柚子一样 一层一层往里进行深入 
```

阻塞/非阻塞 I/O 
发出I/O系统调用 转入阻塞态等待  
阻塞I/O不哦永登 直接用   

非阻塞 等待  指进程无需阻塞等待系统中。 直接就拿来就用 突出一个拿来主义 
厂商标准的统一接口数据的程序 进行连接  操作 
I/O设备的子系统程序 

`UNIX的系统中 设备备看做是一种特殊的文件，每个设备会有对应的FCB  当请求访问某个设备的时候 根据FCB提供并判断是否有相应的访问权限 `

### 假脱机技术 splooing 技术

假脱机 技术的神秘面纱  之前有过类似的问题 

脱机技术：直接 不用 中间的核心 ，直接从内部到 外部 数据信息 类中断机制 
不用走内部审批程序，直接单开后路直达深处 
进程 是可以 有之前的单一设备 变为 共享设备进程 
假脱机 虚拟化  成多个共享设备 把独占改为共享设备 的方式进行 
虚拟化主要是 spoolling 的设备体系  

设备分配算 法 fifo  等等  

设备分配安全性 
### 设备的分配与回收
1设备分配的时候考虑的因素 
设备固有属性 ：独占 共享 虚拟 

进程分配进程后“独占”  阻塞 别人不允许占我的位置 的信息 的数据 只能我共享的这种方式 
别人都得在后面排队

2进程  不安全分配方式可以采用 的 是 死锁避免 银行家挨算法 等  来  避免这种
不安全分配方式： 就是我一个i/O占据的时候别人也在同批进行 

静态分配：破坏请求保持 条件
设备控制表 DCT  
各种表 的控制 目的是索引表的类型 来让他们方便查找 内容类型  
指向队首队列的 pcb 的队列  进程阻塞的原因不同 将pc吧挂到不同的阻塞队列中     设备依照白哦的部分 去指向阻塞队列 
设备控制表 


单一设备或者一组设备的表格  可以冬天更新  主要是针对硬件 等 分配的 










COCT ：组件设备操控指标 
动态控制白哦  是管理GPU 多核处理器等的运行策略  



 信息

SDT ：系统设备表中 ：记录了系统中全部设备的情况类型进行选择性 
包含系统的硬件跟固件信息的数据结构 描述系统的总体配置跟资源布局 
SDT 包含多个子表 MADT FADT等  
BIOS通过SDT 读取系统硬件配置详细信息  并且初始化的时候使用这些信息  


总结 ：
SDT是系统界别描述表 定义了系统的所有硬件资源跟 布局配置各个设备之间引用的问题 
DCT是SDT的子集跟扩展，描述设备的详细配置，并且 是设备管理固件读取SDT 并且根据设备引用信息读取dct 


COCT 是 SDT+DCT的联动，读取SDT全局配置信息，跟DCT设别状态来动态控制整个组件  等 





设备分配步骤：
1 请求物理设备名 查找SDT ：物理设备名是进程请求分组 
2 SDT--->DCT （LUT 信息） 忙碌的时候 就挂设备等待队列  
3 DCT-->COCT  若忙碌 则挂到控制器等待队列中，不忙碌既由控制器分配进程 
4 COCT---->CHCT  忙碌的话 PCB挂到通道的等待队列中  不忙碌分配进程 
很明显 ，在上述描述中，1234中 跟请求物理设备名比较捉急所以改善为逻辑设别 ，
也就是 物理设备-->逻辑设备名中 这样的话有利于信息的传递 ，对于用户来说更容易识别 信息 


必须提供物理设备名 进行  
改进的方式是在  第一步中先查 逻辑设备表 然后子啊进行  SDT --->DCT---》coct --->chct这个过程 


只有一张LUT （逻辑设备表）的话 这个不允许重复 的适用于单用户的操作系统 与上述相符 


如果每个用户有一个LUT 的话 不同用户的逻辑设备 可以重复 多用户不会冲突 

什么是缓冲区 ？
1 缓冲区存储区域 chache     计组内容 速度比内存跟cpu交互要快的多
成本高且    容量小 
2 内存缓冲区组织管理     对内存作为缓冲区 管理
缓冲区作用 ： 缓和CPU 跟I/O不匹配之间的矛盾  
 减少cpu 中断的频率 ，放宽相应的时间限制 
 解决数据粒度不匹配的问题  
 提高 I/Ocpu 的设备并行性 

每次输出一个字符 就向cpu发送中断信号 
放宽cpu对响应中断的限制
输出进程 是一个字符一个字符的输出  

单缓冲 ：只有一块儿 供他们使用    只有一个  
缓冲区 特点：==当缓冲区数据不空的时候，不能往里冲入，只能缓冲区把数据拆除 
缓冲区微控 缓冲区 充满才可以传出  ==
类比于原子性操作 
要输入数据 
这是一个模型   就是 这是一个一整块的时间  一个整体 
从工作区满  缓冲区 空  ------> 工作区满 缓冲区空   的进程 模型 
进行的时间是T+M 这么长时间    ，注意利用这个 截取  
必须得给 缓冲区的数据腾地方  

![[Pasted image 20240922231427.png]]
”谁长谁占理 “ ------但缓冲区的策略       max (C,T)+M 
双缓冲区 是 链各个数据  
当出现缓冲区到工作区的路径的时候的阻塞问题后，要送数据的话是一起送 ，不能说我先送缓冲区A 再送缓冲区B  这个不可以  

一二都空才可以 都往里面冲入数据 信息  
两台 主机缓冲区的之间的传输也均可以 ，并不一定 非得自己用 ！

双机器但缓冲区  的话 只能单通信  
可以配置双缓冲区  ： 一个接收数据 一个是发送数据  同步双向传输功能


循环缓冲区 
缓冲区们组成列表 的循环结构挨个使用  一个一个来谁也别抢被插队 1


缓冲池  ：是 相当于 公用缓冲区 
使用  空缓冲队列  输入队列 输出队列 
收容输入   提取输入 提取输出  收容数出

利用缓冲池机制来达到循环等目的 具体看题目


### 磁盘磁道 跟扇区 ：
磁盘的细节结构u  包括 磁道  此面 磁柱  ，跟 计组的磁盘相关讲解互相对比即可 
最内侧的扇区 的密度是最大的 
移动磁头 然后去读写数据即可 
磁盘装懂的时候 ，想要的东西会从下面划过 即可 ，磁头臂带动磁头 ，让磁头放到磁道 
这个 计组已经详细整理总结过  
磁头 是共进退的方式进行移动的，  柱面号+盘面号+扇区号 
三元组 定位到某个盘面某个扇区 具体的数据字节信息 等 需要综合性大题来训练 期待这种做大题的训练！！！


有的是 磁头可以 活动的  ，有的是固定头磁盘 每个磁道对应固定这一个磁头 
磁盘是否可以更换 分为 可换磁盘 跟不可换磁盘 方式 进行 

磁盘调度算法 ：
合适的磁盘调度算法 ：
  一次磁盘的读 /写的时间 ：是 寻道时间读写 磁头臂到时间  
  启动磁头臂  +移动磁头的需要的时间+ 也就是移动到几环 然后移动到那个区域 ，就这俩数据信息 
  延迟时间 TR  旋转磁盘 磁头定位到目标扇区的时间   旋转的磁盘所需的时间

上传输时间   从磁盘读初 或者写入数据  他的长度 所用的时间  
先往里找，找到内部后 然后去定位到头部开始，从而 开始读写加载到 读完这个条为止

FCFS 先来先服务   谁先来 谁先访问 
按照先来后到的顺序来服务 定位 
平均寻找长度 是磁道书/他们的磁道数量 

SSTF 最短寻找时间有限 ：只需按照眼前最优的 类比与贪心算法 即可 klp算法机制 内容 
局部最优 但是不代表全局最优  ，即可理解内容 
  容易产生肌饿 现象的发生  ，既容易发生的肌饿下乡  
  在某个区间反复 
扫描算法 电梯算法 从头扫到位 在从尾扫到头 然后但是也是局部最优 ，但是在整体来看必须移动到最外侧的磁道在往内部进行移动才可  

不会产生肌饿的现象 ，虽哥哥位置磁道 的相应频率不平均   

LOOK调度算法：如果在磁头移动方向的时候 如果没有别的 请求了 就可以立即改变磁头的移动方向内容，边移动边观察 ，减少 做不必要的无用功

C-SCAN 循环扫描算法 ：
磁头向某个特定方向移动的时候   才会处理磁道的请求 问题 ，返回的事后快速移动到起始端点，斌贵 磁头往正在磁道号增大的方向移动

走外循环  不走回头路 ！


C-LOOK 外循环 首尾相接 但是不走冤枉路 懒蛋思想 


减少磁盘延迟时间的方法：
寻找时间往环内移动磁头磁壁的时间+延迟时间扇区转到磁头下面害的 时间+传输时间读写数据花费的时间 

逻辑
在减少延迟时间的时候：在读完 2号扇区到3号扇区的时候 中间是需要一小段做准备的 这段准备时间磁盘并不会停止转动，他依旧会继续转动下去 所以这就会导致一个问题发生：会多转好多圈，如果我们把它在跨区域的准备时间 中 读取一段无用的磁道 ，也就是说是类比于空转那种思维模型的话，这样准备时间过后刚好能进行到下一个需要读取的扇区 能达到合理利用的目的 

核心 磁盘并不会单独为了等磁道而停下  也就是磁盘的动是一只在东 而不是 暂停那种 

柱面号  盘面号  扇区号 ：这么设计的原因是 柱面号是 并行垂直操作的  这样 当读取连续地址的磁盘面的时候  他可以采用不用进行 内环到 外换 
错位命名 减少旋转的空转的方式 提高他们的效率 

磁盘管理 ：
磁盘初始化 指的是 ：
低级格式化 物理格式化 （划分扇区 ）：扇区分为 头  数据区  尾   
这种设置的部分可以设置为链式区域 头尾相互

磁盘分区  ：
逻辑格式化  

引导块儿：
启动时候 ，进行一系列初始化的工作 ，主要执行的时初始化程序 自启程序完成的 
初始化程序  放在ROM 进行 ROM出厂就设置好，以后不能再修改  并且无法进行更改数据呢绒 
ROM 存放子举装入程序，启动块儿 的位于的是磁盘的固定位置上，子举陈旭 装入内存 完成初始化 的过程 

磁盘的坏块儿的管理 ，操作系统的是软件部分无法进行修复的 
标记的时坏块儿价差 ，读取淮河社区怒 
在FAT 的表中，坏快对操作系统的不透明 

在window的powershell 中的时候 采用的时：
![[Pasted image 20240923102050.png]]
利用chkdsk进行检查磁盘是否有坏块儿的行为 


固态硬盘SSD ：
固态硬盘的一个页  对应的是是一个芯片的页        

一个I/O总线的话  进入到闪存翻译层 （将逻辑块儿号 映射到对应的物理地址 ）
读写是用页为单位的  
里面有闪存的芯片 0  1  2  3  ..........
在处理坏块儿信息 的时候 ，他是会复制到别的闪存芯片上进行 处理 的操作逻辑 
写数据 的话 是 每个页是 可以 写一次 读无数次  
如有数据不能写入 必须将块儿内的其他的也 全部复制到一个新的 中在写入新的 

固态硬盘是可以借助 电路的机制来直接访问到对应的地址区间范围  中。。。
SSD 读写速度快 随机访问的性能高    有寻道时间跟 旋转延迟

固态如果一个块儿被擦除的次数过，重复写同一个块儿 的话 可能会坏掉 并且 很难受 
选择 累计擦除次数少的新的缓存块儿的内容 

读多写少的数据会引发迁移功能 迁移到别的地方 
寿命没问题 






























